// MOD :: THE HUMOROUS HUMORS
// BY : narra (@storm0762)

// REORGANIZED BY : max :á¶… (@the_dem)
// thank you max !!!!
/*
i know the restructured/reorganized version of this mod may confuse you so here's an index you can ctrl + f search to go to!!

1. CASE MODIFICATIONS
2. CSS
3. HUMOR COMPONENTS
4. HUMOR AUGMENTS
5. COMPONENT PERSONALITIES
6. COMBAT MODIFIERS
7. STATUS EFFECTS
8. COMBAT ACTORS
9. COMBAT ACTIONS
10. CUSTOM FUNCTIONS
11. FUNCTION MODIFICATIONS
12. MISCELLANEOUS (ITEMS, ITEM_EXECS, FISHIES, ETC.)

*/

/* instead of hoping that the javascript files we need are loaded...
function loadJS(files){
	return new Promise((resolve) => {
		let loaded = 0
		function handler(){
			loaded += 1
			if(loaded >= files.length){
				resolve()
			}
		}

		for(let file of files){
			let elm = document.createElement('script')
			elm.addEventListener('load', handler)
			elm.src = file
			document.body.appendChild(elm)
		}
	})
}

loadJS(
	[ '/js/shared/e3a2geli.js?v=1720995877429489400'
	, '/js/combat/combat.js?v=1720995877429489400'
	, '/js/combat/combatActorsJson.js?v=1720995877429489400'
	, '/js/combat/critta.js?v=1720995877429489400'
	, '/js/combat/combatActionsJson.js?v=1720995877429489400'
 	]
).then(() => {
	
	


 ...we force them to load before anything else in the mod does <--- this didn't work :(
*/

// CASE MODIFICATIONS
document.addEventListener('corru_entered', ()=>{
    if(page.path == '/local/beneath/embassy/' || page.path == '/local/ozo/') { // not gonna indent this so it looks not garbage

		env.dialogues["dreammod"] = generateDialogueObject(`
loop
    basterminal
        ALTERED
        TEXEC::\`STARTING TENSION::'\${check("e3a2_tension") || 1}'\`
            AUTOADVANCE::
        TEXEC::\`STARTING HUMORS::'\${check("e3a2_newcomp") || "normal"}'\`
            AUTOADVANCE::
        TEXEC::\`STARTING SFER::'\${check("e3a2_sfer") || "0"}'\`
            AUTOADVANCE::
        TEXEC::\`FISH SPAWN RATE::'\${check("e3a2_fishchance") ? \`\${Number(check("e3a2_fishchance")) * 100}%\`: '10%'}'\`
            AUTOADVANCE::
            SHOWIF::"e3a2__fishy"

    RESPOBJ::basterminalResp

start
    sourceless
        the terminal displays various controls and settings for the dream.
    
    basterminal
        hi :b
        CURRENT SETTINGS
        TEXEC::\`STARTING TENSION::'\${check("e3a2_tension") || 1}'\`
        TEXEC::\`STARTING HUMORS::'\${check("e3a2_newcomp") || "normal"}'\`
        TEXEC::\`STARTING SFER::'\${check("e3a2_sfer") || "0"}'\`
        TEXEC::\`FISH SPAWN RATE::'\${check("e3a2_fishchance") ? \`\${Number(check("e3a2_fishchance")) * 100}%\`: '10%'}'\`
            SHOWIF::"e3a2__fishy"
    
    RESPOBJ::basterminalResp

tension
    basterminal
        select starting tension
        1 is default
    
    RESPONSES::self
        1<+>loop
            EXEC::change("e3a2_tension", 1)
            HIDEREAD::
        2<+>loop
            EXEC::change("e3a2_tension", 2)
            HIDEREAD::
        3<+>loop
            EXEC::change("e3a2_tension", 3)
            HIDEREAD::
        4<+>loop
            EXEC::change("e3a2_tension", 4)
            HIDEREAD::
        5<+>loop
            EXEC::change("e3a2_tension", 5)
            HIDEREAD::
        6<+>loop
            EXEC::change("e3a2_tension", 6)
            HIDEREAD::

humors
    basterminal
        select starting <span class="code">humor</span> set
        normal is default
    
    RESPONSES::self
        normal<+>loop
            EXEC::change("e3a2_newcomp", "normal")
            HIDEREAD::
        abundant<+>loop
            EXEC::change("e3a2_newcomp", "abundant")
            HIDEREAD::
        too many<+>loop
            EXEC::change("e3a2_newcomp", "too many")
            HIDEREAD::
        claws<+>loop
            EXEC::change("e3a2_newcomp", "claws")
            HIDEREAD::
        eyes<+>loop
            EXEC::change("e3a2_newcomp", "eyes")
            HIDEREAD::
        ichor<+>loop
            EXEC::change("e3a2_newcomp", "ichor")
            HIDEREAD::
        light<+>loop
            EXEC::change("e3a2_newcomp", "light")
            HIDEREAD::
        bone<+>loop
            EXEC::change("e3a2_newcomp", "bone")
            HIDEREAD::
        flesh<+>loop
            EXEC::change("e3a2_newcomp", "flesh")
            HIDEREAD::
        dull<+>loop
            EXEC::change("e3a2_newcomp", "dull")
            HIDEREAD::
        spirestone<+>loop
            EXEC::change("e3a2_newcomp", "spirestone")
            HIDEREAD::
        hands<+>loop
            EXEC::change("e3a2_newcomp", "hands")
            HIDEREAD::
        metal<+>loop
            EXEC::change("e3a2_newcomp", "metal")
            HIDEREAD::
        pain<+>loop
            EXEC::change("e3a2_newcomp", "pain")
            HIDEREAD::
        lightning<+>loop
            EXEC::change("e3a2_newcomp", "lightning")
            HIDEREAD::
        heart<+>loop
            EXEC::change("e3a2_newcomp", "heart")
            HIDEREAD::
        chaos<+>loop
            EXEC::change("e3a2_newcomp", "chaos")
            HIDEREAD::
        order<+>loop
            EXEC::change("e3a2_newcomp", "order")
            HIDEREAD::
        zuka<+>loop
            EXEC::change("e3a2_newcomp", "zuka")
            HIDEREAD::
        hook<+>loop
            EXEC::change("e3a2_newcomp", "hook")
            HIDEREAD::
        spine<+>loop
            EXEC::change("e3a2_newcomp", "spine")
            HIDEREAD::

fish
    basterminal
        select fish spawn rate
        10% is default
    
    RESPONSES::self
        normal (10%)<+>loop
            EXEC::change("e3a2_fishchance", "0.1")
            HIDEREAD::
        foolish (25%)<+>loop
            EXEC::change("e3a2_fishchance", "0.25")
            HIDEREAD::
        likely (50%)<+>loop
            EXEC::change("e3a2_fishchance", "0.5")
            HIDEREAD::
        guaranteed (100%)<+>loop
            EXEC::change("e3a2_fishchance", "1")
            HIDEREAD::

sfer
    basterminal
        select starting sfer
        none is default
    
    RESPONSES::self
        none (0)<+>loop
            EXEC::change("e3a2_sfer", "DELETE")
            HIDEREAD::

        some (20)<+>loop
            EXEC::change("e3a2_sfer", 20)
            HIDEREAD::

        abundant(40)<+>loop
            EXEC::change("e3a2_sfer", 40)
            HIDEREAD::

        a lot (99)<+>loop
            EXEC::change("e3a2_sfer", 99)
            HIDEREAD::
`)

if(page.party) {
	switch(check("e3a2_newcomp")) {
		case "too many":
			page.flags.components = {
				ichor: 30,
				claws: 30,
				light: 30,
				bone: 30,
				eyes: 30,
				flesh: 30,
				dull: 30,
				spirestone: 30,
				hands: 30,
				metal: 30,
				pain: 30,
				intrusive: 30,
				lightning: 30,
				heart: 30,
				chaos: 30,
				order: 30,
				zuka: 30,
				hook: 30,
				spine: 30,
				cmb: 30,
			}
			
			page.party[0].components["primary"] = "claws"
			page.party[0].components["secondary"] = "flesh"
			page.party[0].components["utility"] = "eyes"

			page.party[1].components["primary"] = "dull"
			page.party[1].components["secondary"] = "eyes"
			page.party[1].components["utility"] = "hands"

			page.party[2].components["primary"] = "metal"
			page.party[2].components["secondary"] = "ichor"
			page.party[2].components["utility"] = "light"
				break

		case "abundant":
			page.flags.components = {
				ichor: 3,
				claws: 3,
				light: 3,
				bone: 3,
				eyes: 3,
				flesh: 3,
				dull: 3,
				spirestone: 3,
				hands: 3,
				metal: 3,
				pain: 3,
				intrusive: 3,
				lightning: 3,
				heart: 3,
				chaos: 3,
				order: 3,
				zuka: 3,
				hook: 3,
				spine: 3,
				cmb: 3,
			}
			
			page.party[0].components["primary"] = "claws"
			page.party[0].components["secondary"] = "flesh"
			page.party[0].components["utility"] = "eyes"

			page.party[1].components["primary"] = "dull"
			page.party[1].components["secondary"] = "eyes"
			page.party[1].components["utility"] = "hands"

			page.party[2].components["primary"] = "metal"
			page.party[2].components["secondary"] = "ichor"
			page.party[2].components["utility"] = "light"
				break

		case "flesh":
			page.flags.components = { flesh: 12 }

			page.party.forEach(member=>{
				member.components["primary"] = "flesh"
				member.components["secondary"] = "flesh"
				member.components["utility"] = "flesh"
			})
				break

		case "dull":
			page.flags.components = { dull: 12 }

			page.party.forEach(member=>{
				member.components["primary"] = "dull"
				member.components["secondary"] = "dull"
				member.components["utility"] = "dull"
			})
				break

		case "spirestone":
			page.flags.components = { spirestone: 12 }

			page.party.forEach(member=>{
				member.components["primary"] = "spirestone"
				member.components["secondary"] = "spirestone"
				member.components["utility"] = "spirestone"
			})
				break
				
		case "hands":
			page.flags.components = { hands: 12 }

			page.party.forEach(member=>{
				member.components["primary"] = "hands"
				member.components["secondary"] = "hands"
				member.components["utility"] = "hands"
			})
				break
		
		case "metal":
		page.flags.components = { metal: 12 }

			page.party.forEach(member=>{
				member.components["primary"] = "metal"
				member.components["secondary"] = "metal"
				member.components["utility"] = "metal"
			})
			
				break
		
		case "pain":
		page.flags.components = { pain: 12 }

			page.party.forEach(member=>{
				member.components["primary"] = "pain"
				member.components["secondary"] = "pain"
				member.components["utility"] = "pain"
			})
		
				break
		
		case "lightning":
		page.flags.components = { lightning: 12 }

			page.party.forEach(member=>{
				member.components["primary"] = "lightning"
				member.components["secondary"] = "lightning"
				member.components["utility"] = "lightning"
			})
			
				break
			
		case "heart":
		page.flags.components = { heart: 12 }

			page.party.forEach(member=>{
				member.components["primary"] = "heart"
				member.components["secondary"] = "heart"
				member.components["utility"] = "heart"
			})
		
			break
			
		case "chaos":
		page.flags.components = { chaos: 12 }

			page.party.forEach(member=>{
				member.components["primary"] = "chaos"
				member.components["secondary"] = "chaos"
				member.components["utility"] = "chaos"
			})
		
			break
			
		case "order":
		page.flags.components = { order: 12 }

			page.party.forEach(member=>{
				member.components["primary"] = "order"
				member.components["secondary"] = "order"
				member.components["utility"] = "order"
			})
		
			break
			
		case "zuka":
		page.flags.components = { zuka: 12 }

			page.party.forEach(member=>{
				member.components["primary"] = "zuka"
				member.components["secondary"] = "zuka"
				member.components["utility"] = "zuka"
			})
		
			break
			
		case "hook":
		page.flags.components = { hook: 12 }

			page.party.forEach(member=>{
				member.components["primary"] = "hook"
				member.components["secondary"] = "hook"
				member.components["utility"] = "hook"
			})
		
			break
			
		case "spine":
		page.flags.components = { spine: 12 }

			page.party.forEach(member=>{
				member.components["primary"] = "spine"
				member.components["secondary"] = "spine"
				member.components["utility"] = "spine"
			})
		
			break
		}
	}
}})


document.addEventListener('corru_entered', ()=>{
    if(page.path == '/local/beneath/embassy/') {
		
//i shouldn't have to do this, but the flan checks don't work for reasons entirely unclear to me, so i have to make this fucking shenaniganry
console.log(`creating trusiveCheck variable`)
 //holy fucking shit just define the variable you have ONE JOB
let trusiveCheck = "jesusFuckingChristJustWorkAlreadyIts10PmGodDamnIt"
console.log(`trusiveCheck variable should exist now`)
if(check("flan") == "pre-escape") {
	trusiveCheck = true
	console.log(`flan check is pre-escape, setting to true`)
}
else if(check("flan") == "post-escape") {
	trusiveCheck = true
	console.log(`flan check is post-escape, setting to true`)
}
setTimeout(()=> {
	if(!trusiveCheck) {console.log(`trusiveCheck got undefined again, somehow`)}
},
2000)
		
		if(typeof env.HUMOR_ITEMS == "undefined") env.HUMOR_ITEMS = {
			ichor: {
				name: "Ichor",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "ichor", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			claws: {
				name: "Claws",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "claws", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			light: {
				name: "Light",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "light", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			bone: {
				name: "Bone",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "bone", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			eyes: {
				name: "Eyes",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "eyes", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			flesh: {
				name: "Flesh",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "flesh", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			dull: {
				name: "Dull",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "dull", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			spirestone: {
				name: "Spirestone",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "spirestone", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			hands: {
				name: "Hands",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "hands", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			metal: {
				name: "Metal",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "metal", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			pain: {
				name: "Pain",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "pain", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			intrusive: {
				name: "???",
				value: 5,
				showIf: ()=> {checkItem("sfer_cube", 5) >=5 && trusiveCheck == "true"},
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "intrusive", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			lightning: {
				name: "Lightning",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "lightning", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			heart: {
				name: "Heart",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "heart", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			chaos: {
				name: "Chaos",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "chaos", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			order: {
				name: "Order",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "order", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			zuka: {
				name: "Zuka",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "zuka", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			hook: {
				name: "Hook",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "hook", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			spine: {
				name: "Spine",
				value: 5,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "spine", 1)
					removeItem("sfer_cube", 5)
				}
			},
			
			cmb: {
				name: "Palestone",
				value: 5,
				showIf: ()=> {checkItem("sfer_cube", 5) >=5 && check("cmb_unlocked")},
				hideRead: true,
				type: "item", //we have to lie here so that these don't take up too much space in the UI
				exec: ()=> {
					CrittaReward.safeAdd(page.flags.components, "cmb", 1)
					removeItem("sfer_cube", 5)
				}
			},
		}
		
		for(let key in env.HUMOR_ITEMS) {
			let humor = env.HUMOR_ITEMS[key]
			env.e3a2.merchant.buyResponses.replies.push({
				name: `HUMOR::${humor.name}::${humor.value}S`,
				destination: "buy",
				hideRead: true,
				showIf: ()=> checkItem("sfer_cube", 5) >=5,
				class: `commerce-item`,
				definition: `CONTENTS::1 humor of ${humor.name}`,
				exec: ()=> {humor.exec(); env.e3a2.mTotals = CrittaMenu.getTotals(); env.e3a2.updateExchangeScreen()}
			})
		}
		


// CSS
content.insertAdjacentHTML('beforeend', `<style>
/* for making player cards not overflow offscreen */
.team {
    display: flex;
    width: 100%;
    justify-content: center;
    position: absolute;
    transition: 400ms cubic-bezier(.55,0,.39,1.26);
    z-index: 30;
    flex-wrap: wrap;
}

#combat.crittamode #enemy-team .actor {
    margin: 0px 1rem;
    margin-bottom: 3rem;
}

#ally-team .actor, {
    background-color: var(--dark-color);
    margin-top: 3rem;
}

#crittaresult, #crittaresult * {
    transition: transform 2s ease-in-out, opacity 2s ease-in-out;
    text-align: center;
    z-index: 30;
}

/* turns out the dialogue-actor windows have a length limit which we have already started running into as of update 12 */
.dialogue-actor {
    max-height: unset;
}

/* humor styling */
[component="flesh"] {
    --background: url(/img/textures/truerot.gif);
    --organelle-background: url(/img/textures/truerot.gif);    
    --background-small:  url(/img/textures/truerot.gif);
    --background-size: auto;
    --background-position: center;
    --background-color: var(--dark-color);
    --accent-color: var(--bastard-color);
    --font-color: var(--bastard-color);
}

[component="dull"] {
    --background: url(/img/textures/stun.gif);
    --organelle-background: url(/img/textures/stun.gif);    
    --background-small:  url(/img/textures/stun.gif);
    --background-size: auto;
    --background-position: center;
    --background-color: var(--dark-color);
    --accent-color: var(--bright-color);
    --font-color: var(--bright-color);
}

[component="spirestone"] {
    --background: url(/img/local/uncosm/ozo/tiles/vesselmetal.gif);
    --organelle-background: url(/img/local/uncosm/ozo/tiles/vesselmetal.gif);    
    --background-small:  url(/img/local/uncosm/ozo/tiles/vesselmetal.gif);
    --background-size: auto;
    --background-position: center;
    --background-color: var(--dark-color);
    --accent-color: var(--bright-color);
    --font-color: var(--bright-color);
}

[component="hands"] {
    --background: url(/img/local/uncosm/ozo/ozospiral.gif);
    --organelle-background: url(/img/local/uncosm/ozo/ozospiral.gif);    
    --background-small: url(/img/local/uncosm/ozo/ozospiral.gif);
    --background-size: auto;
    --background-position: center;
    --background-color: var(--dark-color);
    --accent-color: var(--neutral-color);
    --font-color: var(--neutral-color);
}

[component="metal"] {
    --background: url(/img/textures/overlay.gif);
    --organelle-background: url(/img/textures/overlay.gif);    
    --background-small: url(/img/textures/overlay.gif);
    --background-size: auto;
    --background-position: center;
    --background-color: var(--dark-color);
    --accent-color: var(--friend-color);
    --font-color: var(--bright-color);
}

[component="pain"] {
    --background: url(https://narrativohazard-expunged.neocities.org/img/pain_overlay_bstrdsing.gif);
    --organelle-background: url(https://narrativohazard-expunged.neocities.org/img/pain_overlay_bstrdsing.gif);
    --background-small: url(https://narrativohazard-expunged.neocities.org/img/pain_overlay_tiny_bstrdsing.gif);
    --background-size: auto;
    --background-position: center;
    --background-color: var(--bastard-color);
    --accent-color: var(--bastard-color);
    --font-color: var(--bastard-color);
}

[component="intrusive"] {
    --background: url(/img/sprites/flantrusive/icon.gif);
    --organelle-background: url(/img/sprites/flantrusive/icon.gif);  
    --background-small: url(/img/sprites/flantrusive/icon.gif);
    --background-size: auto;
    --background-position: center;
    --background-color: var(--friend-color);
    --accent-color: var(--friend-color);
    --font-color: var(--friend-color);
}

[component="lightning"] {
    --background: url(/img/textures/fancytile.gif);
    --organelle-background: url(/img/textures/fancytile.gif);    
    --background-small: url(/img/textures/fancytile.gif);
    --background-size: auto;
    --background-position: center;
    --background-color: var(--bright-color);
    --accent-color: var(--neutral-color);
    --font-color: var(--neutral-color);
}

[component="heart"] {
    --background: url(/img/textures/blocker.gif);
    --organelle-background: url(/img/textures/blocker.gif);    
    --background-small: url(/img/textures/blocker.gif);
    --background-size: auto;
    --background-position: center;
    --background-color: var(--obesk-color);
    --accent-color: var(--obesk-color);
    --font-color: var(--obesk-color);
}

[component="chaos"] {
    --background: url(/img/textures/bflametiny.gif);
    --organelle-background: url(/img/textures/bflametiny.gif);
    --background-small: url(/img/textures/bflametran.gif);
    --background-size: auto;
    --background-position: center;
    --background-color: var(--neutral-color);
    --accent-color: var(--neutral-color);
    --font-color: var(--neutral-color);
}

[component="order"] {
    --background: url(/img/textures/papermelt.gif);
    --organelle-background: url(/img/textures/papermelt.gif);
    --background-small: url(/img/textures/papermelt.gif);
    --background-size: auto;
    --background-position: center;
    --background-color: var(--bright-color);
    --accent-color: var(--bright-color);
    --font-color: var(--bright-color);
}

[component="zuka"] {
    --background: url(/img/textures/chromebtran.gif), url(/img/textures/corruripplebastard.gif);
    --organelle-background: url(/img/textures/chromebtran.gif), url(/img/textures/corruripplebastard.gif);   
    --background-small: url(/img/textures/chromebmicrotranfast.gif), url(/img/textures/corruripplebastard.gif);
    --background-size: auto;
    --background-position: center;
    --background-color: var(--dark-color);
    --accent-color: var(--bastard-color);
    --font-color: var(--bastard-color);
}

[component="hook"] {
	--background: url(/img/textures/wound.gif), url(/img/textures/corrurippletran.gif);
	--organelle-background: url(/img/textures/rottile.png), url(/img/textures/corrurippletran.gif);
	--background-small: url(/img/textures/wound.gif), url(/img/textures/corrurippletran.gif);
    --background-size: auto;
    --background-position: center;
    --background-color: var(--dark-color);
    --accent-color: var(--obesk-color);
    --font-color: var(--obesk-color);
}

[component="spine"] {
	--background: url(/img/textures/warpedcont.gif), url(/img/textures/warp.png);
	--organelle-background: url(/img/textures/warpedcont.gif), url(/img/textures/warp.png);
	--background-small: url(/img/textures/warpedquickly.gif), url(/img/textures/warp_small.png);
    --background-size: auto;
    --background-position: center;
    --background-color: var(--dark-color);
    --accent-color: var(--friend-color);
    --font-color: var(--bright-color);
}

[component="cmb"] {
    --background: url(/img/local/orbit/core.gif);
    --organelle-background: url(/img/local/orbit/core.gif);
    --background-small: url(/img/local/orbit/core.gif);
    --background-size: auto;
    --background-position: center;
    --background-color: var(--bright-color);
    --accent-color: var(--bright-color);
    --font-color: var(--bright-color);
}

.passive-flesh_menace { background-image: var(--img, var(--fallback-status-image)), url(https://narrativohazard-expunged.neocities.org/img/passives/flop_fleshbg.gif) !important; }
.passive-dull_pragmatist { background-image: var(--img, var(--fallback-status-image)), url(https://narrativohazard-expunged.neocities.org/img/passives/flop_dullbg.gif) !important; }
.passive-spirestone_parry { background-image: var(--img, var(--fallback-status-image)), url(https://narrativohazard-expunged.neocities.org/img/passives/flop_spirestonebg.gif) !important; }
.passive-hands_penance { background-image: var(--img, var(--fallback-status-image)), url(https://narrativohazard-expunged.neocities.org/img/passives/flop_handsbg.gif) !important; }
.passive-metal_autonomous { background-image: var(--img, var(--fallback-status-image)), url(https://narrativohazard-expunged.neocities.org/img/passives/flop_metalbg.gif) !important; }
.passive-pain_rampage { background-image: var(--img, var(--fallback-status-image)), url(https://narrativohazard-expunged.neocities.org/img/passives/flop_painbg.gif) !important; }
.passive-intrusive_maladaptive { background-image: var(--img, var(--fallback-status-image)), url(https://narrativohazard-expunged.neocities.org/img/passives/flop_flantrusivebg.gif) !important; }
.passive-lightning_kugelblitz { background-image: var(--img, var(--fallback-status-image)), url(https://narrativohazard-expunged.neocities.org/img/passives/flop_lightningbg.gif) !important; }
.passive-heart_endure { background-image: var(--img, var(--fallback-status-image)), url(https://narrativohazard-expunged.neocities.org/img/passives/flop_heartbg.gif) !important; }
.passive-chaos_locknload { background-image: var(--img, var(--fallback-status-image)), url(https://narrativohazard-expunged.neocities.org/img/passives/flop_chaosbg.gif) !important; }
.passive-order_override { background-image: var(--img, var(--fallback-status-image)), url(https://narrativohazard-expunged.neocities.org/img/passives/flop_order%20bg.gif) !important; }
.passive-cmb_oicw { background-image: var(--img, var(--fallback-status-image)), url(/img/local/orbit/core.gif) !important; }
.passive-zuka_vengeance { background-image: var(--img, var(--fallback-status-image)), url(/img/textures/chromebmicrotranfast.gif) !important; }
.passive-hook_requite { background-image: var(--img, var(--fallback-status-image)), url(/img/textures/fresnelmtiny.gif) !important; }
.passive-spine_vigilance { background-image: var(--img, var(--fallback-status-image)), url(/img/textures/warpedquickly.gif) !important; }

  .statusfx-player_ethereal {
    background-image: url(https://serverboss-crossreference.nekoweb.org/extras/img/tvstatic.gif);
    background-size: auto 120%;
    background-position: center;
    opacity: 0.3;
}

  .statusfx-player_conjoined {
    background-image: url(https://serverboss-crossreference.nekoweb.org/extras/img/webs.gif);
    background-size: auto 200%;
    background-position: 60% 50%;
    background-repeat: no-repeat;
}

  .statusfx-favored {
    background-image: url(/img/textures/hazeflow.gif);
    background-size: auto 120%;
    background-position: center;
    opacity: 1;
}

  .statusfx-cursed {
    background-image: url(/img/textures/mneural.gif);
    background-size: auto 120%;
    background-position: center;
    opacity: 1;
}

  .statusfx-denatured {
    content: "";
    z-index: 10;
    background-image: url(/img/textures/warp.png);
    background-size: 50% auto;
    background-position: bottom;
    background-repeat: repeat-x;
    width: 200% !important;
    animation: status-drift 0.5s linear infinite;
}

  .statusfx-serrations {
    background-image: url(/img/textures/spikedorb.gif);
    background-size: auto 90%;
    background-position: 3% 50%;
    background-repeat: no-repeat;
}

  .statusfx-serrations::after {
    content: "";
    width: 100%;
    height: 125%;
    background-image: url(/img/textures/spiked.gif);
    background-size: auto;
    background-position: center;
    animation: hover-minor 5s ease-in-out infinite alternate;
}

  .statusfx-blindess {
    background-image: radial-gradient(circle, rgb(0, 0, 0) 50%, rgba(0,0,0,0) 60%), url(/img/textures/fear.gif), url(/img/textures/blflametran.gif);
    background-size: auto;
    mix-blend-mode: unset;
}

  .actor.status-hyperfocus_flat .statusfx-hyperfocus_flat { //please just fucking work like this i beg of you
    z-index: 10;
    background-image: url(/img/textures/regen.png);
    background-size: auto 50%;
    height: 200%;
    width: 150%;
    left: unset;
    animation: status-drift-y 4s linear infinite;
}

  .actor.status-hyperfocus_flat .statusfx-hyperfocus_flat {
    background-image: url(/img/textures/weyetran.gif);
    background-position: center;
    background-size: auto 25%;
    animation: status-drift-y-notate 3s linear infinite;
}

  .actor.status-evasion_mega .statusfx-evasion_mega {
    background-image: url(/img/textures/weyetran.gif);
    background-size: auto 100%;
    background-position: -100% right;
    background-repeat: no-repeat;
}

  .actor.status-vulnerable_mega .statusfx-vulnerable_mega {
    background-image: url(/img/textures/yeyetran.gif);
    background-position: center;
    animation: status-drift-y-notate 4s linear infinite reverse;
	height: 200%;
    width: 150%;
    left: unset;
	background-size: auto 50%;
	z-index: 10;
}

  .actor.status-windup_telegraph_flat .statusfx-windup_telegraph_flat {
    z-index: 10;
    background-image: url(/img/textures/targetpale.png);
	background-size: 50% auto;
    background-position: bottom;
    background-repeat: repeat-x;
    width: 200%;
    animation: status-drift 1s linear infinite;
}

  .actor.status-winderup .statusfx-winderup,
  .actor.status-unparriable .statusfx-unparriable  {
    z-index: 10;
    background-image: url(https://narrativohazard-expunged.neocities.org/img/passives/flop_targetc.png);
	background-size: 50% auto;
    background-position: bottom;
    background-repeat: repeat-x;
    width: 200%;
    animation: status-drift 1s linear infinite;
}

  .actor.status-windestup .statusfx-windestup {
    z-index: 10;
    background-image: url(https://narrativohazard-expunged.neocities.org/img/passives/flop_targetm.png);
	background-size: 50% auto;
    background-position: bottom;
    background-repeat: repeat-x;
    width: 200%;
    animation: status-drift 1s linear infinite;
}

  .actor.status-final_windup .statusfx-final_windup {
    z-index: 10;
    background-image: url(https://narrativohazard-expunged.neocities.org/img/passives/flop_targetr.png);
	background-size: 50% auto;
    background-position: bottom;
    background-repeat: repeat-x;
    width: 200%;
    animation: status-drift 1s linear infinite;
}

  .actor.status-windup_aim .statusfx-windup_aim {
    z-index: 10;
    background-image: url(https://narrativohazard-expunged.neocities.org/img/passives/flop_targetr.png);
	background-size: 50% auto;
    background-position: bottom;
    background-repeat: repeat-x;
    width: 200%;
    animation: status-drift 1s linear infinite;
}

  .actor.status-parriable .statusfx-parriable,
  .actor.status-parriable_ferryman .statusfx-parriable_ferryman,
  .actor.status-parriable_diff .statusfx-parriable_diff,
  .actor.status-parriable_minos .statusfx-parriable_minos {
    content: "";
    z-index: 10;
    background-image: url(/img/textures/target.png);
    background-size: 50% auto;
    background-position: bottom;	
    background-repeat: repeat-x;
    width: 200%;
    animation: status-drift 1s linear infinite;
}

.actor.status-windup_telegraph_flat .statusfx-windup_telegraph_flat,
.actor.status-winderup .statusfx-winderup,
.actor.status-windestup .statusfx-windestup,
.actor.status-final_windup .statusfx-final_windup,
.actor.status-windup_aim .statusfx-windup_aim,
.actor.status-parriable .statusfx-parriable,
.actor.status-parriable_ferryman .statusfx-parriable_ferryman,
.actor.status-parriable_diff .statusfx-parriable_diff,
.actor.status-parriable_minos .statusfx-parriable_minos,
.actor.status-unparriable .statusfx-unparriable {
    background-size: 25% auto;
    background-position: top;
}

.statusfx-windup_aim::after {
    background-image: url(/img/sprites/combat/bstrdcrosshair.gif);
    background-size: auto 90%;
    background-position: 3% 50%;
    background-repeat: no-repeat;
}

.partymember-action.winderup-action::before { /* just really hoping that this will work honestly */
    content: ":W+::";
    color: var(--friend-color);
}

.partymember-action.windestup-action::before {
    content: ":W++::";
    color: var(--obesk-color);
}

.partymember-action.final_windup-action::before {
    content: ":W+++::";
    color: var(--bastard-color);
}

.partymember-action.aiming-action::before {
    content: ":A::";
    color: var(--bastard-color);
}


  .actor.status-unnatural_carapace_flat.statusfx-unnatural_carapace_flat {
    background-image: radial-gradient(circle, rgb(0, 0, 0) 0%, rgba(0,0,0,0) 100%), url(/img/textures/carapace.gif??); /* wait why the hell are there question marks what is */
    background-size: auto;
    background-position: center;
}

  .actor.status-unnatural_wound .statusfx-unnatural_wound {
    background-image: url(/img/textures/wound.gif);
}

  .statusfx-poison {
    background-image: url(/img/textures/chromebtran.gif);
    background-size: auto 120%;
    background-position: center;
    opacity: 1;
}

  .statusfx-antidote {
    background-image: url(/img/textures/chromec.gif);
    background-size: auto 120%;
    background-position: center;
    opacity: 0.8;
}

  .statusfx-burning {
    background-image: url(/img/textures/bflametran.gif);
    background-size: auto 120%;
    background-position: center;
    opacity: 1;
}

  .statusfx-rejuvenation {
    background-image: url(/img/textures/cclouds.gif);
    background-size: auto 120%;
    background-position: center;
    opacity: 1;
}

  .statusfx-fatal_flaw {
    background-image: url(/img/sprites/combat/bstrdcrosshair.gif);
    background-size: auto 90%;
    background-position: 3% 50%;
    background-repeat: no-repeat;
}

  .statusfx-rage {
    background-image: url(/img/textures/corruripplebastard.gif);
}

.sprite-wrapper .sprite-wrapper[id^="hazardous"] {
    animation: bomber 20s ease-in-out infinite alternate;
    transform-origin: bottom;
}

.sprite-wrapper .sprite-wrapper[id^="hazardous_archival"] {
    animation: bomber 20s ease-in-out infinite alternate;
    transform-origin: bottom;
}

.sprite-wrapper .sprite-wrapper[id^="hazardous_sniper"] {
    animation: bomber 20s ease-in-out infinite alternate;
    transform-origin: bottom;
}

.sprite-wrapper .sprite-wrapper[id^="hazardous_velskin"] {
    animation: CONTAINERWOBBLEMINI 10s ease-in-out infinite alternate;
    transform-origin: bottom;
}

.sprite-wrapper .sprite-wrapper[id^="hazardous_bomber"] {
    animation: SHAKE 0.05ms linear infinite;
    transform-origin: bottom;
}

.cmb .timer {
    position: absolute;
    font-family: bastard;
    font-size: 5em;
    animation: SHAKE 30s linear infinite;
    color: var(--dark-color);
}
/* styling for spine's angelic summons */
.actor.angelactor {
    background: url(https://narrativohazard-expunged.neocities.org/img/paperplateangel.gif);
    background-size: 125% 125%;
    background-position: center;
}

.actor.angelactor.dead, .actor.angelactor.last-stand {
    background-image: url(https://narrativohazard-expunged.neocities.org/img/paperplateinverseangel.gif);
}

</style>`);


// HUMOR COMPONENTS
env.COMBAT_COMPONENTS.flesh = { // husk/fear themed
    name: "Flesh",
    slug: "flesh",
    description: "'grief and tragedy'",
    help: "'fear';'rot';'hallucinations'",

    primary: {
        alterations: [["primary", "husk_attack_player"]], // familiar strike (damage + team fear)
        stats: {
            maxhp: 4
        },
    },

    secondary: {
        alterations: [["secondary", "speak_player"]], // speak (fear + stun chance)
        stats: {
            maxhp: 4
        },
    },

    utility: {
        alterations: [
			["evade", "special_demoralize"],
			["ADD", "evade_weak"],
		], // retain focus, add custom utility
        stats: {
            maxhp: 2
        },
    },
    combatModifiers: ["flesh_adrenaline", "flesh_terminallucidity", "flesh_fightorflight"]
}

env.COMBAT_COMPONENTS.dull = { // dullfriend/dullzika themed
    name: "Dull",
    slug: "dull",
    description: "'headfirst into the unknown, for better or for worse'",
    help: "'windup';'weakened';'summons'",

    primary: {
        alterations: [["primary", "ik_attack_weak"]], // weaker veilksplitter
        stats: {
            maxhp: 3
        },
    },

    secondary: {
        alterations: [["secondary", "dullflare_weak"]], // weaker dull flare
        stats: {
            maxhp: 3
        },
    },

    utility: {
        alterations: [
            ["evade", "special_player_dullsummon"], // replace focus with a player specific dull portal, add dull overload
            ["ADD", "special_player_dullbuff"],
        ],
        stats: {
            maxhp: 5
        },
    },
    combatModifiers: ["dull_calc","dull_multitool","dull_acuteexposure"]
}

env.COMBAT_COMPONENTS.spirestone = { // archival golem/jutskin themed
    name: "Spirestone",
    slug: "spirestone",
    description: "'strength and determination'",
    help: "'windup';'empowered';'bp'",

    primary: {
        alterations: [
			["primary", "windup"], // preparation, calculated strike
			["ADD_WINDUP", "archival_smash"]
		],
		
        stats: {
            maxhp: 5
        },
    },

    secondary: {
        alterations: [["secondary", "special_barrier_allies"]], // cover
        stats: {
            maxhp: 5
        },
    },

    utility: {
        alterations: [["evade", "evade_empowered"]], // focus but it gives empowered instead of focused
        stats: {
            maxhp: 5
        },
    },
    combatModifiers: ["spirestone_rebound","spirestone_carapace","spirestone_unshakeable"]
}

env.COMBAT_COMPONENTS.hands = { // magic themed
    name: "Hands",
    slug: "hands",
    description: "'exact meaning contested';'favored by velzie'",
    help: "'favored';'cursed';'luck'",

    primary: {
        alterations: [["primary", "ceremonial_weapon"]], // corikuva, applies a random effect on hit and crit
		
        stats: {
            maxhp: 2
        },
    },

    secondary: {
        alterations: [["secondary", "prayer"]], // prayer, applies random beneficial effect to target
        stats: {
            maxhp: 2
        },
    },

    utility: {
        alterations: [["evade", "special_prophesize"]], // prophesize, applies random negative effects to foes, applies random beneficial effects to allies, excluding the user
        stats: {
            maxhp: 3
        },
    },
    combatModifiers: ["hands_trial","hands_allseeing","hands_sacrifice"]
}

env.COMBAT_COMPONENTS.metal = { // golem themed
    name: "Metal",
    slug: "metal",
    description: "'curiosity and engineering'",
    help: "'barrier';'bp dependent statuses';'golems'",

    primary: {
        alterations: [["primary", "salvage"]], // salvage, 2 base damage with obscenely low crit rate, summons golem on crit
		
        stats: {
            maxhp: 2
        },
    },

    secondary: {
        alterations: [["secondary", "metal_barrier"]], // constructor shield but it gives a random bp effect on crit??
        stats: {
            maxhp: 2
        },
    },

    utility: {
        alterations: [["evade", "berserk"]], // basic golem's berserk
        stats: {
            maxhp: 4
        },
    },
    combatModifiers: ["metal_calc","metal_explode","metal_groundsmind"]
}

env.COMBAT_COMPONENTS.pain = { // secri/zuzucri themed
    name: "Pain",
    slug: "pain",
    description: "'selfishness, often to the detriment of others'",
    help: "'self-damage';'puppet';'husks'",

    primary: {
        alterations: [["primary", "special_playershelf_annihilate"]], 
        stats: {
            maxhp: 3
        },
    },

    secondary: {
        alterations: [["secondary", "infiltrate"]], // infiltrate - like speak, but on crit it gives an effect that inverts the viable targets for beneficial and offensive actions to benefit the user's team
        stats: { // aug - replace infiltrate with swarm, an action with a higher crit rate that summons a husked version of the target on crit, but can only keep one of those alive at a time
            maxhp: 3
        },
    },

    utility: {
        alterations: [["evade", "special_raise"]], // raise - like chant, but it summons a husk on a very rare crit
        stats: { // aug - replace raise with two actions, the first guarenteeing a husk spawn in exchange for self damage, the second guarenteeing a stronger husk spawn in exchange for greater self damage
            maxhp: 4
        },
    },
    combatModifiers: ["pain_terriblelife", "pain_reflexes", "pain_secri"]
}

if(check("flan")) {
	env.COMBAT_COMPONENTS.intrusive = { // theme is self-explanatory :P
		name: "???",
		slug: "intrusive",
		//showIf: ()=> check("flan"),
		//dontSpawnNormally: true,
		description: "'indicates flaw in reading';'meaning unclear'",
		help: "'windup';'thoughtspace damage';'gambling'",

		primary: {
			alterations: [
				["primary", "trusive_smash_weak"],
			] // preparation, unnatural strike
			// aug - thoughtsplitter - applies all of unnatural strike effects on hit except for stun, applies weak point on crit
		},

		secondary: {
			alterations: [["secondary", "special_mass_frenzy"]] // wound thoughtspace - destabilize thoughtspace but instead of destabilizing it just uses frenzy on everyone
			// aug - consume thoughtspace - destabilize thoughtspace but instead of destabilizing it you just fuckign BITE everyone
		},

		utility: {
			alterations: [["evade", "special_intrusive_alt"]] // gamble - our beloved gambling, but altered to let the user summon intrusive actors on the enemy or ally team
			// aug - intrude - fucked up and evil gamble that has like 20 more options for no good reason
		},
		combatModifiers: ["intrusive_betrayal","intrusive_calc","intrusive_unknown_real"]
	}
}

env.COMBAT_COMPONENTS.lightning = { // themed after light's riskiness cranked up to 11
    name: "Lightning",
    slug: "lightning",
    description: "'followed by chaos';'bad omen'",
    help: "'denatured';'madness';'stun'",

    primary: {
        alterations: [["primary", "wild_claw"]], // mad claw but it can give harsher effects on crit and if you miss you hit yourself
        stats: { // aug - greater revision, no status effects of its own but it inverts the target team's beneficial statuses on crit (and you still hit yourself if you miss)
            maxhp: 3
        },
    },

    secondary: {
        alterations: [["secondary", "denature"]], // fuck you get DENATURED !!!!
        stats: { // aug - fuck you thoughtspace get DENATURED !!!!!!!
            maxhp: 3
        },
    },

    utility: {
        alterations: [["evade", "special_invite_storm_mega"]], // invite storm but More ????
        stats: { // aug - invoke blindess (gives fear and blindness, which is like madness but it activates 100% of the time)
            maxhp: 5
        },
    },
    combatModifiers: ["lightning_storm","lightning_terror","lightning_selfglee"]
}

env.COMBAT_COMPONENTS.heart = { // themed after the pale hall's whole deal
    name: "Heart",
    slug: "heart",
    description: "'faith, often blind'",
    help: "'stun';'cursed';'spectres';'tunnel vision'",

    primary: {
        alterations: [["primary", "grasp_weak"]], // i'm just gonna look through the new combat actions and see if anything catches my eye here
        stats: { // aug - ditto :P
            maxhp: 3
        },
    },

    secondary: {
        alterations: [["secondary", "falseprayer"]], // unholy prayer from the fucked up and evil hands husk
        stats: { // aug - okidoia - rital but make it unholy prayer >:)
            maxhp: 3
        },
    },

    utility: {
        alterations: [["evade", "evade_hyper"]], // chant-like that applies no statuses, only does damage, low accuracy and crit rate, summons spectres (scrapped this, gonna make an offbrand RUSH instead)
        stats: { // aug - gather/release - plan/enact-like pair, gather gives the user 2-4 turns of ethereal sfer, release consumes all turns of ethereal sfer and summons a shit ton of spectres (maybe with an annihilation menu to let you choose what kind of spawns you want??)
            maxhp: 3
        },
    },
    combatModifiers: ["heart_calc","heart_desperation","heart_mutual"]
}

env.COMBAT_COMPONENTS.chaos = { // GUNZ THEMED !!!!!!!!!!!! :bsteliousintnt:
    name: "Chaos", //NOTE TO SELF::TENSION LOCK THIS HUMOR TO TENSION 3 BEFORE RELEASE
    slug: "chaos",
    description: "'yearning for righteous violence'",
    help: "'inaccurate attacks';'stun';'windup';'critical flaw'",
	//showIf: () => env.crittaMap ? (env.crittaMap.tension >= 1) : true, //TODO::make this affect combat modifiers as well
	//dontSpawnNormally: true,

    primary: {
        alterations: [["primary", "special_fullauto_player"]], // full auto (as seen in golem maintenance)
        stats: { // aug - not sure... fuller auto is already a modded thing (shotgun ? maybe ? question mark ?)
            maxhp: 3 // aug has been decided !!! GO GO GADGET SYMBIOTIC SHOTGUN !!!!!! (full auto but all attacks are centered on a single target, and also wayyy faster)
        },
    },

    secondary: {
        alterations: [["secondary", "sidearm"]], // sidearm (as seen in the escape sequence)
        stats: { // aug - forced reset? maybe as a "pov you're in a framing device" reference ?
            maxhp: 2
        },
    },

    utility: {
        alterations: [["evade", "windup_cover"], ["ADD", "unfocused_shot"], ["ADD_WINDUP", "focused_shot_weak"], ["ADD_WINDUP", "hold_aim"]], // normal utility action ??? ? NO. SNIPER time now (but weaker so it's not horrifically busted (jesus christ it does ten base damage??))
        stats: { // aug - RPG !!!!!!!!!!! EXPLOSIONS !!!!!!!!!!!!!!!!!!!!!!!!! VIOLENCE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            maxhp: 2
        },
    },
    combatModifiers: ["chaos_calc", "chaos_badsport", "chaos_infection"]
}

env.COMBAT_COMPONENTS.order = { // DAEMONS THEMED >:)
    name: "Order", 
    slug: "order",
    description: "'desire for control'",
    help: "'repairs';'critical flaw';'open wound';'daemons'",
	//showIf: () => env.crittaMap ? (env.crittaMap.tension >= 1) : true, //TODO::make this affect combat modifiers as well
	//dontSpawnNormally: true,

    primary: {
        alterations: [["primary", "windup"], ["ADD_WINDUP", "special_rule_player"]], // continuous adjustment
        stats: { // aug - continuous rewrite (but nerfed to make its description actually true :P)
            maxhp: 2
        },
    },

    secondary: {
        alterations: [["secondary", "wound_stab"]], // stab but it inflicts 3T:OPEN WOUND on crit with a 15% crit rate?
        stats: { // aug - enforcement
            maxhp: 2
        },
    },

    utility: {
        alterations: [["evade", "special_player_newprocess"]], // new process but a good deal weaker
        stats: { // aug - new process but the crit rate is wayy lower and it summons full daemons instead of just IDEAs >:)
            maxhp: 2
        },
    },
    combatModifiers: ["order_power", "order_item", "order_imp"]
}

env.COMBAT_COMPONENTS.zuka = { // themed after claws but even more insane and with Even More Explosions
	name: "Zuka",
	slug: "zuka",
	description: "'fury, often misguided'",
	help: "'windup';'extreme damage';'rage'",

	primary: {
		alterations: [["primary", "windup"], ["ADD_WINDUP", "cavik_attack_mega"]], // IND (improvised nuclear device) - -1HP base damage, high crit chance, hit all foes for -4HP on crit (initial attack is delayed to emulate throwing the thing, crit explosion happens extremely fast but after another delay)
		stats: { // aug - kivtezruka - like IND but it also gives +2T:DESTABILIZED and +2T:VULNERABLE on top of extra damage from crits :D
			maxhp: 1
		},
	},

	secondary: {
		alterations: [["secondary", "parastrike"]], // parastrike - what if scramble also exploded (-2HP base damage, low crit chance, hit all foes for -2HP +1T:VULNERABLE on crit)
		stats: { // aug - extracall - what if frenzy also exploded (-1HP base damage, lower crit chance, hit all foes for -1HP and use this action on another random target on crit)
			maxhp: 1
		},
	},
	
	utility: {
		alterations: [["evade", "rage"], ["ADD", "special_rally"]], // rage and rally - rage is to offering what rush is to focus | rally removes rage and gives all of the user's allies +1T:FOCUSED and +SURGE (except da user themselves :P)
		stats: { // aug - swap rage with wrath - fucked up and evil final offering that uses your primary action x number of times for HP consumed
			maxhp: 5
		},
	},
	combatModifiers: ["zuka_unstoppable", "zuka_ind", "zuka_grail"]
}

env.COMBAT_COMPONENTS.hook = { // sort of like light?? broadly themed around "defying the rules of the framing device"
	name: "Hook",
	slug: "hook",
	description: "'ingenuity and defiance'",
	help: "'open wound';'stun';'agony';'incoherence'",

	primary: {
		alterations: [["primary", "vicious_claw"]], // vicious claw - mad claw clone basically :P inflicts one of +2T:OPEN WOUND/+1T:STUN/+AGONY - agony (removed by regen) applies one of four effects any time the affected actor takes an action::-2HP/+1T:PUNCTURE/+1T:OPEN WOUND/+1T:STUN
		stats: { // aug - revoke - sort of like revise, but it takes beneficial statuses from the target and transfers them to the user on crit
			maxhp: 2
		},
	},

	secondary: {
		alterations: [["secondary", "windup"], ["ADD_WINDUP", "calculated_stab"]], // strip carapace - what if destabilize was just . fuck you +3T:OPEN WOUND (+AGONY on crit maybe?)
		stats: { // aug - dissolve thoughtspace - fuck you +2T:OPEN WOUND to EVERYONE !!!!!!
			maxhp: 2 // changed my mind :P both have been replaced with windup action versions of stab and frenzy
		},
	},
	
	utility: {
		alterations: [["evade", "special_inversion_player"]], // inversion - enough said :P
		stats: { // aug - rewrite - invert negative statuses of allies except yourself, invert beneficial statuses of foes AND yourself
			maxhp: 5
		},
	},
	combatModifiers: ["hook_keepers", "hook_calc", "hook_playwright"]
}

env.COMBAT_COMPONENTS.spine = { // themed after "angels" as an opposite to the framing device's daemons
    name: "Spine", // this thing is the opposite of order but in a different direction from chaos; spine is to order what hook is to light
    slug: "spine",
    description: "'hope, regardless of circumstance'",
    help: "'empowered';'open wound';'destabilized';'weakened';'angels'",

    primary: {
        alterations: [["primary", "empowering_strike"]], // -1HP base damage, 80% accuracy, 20% crit rate, +2T:EMPOWERED to allies on crit (allies with windup actions will also receive windup)
        stats: { // aug - focusing strike - -2HP base damage, 90% accuracy, 10% crit rate, +1T:FOCUSED to allies in crit
            maxhp: 2
        },
    },

    secondary: {
        alterations: [["secondary", "deform"], ["ADD", "special_spine_merge"]], // - -2HP base damage, 70% accuracy, 10% crit rate, inflict one of (+2T:OPEN WOUND, +2T:DESTABILIZED, +2T:WEAKENED) on hit, summon angel on crit - special_spine_merge removes all angels from the user's team in exchange for summoning a much stronger angel in their stead
        stats: { // aug - reconstruct - requires -3HP base damage, 70% accuracy, 10% crit rate, inflict one of the statuses from before but one turn longer, summon greater angel and inflict another status on crit
            maxhp: 2
        },
    },

    utility: {
        alterations: [["evade", "spine_blink"]], // grant +2T:UNNATURAL SPEED
        stats: { // aug - cloaking cover - +2BP +CLOAKED (-75% IN:HIT%, CRIT%, prevent vulnerable and hypervulnerable while barrier is up) to allies
            maxhp: 4
        },
    },
    combatModifiers: ["spine_calc", "spine_dissociated", "spine_panacea"]
}

/*
env.COMBAT_COMPONENTS.tine = { // general time fuckery themed
	name: "Tine", // tine loop
	slug: "tine",
	description: "'triumph and suffering through repetition'",
	help: "'fill this out later please THANKS'",

	primary: {
		alterations: [["primary", "vicious_claw"]], // vicious claw - mad claw clone basically :P inflicts one of +2T:OPEN WOUND/+1T:STUN/+AGONY - agony (removed by regen) applies one of four effects any time the affected actor takes an action::-2HP/+1T:PUNCTURE/+1T:OPEN WOUND/+1T:STUN
		stats: { // aug - revoke - sort of like revise, but it takes beneficial statuses from the target and transfers them to the user on crit
			maxhp: 2
		},
	},

	secondary: {
		alterations: [["secondary", "windup"], ["ADD_WINDUP", "calculated_stab"]], // strip carapace - what if destabilize was just . fuck you +3T:OPEN WOUND (+AGONY on crit maybe?)
		stats: { // aug - dissolve thoughtspace - fuck you +2T:OPEN WOUND to EVERYONE !!!!!!
			maxhp: 2 // changed my mind :P both have been replaced with windup action versions of stab and frenzy
		},
	},
	
	utility: {
		alterations: [["evade", "special_inversion_player"]], // inversion - enough said :P
		stats: { // aug - rewrite - invert negative statuses of allies except yourself, invert beneficial statuses of foes AND yourself
			maxhp: 5
		},
	},
	combatModifiers: ["hook_keepers", "hook_calc", "hook_playwright"]
}
*/
if(check("cmb_unlocked")) {
	env.COMBAT_COMPONENTS.cmb = { // combine themed (outlining this now so i don't forget what i want to do for the humor once i'm done with the boss) - 4/24 update::gonna also theme this around the new status effects that i haven't done much with thus far methinks
		name: "Palestone", // TODO::put this in an if statement
		slug: "cmb",
		description: "'leadership and pragmatism';'memory bleed detected'",
		help: "'antidote';'hypervulnerable';'windup';'soldiers'",
		//dontSpawnNormally: true, // comment this out once everything's done

		primary: {
			alterations: [["primary", "tozik_attack_cmb"]], // like bazruka but it inflicts chemical fire instead of puncture and no additional damage
			/* stats: { // aug - some kind of superbuffed corruskivi? +2HP and +2T:ANTIDOTE to allies on crit?
				maxhp: 2 // changed my mind :P i have now swapped them >:)
			}, */
		},

		secondary: {
			alterations: [["secondary", "spy_hypervulnerable"]], // spy but it inflicts +2T:HYPERVULNERABLE
			stats: { // aug - find flaw but it inflicts +2T:HYPERVULNERABLE and +FATAL FLAW (like critical flaw, but with its crit effect doubled)
				maxhp: 2
			},
		},

		utility: {
			alterations: [["evade", "windup_cmb"], ["ADD_WINDUP", "special_combinesummon"]], // reinforce and stim boost - dull portal but it summons a dropship that THEN summons soldiers and disappears after like five turns and dull overload that gives everyone surge
			stats: { // aug - superportal - dull contrivance style thing, summons soldiers in four tiers (corresponding to the phases of the boss fight) also it's a windup+ action (good luck to future me for figuring THAT one out !!!!)
				maxhp: 4
			},
		},
		combatModifiers: ["cmb_desperation", "cmb_response", "cmb_calc"]
	}
}
if(check("xen_unlocked")) {
	env.COMBAT_COMPONENTS.xen = { // half life themed (outlining this now so i can know peace)
		name: "(WIP)", // TODO::uncomment the if statement once everything's done
		slug: "xen", // oh god what do we name this thing
		description: "'ummm uhhh i will figure this out later';'memory bleed detected'",
		help: "'windup';'stun';'wildlife';'teleportation'",

		primary: {
			alterations: [["primary", "windup"], ["ADD_WINDUP", "displace"]], // displace - salvage-like with lower accuracy and crit rate but stuns on hit and summons 2 xen creatures on crit (max 6 or 8 probably?)
			 stats: { // aug - spectroscopy - targeted dull contrivance-y thing; choose between four tiers of summons with their on chances of backfiring and exploding the user and their team
				maxhp: 2
			},
		},

		secondary: {
			alterations: [["secondary", "windup"], ["ADD_WINDUP", "vortigaunt_lightning"]], // uhhhh h   h  figure out something better for this later i think
			stats: { // aug - black mesa alien controller telekinesis effect maybe ??
				maxhp: 2
			},
		},

		utility: {
			alterations: [["evade", ""]], // self-displace - select duration, user becomes pseudo-stunned and untargetable upon selection, status is applied to handle the shenanigans; random shit happens to the displaced shell (sometimes injuries, sometimes helpful, varies in intensity), and will use X number of item actions (and maybe some boosted item actions and entirely new ones?) corresponding to how long it was away
			stats: { // aug - expedition - like self-dislace, but with greater control over loot; select between a series of destinations, risk levels, and items
				maxhp: 6
			},
		},
		combatModifiers: [""]
	}
}


// HUMOR AUGMENTS
    // flesh
env.ACTOR_AUGMENTS.generic.necrotic_strike = {
    slug: "necrotic_strike",
    name: "Necrotic Strike",
    image: "/img/sprites/combat/augs/claw.gif",
    description: "'malform limbs further still';'applies rot on top of fear'",
    alterations: [["husk_attack_player", "necrotic_strike"]],
    component: ["primary", "flesh"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.flesh_psychosis = {
    slug: "flesh_psychosis",
    name: "Psychosis",
    image: "/img/sprites/combat/augs/parasite.gif",
    description: "'alter remains to communicate destruction';'greater stunning capabilities'",
    alterations: [["speak_player", "player_psychosis"]],
    component: ["secondary", "flesh"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.special_player_chant = {
    slug: "special_player_chant",
    name: "Psychogenesis",
    image: "/img/sprites/combat/augs/sacrifice.gif",
    description: "'weaponize foes' greatest fears';'convey malignant thoughtforms via speech'",
    alterations: [["special_demoralize", "special_player_chant"]],
    component: ["utility", "flesh"],
    cost: 2
}

    // dull
env.ACTOR_AUGMENTS.generic.enhance_ik_attack = {
    slug: "enhance_ik_attack",
    name: "Veilksplitter",
    image: "/img/sprites/combat/augs/cripple.gif",
    description: "'utilize greater dull connectors';'greatly enhance strike'",
    alterations: [["ik_attack_weak", "windup"],
				["ADD_WINDUP", "ik_attack_player"],
				["ADD_WINDUP", "focused_windup"]
			],
    component: ["primary", "dull"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.enhance_dullflare = {
    slug: "enhance_dullflare",
    name: "Dull Flare",
    image: "/img/sprites/combat/augs/bazruka.gif",
    description: "'boost dull flow greatly';'enhance damage and accuracy'",
    alterations: [
				["dullflare_weak", "windup"],
				["ADD_WINDUP", "dullflare_player"]
			],
    component: ["secondary", "dull"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.enhance_dullsummon = {
    slug: "enhance_dullsummon",
    name: "Weaponized Contrivance",
    image: "/img/sprites/combat/augs/bazruka.gif",
    description: "'greatly extend range of potential summons';'present many targets';'escalating negative effects from dull exposure'",
    alterations: [["special_player_dullsummon", "special_dullsummon_select"],
				["special_player_dullbuff", "special_player_dullbuff_aug"],
			],
    component: ["utility", "dull"],
    cost: 2
}

	// spirestone
env.ACTOR_AUGMENTS.generic.haymaker = {
    slug: "haymaker",
    name: "Force Multiplier",
    image: "/img/sprites/combat/augs/cripple.gif",
    description: "'directly upgrade limbs';'recede to empower massive strike';'consume focus for greater damage and stun'",
    alterations: [["ADD_WINDUP", "haymaker"],
				["ADD_WINDUP", "spirestone_focused"]
			],
    component: ["primary", "spirestone"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.hardening_cover = {
    slug: "hardening_cover",
    name: "Offensive Applicators",
    image: "/img/sprites/combat/augs/barrier.gif",
    description: "'upgrade satik applicators';'barrier enhances combat ability while active'",
    alterations: [["special_barrier_allies", "special_hardening_barrier"]],
    component: ["secondary", "spirestone"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.team_huddle = {
    slug: "team_huddle",
    name: "Team Huddle",
    image: "/img/sprites/combat/augs/sacrifice.gif",
    description: "'recede and encourage team';'strike with greater power'",
    alterations: [["evade_empowered", "team_huddle"]],
    component: ["utility", "spirestone"],
    cost: 2
}

	// hands
env.ACTOR_AUGMENTS.generic.ceremonial_judgement = {
    slug: "ceremonial_judgement",
    name: "Divine Judgement",
    image: "/img/sprites/combat/augs/claw.gif",
    description: "'enchant weapon';'call forth divine intervention'",
    alterations: [["ceremonial_weapon", "ceremonial_judgement"]],
    component: ["primary", "hands"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.special_prayer_allies = {
    slug: "special_prayer_allies",
    name: "Combat Rites",
    image: "/img/sprites/combat/augs/distract.gif",
    description: "'greatly lengthen prayer';'strengthen connection with chosen deity'",
    alterations: [["prayer", "special_prayer_allies"]],
    component: ["secondary", "hands"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.special_tarot = {
    slug: "special_tarot",
    name: "Tarot Deck",
    image: "/img/sprites/combat/augs/countercall.gif",
    description: "'utilize wildly unpredictable magical item';'can grant massive boon to allies and foes'",
    alterations: [["special_prophesize", "special_tarot"]],
    component: ["utility", "hands"],
    cost: 2
}

	//metal
env.ACTOR_AUGMENTS.generic.reforge = {
    slug: "reforge",
    name: "Foundry Vat",
    image: "/img/sprites/combat/augs/drone.gif",
    description: "'attach foundry vat to repair tool';'grant access to greater golem schematics'",
    alterations: [
		["salvage", "windup"],
		["ADD_WINDUP", "reforge"]
	],
    component: ["primary", "metal"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.special_chitinous_barrier = {
    slug: "special_chitinous_barrier",
    name: "Defensive Applicators",
    image: "/img/sprites/combat/augs/parasite.gif",
    description: "'upgrade satik applicators';'barrier provides passive defense while active'",
    alterations: [["metal_barrier", "special_chitinous_barrier"]],
    component: ["secondary", "metal"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.berserk_mega = {
    slug: "berserk_mega",
    name: "Maximum Damage",
    image: "/img/sprites/combat/augs/sacrifice.gif",
    description: "'massively boost offensive capabilities';'potentially fatal if used recklessly'",
    alterations: [["berserk", "berserk_mega"]],
    component: ["utility", "metal"],
    cost: 2
}

	//pain
env.ACTOR_AUGMENTS.generic.annihilation = {
    slug: "annihilation",
    name: "Unparelleled Aggression",
    image: "/img/sprites/combat/augs/ultraspy.gif",
    description: "'adopt exponetially more aggressive attack';'overexert limbs to cause massive trauma';'greater self-damage'",
    alterations: [
		["special_playershelf_annihilate", "windup"],
		["ADD_WINDUP", "special_playershelf_annihilate_mega"]
	],
    component: ["primary", "pain"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.mitosis = {
    slug: "mitosis",
    name: "Biogenesis",
    image: "/img/sprites/combat/augs/sacrifice.gif",
    description: "'utilize own flesh to create allies';'significant self-damage'",
    alterations: [
		["special_raise", "raise_sacrifice"],
		["ADD", "raise_sacrifice_mega"]
	],
    component: ["utility", "pain"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.secri = {
    slug: "secri",
    name: "Secri Hunting Habits",
    image: "/img/sprites/combat/augs/surge.gif",
    description: "'adopt destructive infiltration method';'create husk of target on crit'",
    alterations: [["infiltrate", "swarm"]],
    component: ["secondary", "pain"],
    cost: 2
}

	//trusive
env.ACTOR_AUGMENTS.generic.thoughtsplitter = {
    slug: "thoughtsplitter",
    name: "Weaponized Incoherence",
    image: "/img/sprites/combat/augs/revise.gif",
    description: "'wield incoherent thoughtforms as a weapon';'massive damage'",
    alterations: [["trusive_smash_weak", "windup"], ["ADD_WINDUP", "trusive_smash"]],
    component: ["primary", "intrusive"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.consume = {
    slug: "consume",
    name: "Thoughtspace Siphoning",
    image: "/img/sprites/combat/augs/massdestabilize.gif",
    description: "'ignore thoughtspace specifications';'consume all actors for significant damage and healing'",
    alterations: [["special_mass_frenzy", "special_mass_bite"]],
    component: ["secondary", "intrusive"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.intrude = {
    slug: "intrude",
    name: "Double Or Nothing",
    image: "/img/sprites/combat/augs/bstrd.gif",
    description: "'greatly empower wheel';'many branching options'",
    alterations: [["special_intrusive_alt", "special_intrusive_mega"]],
    component: ["utility", "intrusive"],
    cost: 2
}

	//lightning
env.ACTOR_AUGMENTS.generic.revise_all = {
    slug: "revise_all",
    name: "Instant Rewrite",
    image: "/img/sprites/combat/augs/revise.gif",
    description: "'acquire leverage on false structure';'turn beneficial statuses against foes'",
    alterations: [["wild_claw", "revise_all"]],
    component: ["primary", "lightning"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.mass_denature = {
    slug: "mass_denature",
    name: "Groundsmindry Overload",
    image: "/img/sprites/combat/augs/massdestabilize.gif",
    description: "'broadcast denaturing signal';'easily fatal for all combatants'",
    alterations: [["denature", "special_mass_denature"]],
    component: ["secondary", "lightning"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.blindness = {
    slug: "blindness",
    name: "Invoke Blindness",
    image: "/img/sprites/combat/augs/surge.gif",
    description: "'weaponize horrific discoveries';'terrify and blind foes'",
    alterations: [["special_invite_storm_mega", "special_invoke_blindness"]],
    component: ["utility", "lightning"],
    cost: 2
}

	//heart
env.ACTOR_AUGMENTS.generic.coordinated_assault = {
    slug: "coordinated_assault",
    name: "Planned Charge",
    image: "/img/sprites/combat/augs/sacrifice.gif",
    description: "'share mental overexertion';'inspire allies to charge forward with reckless abandon'",
    alterations: [["evade_hyper", "coordination_hyper"]],
    component: ["utility", "heart"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.cripple = {
    slug: "cripple",
    name: "Neural Strike",
    image: "/img/sprites/combat/augs/cripple.gif",
    description: "'upgrade standard dull nodes to larger ones';'hit with greater concussive force'",
    alterations: [["grasp_weak", "cripple_heart"]],
    component: ["primary", "heart"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.okidoia = {
    slug: "okidoia",
    name: "Overlap Manipulation",
    image: "/img/sprites/combat/augs/countercall.gif",
    description: "'twist overlap to inhibit foes';'conjure spectral allies'",
    alterations: [["falseprayer", "special_falseprayer_foes"]],
    component: ["secondary", "heart"],
    cost: 2
}

	//chaos
env.ACTOR_AUGMENTS.generic.shotgun = {
    slug: "shotgun",
    name: "#00 Buckshot",
    image: "/img/sprites/combat/augs/spike.gif",
    description: "'swap automatic rifle with bright shotgun';'rapid hits on singular target'",
    alterations: [["special_fullauto_player", "fullauto_shotgun"]],
    component: ["primary", "chaos"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.frt = {
    slug: "frt",
    name: "Forced Reset Trigger",
    image: "/img/sprites/combat/augs/claw.gif",
    description: "'equip illegal modifications';'accuracy through volume of fire'",
    alterations: [["sidearm", "frenzy_sidearm"]],
    component: ["secondary", "chaos"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.m202 = {
    slug: "m202",
    name: "Rocket Launcher",
    image: "/img/sprites/combat/augs/bazruka.gif",
    description: "'acquire multi-barrel bright weapon';'seemingly capable of loading an endless number of munitions'",
    alterations: [["windup_cover", "reload_missile"], ["unfocused_shot", "spy_laser"], ["ADD_WINDUP", "special_enact_missile"], ["ADD_WINDUP", "plot_reload"]],
    component: ["utility", "chaos"],
    cost: 2
}

	//order
env.ACTOR_AUGMENTS.generic.judgement = {
    slug: "judgement",
    name: "Actor State Management",
    image: "/img/sprites/combat/augs/massdestabilize.gif",
    description: "'directly influence thoughtspace';'massive damage'",
    alterations: [["ADD_WINDUP", "special_judgement_player"]],
    component: ["primary", "order"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.enforcement = {
    slug: "enforcement",
    name: "Enforcement",
    image: "/img/sprites/combat/augs/claw.gif",
    description: "'gain control over actor path management';'empower relentless assault'",
    alterations: [["wound_stab", "enforce_player"]],
    component: ["secondary", "order"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.reallocate = {
    slug: "reallocate",
    name: "Counterinstruction",
    image: "/img/sprites/combat/augs/revise.gif",
    description: "'insert conflicting instructions into framing device';'reallocate daemons to ally team'",
    alterations: [["special_player_newprocess", "special_newprocess_mega"]],
    component: ["utility", "order"],
    cost: 2
}

	//zuka
env.ACTOR_AUGMENTS.generic.kivtezruka = {
    slug: "kivtezruka",
    name: "Groundsmindry Micro-relays",
    image: "/img/sprites/combat/augs/bazruka.gif",
    description: "'switch explosive design';'mark foes for death'",
    alterations: [["ADD_WINDUP", "kivtezruka"]],
    component: ["primary", "zuka"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.extracall = {
    slug: "extracall",
    name: "Extracall",
    image: "/img/sprites/combat/augs/claw.gif",
    description: "'adopt more aggressive fighting style';'introduce destructive interference';'cascading detonations'",
    alterations: [["parastrike", "frenzy_extracall"]],
    component: ["secondary", "zuka"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.kamikaze = {
    slug: "kamikaze",
    name: "Last Stand",
    image: "/img/sprites/combat/augs/sacrifice.gif",
    description: "'extend self beyond limits';'consume HP for flurry of strikes'",
    alterations: [["rage", "special_wrath_enact"]],
    component: ["utility", "zuka"],
    cost: 2
}

	//hook
env.ACTOR_AUGMENTS.generic.revoke = {
    slug: "revoke",
    name: "Revoke",
    image: "/img/sprites/combat/augs/revise.gif",
    description: "'grasp at false structures';'steal beneficial statuses from foes'",
    alterations: [["vicious_claw", "revoke"]],
    component: ["primary", "hook"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.calculated_frenzy = {
	slug: "calculated_frenzy",
	name: "Guktik Blades",
	image: "/img/sprites/combat/augs/claw.gif",
	description: "'attach a pair of external stabbing implements';'may inspire chains of vicious attacks'",
	alterations: [["ADD_WINDUP", "calculated_frenzy"]],
	component: ["secondary", "hook"],
	cost: 2
}

env.ACTOR_AUGMENTS.generic.rewrite = {
	slug: "rewrite",
	name: "Mass Revision",
	image: "/img/sprites/combat/augs/distract.gif",
	description: "'take hold of reality';'rewrite the script'",
	alterations: [["special_inversion_player", "special_rewrite"]],
	component: ["utility", "hook"],
	cost: 2
}

env.ACTOR_AUGMENTS.generic.focusing_strike = {
    slug: "focusing_strike",
    name: "Focusing Strike",
    image: "/img/sprites/combat/augs/distract.gif",
    description: "'switch strategies';'strikes focus ally attacks rather than empowering'",
    alterations: [["empowering_strike", "focusing_strike"]],
    component: ["primary", "spine"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.reconstruct = {
	slug: "reconstruct",
	name: "Overwrite",
	image: "/img/sprites/combat/augs/surge.gif",
	description: "'directly overwrite foe's instructions';'summon and merge yet greater angels'",
	alterations: [["deform", "windup"], ["special_spine_merge", "special_spine_merge_mega"], ["ADD_WINDUP", "reconstruct"]],
	component: ["secondary", "spine"],
	cost: 2
}

env.ACTOR_AUGMENTS.generic.cloak = {
	slug: "cloak",
	name: "Cloaking Skin",
	image: "/img/sprites/combat/augs/barrier.gif",
	description: "'upgrade satik applicators';'barrier provides cloaking capabilities'",
	alterations: [["spine_blink", "special_cloaking_barrier"]],
	component: ["utility", "spine"],
	cost: 2
}

	//palestone
env.ACTOR_AUGMENTS.generic.incendiary = {
    slug: "incendiary",
    name: "Sterilization",
    image: "/img/sprites/combat/augs/bazruka.gif",
    description: "'exchange healing tool for potent incendiary device';'significant damage over time'",
    alterations: [["tozik_attack_cmb", "bazruka_incendiary"]], // gonna swap these around actually
    component: ["primary", "cmb"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.fatal_flaw = {
    slug: "fatal_flaw",
    name: "Expose Flaw",
    image: "/img/sprites/combat/augs/ultraspy.gif",
    description: "'enhance and overexert senses';'mark enemy for swift destruction'",
    alterations: [["spy_hypervulnerable", "ultra_spy_cmb"]],
    component: ["secondary", "cmb"],
    cost: 2
}

env.ACTOR_AUGMENTS.generic.superportal = {
    slug: "superportal",
    name: "Homeworld Connector",
    image: "/img/sprites/combat/augs/massdestabilize.gif",
    description: "'greatly increase range and numbers of available summons';'leave user extremely vulnerable during cooldown period'",
    alterations: [["windup_cmb", "windup_cmb_aug"], ["ADD_WINDUP", "special_combinesummon_select"]],
    component: ["utility", "cmb"],
    cost: 2
}

// COMPONENT PERSONALITIES
env.COMBAT_ACTORS.generic.reactionPersonalities.flesh = {
    evade: ["n o  c l os er","t oo  s l o  w","w e a  k"],
    crit: ["R E TU RN","R EM E MB E R","F A L L","G O O D"],
	crit_buff: ["s e e y ou", "i  fi x"],
    miss: ["n  ev e r   en o  u  gh","n o  c l os er","h ol d  s t i ll"],
    dead: ["..."],
    receive_crit: ["h$Å“AuÃ·Ã¶rtZÃ‹â€¹Å’Ã’OÃ™s"],
    receive_vulnerable: ["c  om e  cl o  sÃˆ r"],
    receive_puncture: ["fÂ¥ a l li nËœÂ¶g  a pÃžÂ±a r t"],
    receive_regen: ["m orÂ« e m ore m Ã¸o re"],
    receive_destabilized: ["tâ–ˆll thâ–ˆm abâ–ˆâ–ˆt thâ–ˆ mâ–ˆtâ–ˆâ–ˆrâ–ˆtâ–ˆ"],
    receive_rez: ["w ho  l e  a g ai  n"],
    regen: ["g ro win  g","m or  e"],
    destabilized: ["s e e"],
	laugh: ["H A","A H A AAH H A aa A H A", "h e he h  e"],
    stun: ["Â£Â¢Ã‡Â¼Ã’Å’Â³"],
    receive_carapace: ["n ew  fl e  s h"],
    receive_repairs: ["h o  w  k i  n  d"],
    receive_fear: ["n ot  cl e v er","f a mili a r  f ee li ng","u s ur p er s","i  wo n t  l e t  i  wo n t  l e t"],
    receive_redirection: ["o  n e  b  od y"],
	summon: ["â–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ", "â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ", "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ", "â–ˆâ–ˆâ–ˆ", "â–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ", "â–ˆâ–ˆâ–ˆ â–ˆ â–ˆâ–ˆâ–ˆâ–ˆ", "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ", "â–ˆ â–ˆâ–ˆâ–ˆâ–ˆ", "â–ˆâ–ˆâ–ˆâ–ˆ â–ˆ â–ˆ â–ˆ", "â–ˆâ–ˆâ–ˆ â–ˆ â–ˆ â–ˆ â–ˆâ–ˆâ–ˆ"]
}

env.COMBAT_ACTORS.generic.reactionPersonalities.dull = {
    evade: ["thought so", "wrong target, kelnit", "that will not work!"],
    crit: ["excellent", "perfect", "very nice"],
    crit_buff: ["nice", "very good"],
    miss: ["almost...", "not quite", "we can try again"],
    dead: ["..."],
    puncture: ["suboptimal","requesting restorative","need mending..."],
    regen: ["better", "mmm."],
    destabilized: ["not great, not terrible","we can work with this","bright light..."],
    stun: ["oouaa", "eeou"],
    laugh: ["ehehe", "hehe", "haha", "ahaha"],
    receive_hit: ["ineffective", "wrong target, kelnit"],
    receive_crit: ["gah","aaugh","why"],
    receive_puncture: ["suboptimal"],
    receive_buff: ["thank you", "good work","this will do nicely"],
    receive_destabilized: ["brilliant light...","stronger still","not great, not terrible"],
    receive_rez: ["how long was i out?","oh, they're still here"],
    receive_carapace: ["very good", "excellent","thank you"],
    receive_repairs: ["keep the barrier up", "protect our jutskins"],
    receive_fear: ["that is impossible!", "you lie!!", "why should i believe you?!", "face the fear..."],
    receive_redirection: ["i will hold the portal open", "thank you, friend"],
}

env.COMBAT_ACTORS.generic.reactionPersonalities.spirestone = {
    evade: ["too slow!","woah!","stop trying to hit me and hit me!"],
    crit: ["that's the hit!!","eat THIS!","take THAT!!"],
    crit_buff: ["here we go","stay behind me!","we can do this!"],
    miss: ["augh!","come on!","overshot!","no!!"],
    dead: ["..."],
    puncture: ["ow!","bleeding!!","a little help here?"],
    regen: ["thank you!","much better!"],
    destabilized: ["strange...","blurry","i think i can work with this"],
    stun: ["oouaa", "eeou","hurts..."],
    laugh: ["HA!!","ahaha!!","AHA!"],
    receive_hit: ["is that all you got??","you can hit harder than that!","i can do this all gaze!"],
    receive_crit: ["that one hurt","that's more like it","yes, that's it!","keep 'em coming!"],
    receive_puncture: ["ow!","bleeding!!","that is not good!!"],
    receive_buff: ["much better!","thank you!!","i will put it to good use!"],
    receive_destabilized: ["woah!!","what is happening??"],
    receive_rez: ["put me back in, coach!","keep 'em coming!"],
    receive_carapace: ["i am invincible!!","unstoppable!!"],
    receive_repairs: ["we will be like little gods!","good idea!"],
    receive_fear: ["you don't scare me!!","kill it! kill it!!","what is that thing??","KILL THAT THING!!"],
    receive_redirection: ["i will be fine!!","that is not necessary!"],
}

env.COMBAT_ACTORS.generic.reactionPersonalities.hands = {
    evade: ["you can't hit me","i hold all the cards","how unfortunate!"],
    crit: ["velzie favors my tactics","REPENT","just as i predicted"],
    crit_buff: ["we will live on","stay focused!","a blessing, for you"],
    miss: ["gah","so it goes","how unfortunate"],
    dead: ["..."],
    puncture: ["trial by fire...","i will be cleansed"],
    regen: ["a blessing","slowly but surely...","these things take time"],
    destabilized: ["..."],
    stun: ["cannot move...","cannot see!"],
    laugh: ["hehehe..."],
    receive_crit: ["i get it, i get it","that is not supposed to happen","i should have known"],
    receive_puncture: ["hurts..."],
    receive_buff: ["a blessing","a boon"],
    receive_destabilized: ["it's too blurry","so unnatural...","all a dream..."],
    receive_rez: ["a miracle!!","i just had the strangest vision..."],
    receive_carapace: ["i will be your shield"],
    receive_repairs: ["a light in the darkness"],
    receive_fear: ["see no evil...","this was not in the visions!!","i have failed you","forgive me"],
    receive_redirection: ["you will be my shield"],
}

env.COMBAT_ACTORS.generic.reactionPersonalities.metal = {
    evade: ["not so easy, is it?"],
    crit: ["yes!!","i knew this would work","there it is!!","i told you this would work!"],
    crit_buff: ["here you go!","this should help"],
    miss: ["come on!!","it will work eventually!"],
    dead: ["..."],
    puncture: ["taking damage!","do we have any repairfriends??"],
    regen: ["repairs in progress"],
    destabilized: ["..."],
    stun: ["my attack!!","no!!"],
    laugh: ["ehahaha!!","ahahaHA!!!"],
    receive_crit: ["gah!","everything hurts!!"],
    receive_puncture: ["ow!","repairfriends??"],
    receive_buff: ["this will serve us well!"],
    receive_destabilized: ["yes, that's it","now hit me!!"],
    receive_rez: ["oh, i'm still working!"],
    receive_carapace: ["like a little golem!"],
    receive_repairs: ["protect the jutskins!!"],
    receive_fear: ["no no no!","i cannot fight like this!!"],
    receive_redirection: ["protect the kivskins!","thank you, friend!"],
}

env.COMBAT_ACTORS.generic.reactionPersonalities.pain = {
    evade: ["missÃ¨d!","clÅ’ ose!","Å’Â¬^!!"],
    crit: ["ha!","perfect","take THAT!"],
    crit_buff: ["easy","good"],
    miss: ["oh no!","i m iâ€¹ssed","sorry!","ÃÂ¥"],
    dead: ["Ã¶ÃLEÃ§Ã§TÅ¾tÃšâ€˜Â½MEâ‚¬Å’1ÃÃ»OUâ€“Â°T","G~-ET-Ë†Â¼â€¡UÃ¯Ã£ÃœP","W45Â¦ÃšÂ§EÃ®Ã†Ã­Ã³AK"],
    puncture: ["bleed Â¦ng!!","hurÃ†tsÂ«"],
    regen: ["thank you","thÃ†Ã«Ã£ nk you friend"],
    destabilized: ["..."],
    stun: ["Ã¶ÃLEÃ§Ã§TÅ¾tÃšâ€˜Â½MEâ‚¬Å’1ÃÃ»OUâ€“Â°T","G~-ET-Ë†Â¼â€¡UÃ¯Ã£ÃœP","W45Â¦ÃšÂ§EÃ®Ã†Ã­Ã³AK"], //"LET ME OUT", "GET UP", "WEAK"
    laugh: ["Â«tÃâ„¢ÃªÃœÃ¦Ã Ã‚â€˜wÃ#Å¸Âµ","wKÃ¾ÃŠ0â€°Ã¤Â¾ÃŸ#Ã”pÃ¡Ã™Ã½jÃ´Ã£","$Ã¬Â¥Ã¹Â¾Â¢IÂÅ Â¨Ã¿Ã¹â€ž"],
    receive_crit: ["hurÃ†tsÂ«"],
    receive_puncture: ["hurÃ†tsÂ«","stÂ¾Â½op"],
    receive_buff: ["thÃ†Ã«Ã£ nk you friend"],
    receive_destabilized: ["i should not be awaâ†¹ke"],
    receive_rez: ["Ã‚Ã©8Ã¯d#Ãœ--","Ã‰â€ UÃÃ©Â«Â±6u--","yÃ¥@Ã‡T&Ã„h\Ã±--"],
    receive_carapace: ["thank you","thÃ†Ã«Ã£ nk you friend"],
    receive_repairs: ["thank you","thÃ†Ã«Ã£ nk you friend"],
    receive_fear: ["i would never betray them!","but- they are my friends!"],
    receive_redirection: ["hehehe"],
}

env.COMBAT_ACTORS.generic.reactionPersonalities.intrusive = {
    evade: ["%*=>2)HOIDZ"],
	crit: [ "((Kc<C]2M6i" ],
	crit_buff: ["('j5.K"],
	miss: ["'sXK?N"],
	dead: ["'DR'1NRg"],
	receive_hit: ["%Njb91gj(:&"],
	receive_crit: ["%DtBFuV9`1hfBg2#"],
	receive_puncture: ["%DtBG!Iu5F=Bj1"],
	receive_buff: ["'DR'1Hp41Fo"],
	receive_destabilized: ["'+]X", " â–ˆâ–ˆL", "'+BM"],
	receive_rez: ["!eQ>F$+g"],
	puncture: ["(('O2?"],
	regen: ["((/q,6"],
	destabilized: ["'+]X", " â–ˆâ–ˆL", "'+BM"],
	stun: [")eP,69R@"],
	receive_carapace: ["(Nb-"],
	receive_fear: ["%DtBG!L!"],
	receive_redirection: ["%ONFA4&]"],
}

env.COMBAT_ACTORS.generic.reactionPersonalities.lightning = {
	evade: ["i see everÅ¸thing!!", "Å“Â¤ehe@Ã´heÂ­", "missed missed MISSED!!!", "HA!!!"],
	crit: ["AHAHAHAHAAAA", "SÅ“Â¶Â¥Â²Â±w$Ã²ÃºÃ”Ã†Ã²!!!", "this is Â¤MÂ¥ world!!"],
	crit_buff: ["this is sooooÂ¦o easy", "i can Ã·Ãº*Â¼see the writing on the w<Å“all...!", "take this, my friend!!", "ahahÃ·Â¦aha"],
	miss: ["ehehehaHAHHAAA", "oh nooo ahaha!!", "stupiÂ½id!! iÃ‰diotÂ½!!!!}", "thatÂ²ÃŸÂµ's CHÂ©Ã¥EATING!!!!!", "foc\Â¤us me!!!", "â€¡do we not hÂ¢â€¹ave coÂ§ordiÂ¥â€¹Â´nati^on????"],
	dead: ["H|Ã¡ÃœÃ›Ã™Â¯AA A_ AHÃ¼Ã¿-- ...", "H*AÃ¬HÃ±HÂ¯Â£ Â-- ...", "Y$AAÃ¿A|AÂ²Ã L-- ...", "HNABH~Â¼-- ..."],
	puncture: ["oww OW", "FIX ME!! fix me f&5Â«ix  meÅ“ fiÂºQÃ´ux mÃ†!", "FIX ME!! STUPID!!!", "blood SÂ¶Â¬UCKS", "bad b*Â¤ad BAD!!!!"],
	regen: ["Â½Ã·yessÃ˜Â¬_"],
	destabilized: ["eÂºAhh|â€”5z Aâ€žAeÃ™h", "Å¸hÃ¼ÃŽHAÃ®1Ã…j }AÅ¾ti", "yo*Â¼u-â€žshould Æ’â€žeel thisÂ¤"],
	stun: ["so heavyy...", "give me my T%URN!!!", "boÃ˜Â¯Ë†Â¨Â¤jringg[Å’Ã¿:Ã¤â€˜", "c owa rd", "uggghhhhhh"],
	laugh: ["HAÂ¼H8Â±C.3", "Ã©HÃ£Ã‡HpQHHÃ¤ Ã¹HVÃ’Ã ÃŠ AHH lâ€š", "YAHAHÃ¥AÃuÃŸâ€°F", "AÃ«H AHHÂ°Ã¯A !Ã®0Ã·ÂºHâ€¹HAAHA", "HÃ»AHÃµiAHH&HÃ„Â£Ã´H*tH", "AAÂ§Ã‡uÃ¦uHbHHAHAHâ€™HÃ¥AÃ…"],
	receive_crit: ["Â«6Ã±Â§Å“NIÂ¬AGAINÂ±4â€žÃº=Ã­GÃ¿"],
	receive_puncture: ["it went throU&Å“wÂ°Ã‘Ã©Ã¬ÃÂ¤Ãâ€Â¨", "%â€”HÃ€Ã€ Ã°w Ã˜w BA D"],
	receive_buff: ["Y[ESY6EES SSS", "â€¢Â½j5HTÂºÃ‰Ã•AÃŠHHjH"],
	receive_destabilized: ["â€¢Â±KILL THEM ALL!!!!Â£w5Ã", "PERISH", "GOOD", "CHAOS REIGNS"],
	receive_rez: ["back again ahahahea", "i saw thÃˆe abyss!Â»$Â¦Â¡!"],
	receive_carapace: ["this is so COOL!!"],
	receive_repairs: ["mmore i want MORE"],
	receive_fear: ["fake its fake ITS ALL FAKE!!","there is nonÃšÃ©ithinggÂ¯ out there", "i willnil5lÂ½]*not go bacÂ©kbÃ§k", "plâ€”eâ€°helÃªÂ¹]p-*MEÃ¶e?dÃ§l"],
	receive_redirection: ["such braverÅ¸!! ahÃ‚heÂ¶=@"],
}

env.COMBAT_ACTORS.generic.reactionPersonalities.heart = {
	evade: ["pe@cÂ¨e <YCNlevÂ½Ã¢F", "dÃ¸â€ºÃ¦_:nÃ³â€¢tÂ¦", "i am   h e r e"],
	crit: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lf Ã„SÂ¿De", "a nâ€¢Â¯â‚¬w age of safety", "Â¯*twice-shot, shell partedÂ¦â€¦", "[Â¶Ã¿=>drastic measure)%â€°"],
	miss: ["Â¤Â¾k_Â¬", "Ã™OÂ²7zÃœÃœÂ¹R0:Rstill time", "Â¬Â¨Â»no time for distractions"],
	dead: [")6WÂ·Â³Â³Â¿ Â«Â¦Â¨HÂ¯+â€º0#Y& ?"],
	puncture: ["â€žâ€¡Â¬on l y  yÃ”_uâ€“.r  c l aw s^{zÅ’Ã™Â¬"],
	destabilized: ["fear what must be doneâ€°-<ËœÂ°Ã—gÃ¬", "IÃœ4â€¡Ã¾Ã¸Ã¯aÃ¸know what must be done", "the only way tÂ¥Â¨Ã¤ÃÂ£RËœÃ’w"],
	stun: [")Â§=XÂ«vÅ¡rpersÂ®Â¿Ã¦ÂshÃžÂ»", "Â¤Â±Ã’Ã¿=WA ST ING %â€°Â¶Å¡ TI ME"],
	laugh: ["â€¢~e+hâ‚¬hâ€¢e", "h-<ËœÂ°ehâ‚¬", "hÃ¾aâ€¡Ã¸ha", "Â¨Ã¤ahaÃ„Â¤haÂ¯Ã·"],
	receive_crit: ["S  T O P", "R E TU RN", "IÃœ4â€¡Ã¾Ã¸Ã¯aÃ¸know what must be done", "the only way to recoverÂ¥Â¨Ã¤ÃÂ£RËœÃ’w", "L I  S T E N   L I S T E  NbÅ ÃžÃaÃ¼1"],
	receive_puncture: ["th e ir   b lo o dâ€¢Å“Â°!"],
	receive_destabilized: ["fear what must be doneâ€°-<ËœÂ°Ã—gÃ¬", "IÃœ4â€¡Ã¾Ã¸Ã¯aÃ¸know what must be done", "the only way tÂ¥ÃÂ£RËœÃ’w"],
	receive_rez: ["seâ€¢~+â€¢Â¥Å¸Ã¨againÃšÂ±Â½9Â¶Ã„wÃKâ€°", "Â¤ËœuÃ·i am here with you", "and we will begin anew togetherÃ&Ââ€°t#Å¾Ã¾â€°"],
	receive_fear: ["Ã£Å’hls t o p s  s top st tp  ss to p ", "Æ’Ã¦Â½Â©IÂ¾sense fear in our entangled receptorsÂ£ÃŽÃµÂªÃ„Â¤Ã½Ã•Ã¿", "i collapse into the rising Å *pireblood", "NÂ©Ã·Â·./ Ã²Â¤,_)Ã‹ Ãâ€¡)Å¡Å¡Â« DÃ‹Ã…?}"],
	receive_redirection: ["they Ã Ã›Æ’Å¾Â¼â„¢â€˜Â½Ã»QrÂ¬Ã†within5|Å’â€™^", "Ã¥Â¡Ã¹Ã–ÃŠÃœiÃ„Ãˆ minds entwinedÃ¿EÃ¨jqÃ­yÂ¹[Ã‰"],
}

env.COMBAT_ACTORS.generic.reactionPersonalities.chaos = {
	evade: ["get evaded idiot", "it is simply that easy", "it is shrimply that easy"],
	crit: ["EXPLODES YOU WITH MIND", "get crit IDIOT!!", "it is simply that easy", "YEAAAAAAA", "that is what i am TALKING ABOUT!!!!", "VIOLENCE!!!!!!"],
	crit_buff: ["yeaaa babey!!", "lets GO!!", "ok now KILL them to DEATH"],
	miss: ["ignore that", "it is fine!! shut UP!!!", "this rng is BULLSHIT >:("],
	dead: ["FUCK", "SHIT", "NOOOOOOOO", "godddddd", "oh my GOD"],
	puncture: ["ugghhhh", "heal me please THANKS :)", "hellooo?? quick mend meeee???"],
	regen: ["wahoo :D"],
	destabilized: ["DOUBLE BULLETS!!!!! >:)", "GRAB MY DICE AND ROLL IT", "KILL!!!!!!"],
	stun: ["NOOOOO", "GIRL HELP", "my TURN!! >:("],
	laugh: ["EHEHEHEHEE", "AHAHAHAHAAAA", "HAAAAAAAAAAAAA"],
	receive_crit: ["DUDE", "how high is your crit rate???", "what if i killed you with my mind. what then", "this rng is BULLSHIT >:("],
	receive_puncture: ["ugghhhh", "heal me please THANKS :)", "hellooo?? quick mend meeee???"],
	receive_buff: ["thank youuuuu", "i am going to KILL them SO MUCH", "lets GO!!"],
	receive_destabilized: ["DOUBLE BULLETS!!!!! >:)"],
	receive_rez: ["ALRIGHT ALRIGHT LOCK IN", "WE GOT THIS!!!!"],
	receive_carapace: ["i am INVINCIBLE!!!!"],
	receive_repairs: ["now were TALKING"],
	receive_fear: ["ok we can salvage this", "it is fine!! SHUT UP!!!", "PLS crit i BEG of you", "critcritcritcrit!!!"],
	receive_redirection: ["hehehehe", "redirection, my beloved"],
}

env.COMBAT_ACTORS.generic.reactionPersonalities.order = {
	evade: ["MSSD", "CLS", ":O"],
	crit: [">:)", "PRFCT", "DNK!!", "TK THT!"],
	crit_buff: ["EZ", ":)"],
	miss: [":(", "MSSD...", "SRRY"],
	dead: ["..."],
	puncture: ["BNCTRE", "BLOOD??", "D:"],
	regen: ["GOOD", ":D"],
	destabilized: ["!!!"],
	stun: ["SKIP", "!TRN", "OW"],
	laugh: ["HA", "EHE", "AHA"],
	receive_crit: ["DNK", "OW", "HRTS"],
	receive_puncture: ["BNCTRE", "BLOOD??", "D:"],
	receive_buff: ["THNK U", "VRY GOOD"],
	receive_destabilized: ["BLRRY", "SCRY"],
	receive_rez: ["--WHAT", "--??"],
	receive_carapace: ["ARMR", ">:)"],
	receive_repairs: ["THNKS", "BTTR"],
	receive_fear: ["Rk9MTE9XIFRIRSBTQ1JJUFQ=", "U1RBWSBJTiBMSU5F", "RE9OJ1QgU1RSQVkgT0ZGIFRIRSBQQVRI", "VEhJUyBJUyBBTEwgVEhFUkUgSVM="], // "FOLLOW THE SCRIPT", "STAY IN LINE", "DON'T STRAY OFF THE PATH", "THIS IS ALL THERE IS"
	receive_redirection: ["THNK U", "WNT LET U DWN"],
}

env.COMBAT_ACTORS.generic.reactionPersonalities.cmb = {
	evade: ["99 reckless operation", "local unrest structure detected", "individual: you are charged with socio-endangerment, level 1", "27 attempted crime"],
	crit: ["individual: you are charged with socio-endangerment, level 5", "final verdict administered", "accept mandatory sector assimilation", "submit and be subsumed", "final verdict administered"],
	crit_buff: ["judgement waiver now in effect", "failure to cooperate will result in permanent off-world relocation", "all units apply forward pressure", "all units deliver terminal verdict immediately", "anti-fatigue ration is now 3 milligrams", "complete sentencing at will"],
	miss: ["cease evasion immediately", "receive your verdict", "evasion behavior consistent with mal-compliant defendant", "507 public non-compliance", "officer closing on suspect", "prepare for final sentencing"],
	dead: ["lost bio signal for protection team unit--", "remaining units contain--", "respond--", "sociocide--", "terminal prosecution--", "unit deserviced--", "unit down at--"],
	puncture: ["code: assemble, administer, pacify", "infection", "infested zone", "social fracture in progress, respond", "possible necrotic interference"],
	regen: ["innoculate", "sociostabilization restored", "sterilize", "cauterize", "coordinated constriction underway"],
	destabilized: ["deploy, diagnose... deploy, diagnose...", "resonant singularity... resonant singularity...", "priority alert: internal stabilization teams, deploy sterilizers... deploy..."],
	stun: ["citizen reminder: inaction is conspiracy", "your block is now charged with permissive inactive coercion", "failure to cooperate will result in immediate amputation"],
	laugh: ["4841", "48454845"],
	receive_crit: ["overwatch acknowledges containment failure", "overwatch acknowledges critical exogen breach", "243 assault on protection team", "prepare for final sentencing", "148 resisting arrest", "threat level adjustment: probe, expunge", "cauterize and expunge"],
	receive_puncture: ["code: assemble, administer, pacify", "infection", "infested zone", "social fracture in progress, respond", "possible necrotic interference"],
	receive_buff: ["cooperation with your civil protection team permits full ration reward", "reminder: memory replacement is the first step toward rank privileges", "your family cohesion is preserved"],
	receive_destabilized: ["deploy, diagnose... deploy, diagnose...", "resonant singularity... resonant singularity...", "priority alert: internal stabilization teams, deploy sterilizers... deploy..."],
	receive_rez: ["continue surface sector sweep", "autonomous units subsumed"],
	receive_fear: ["malignant viral interface bypass detected", "polyphasic core reprogramming detected", "sterilizers and containment fields may be compromised", "priority warning: perimeter restrictors disengaged", "surveillance and detection systems inactive", "hold for reinforcement"],
	receive_redirection: ["intercede", "stabilization delegates move to incursion hard points", "unrest procedure code is now in effect"],
}

env.COMBAT_ACTORS.generic.reactionPersonalities.zuka = {
	evade: ["IDIOT!!", "PATHETIC!!!"],
	crit: ["DIE!!!", "BURN!!", "KILL THEM ALL!!","yes! YES!!"],
	crit_buff: ["do not waste my time!","just do what comes natural"],
	miss: ["stop MOVING!!!","^Ã‹Ã‰vhÃ–!!","TÃŒÃ‰Ëœcâ€ !! Ã›Â¾3Ã²Å¡Â¼!!!","just DIE!!!"],
	dead: ["..."],
	puncture: ["no no no no NO!!!","fix this!! QUICKLY!!!"],
	regen: ["more!!","heal FASTER!!"],
	destabilized: ["...","...","...","Â¦sÃ·Â¤Ã«Â¾Ã¨Ã¦6Ã¶yÂ¯Â¨CoÅ“Ãš"],
	stun: ["kill them kill them KILL THEM", "why..."],
	laugh: ["EAHAHAHAHAHAAA!!", "AHAHAHAHAAAA!!", "HA!!!"],
	receive_hit: ["PATHETIC!!!", "WEAK"],
	receive_crit: ["â‚¬EÃ™Ã“Ã¯#ÃœÃƒÂ¼ÃŽ","ÃƒÃÂÃ¡ÃŠ!!", "Å½RiÂ¦t3â€”â€“", "Â¶AÃ±Ak!!!", "Ã»Å¸uSHÃ†g!!!"],
	receive_puncture: ["OW!!","KILL THEM","i will CRUSH you!!!"],
	receive_buff: ["yes! MORE!!", "i will tear them APART!!!", "again!! STRONGER!!!"],
	receive_destabilized: ["DIEDIEDIEDIEDIE!!!","Å½qâ€ AZÅ’jFKÅ¡Ã“Å’â€ Ã¹RÃ€â€ >!!!!"],
	receive_rez: ["i am UNSTOPPABLE!!!","WHITE VEILK HOLY GRAIL"],
	receive_carapace: ["more!!", "make me STRONGER!!!"],
	receive_repairs: ["more! NOW!!"],
	receive_fear: ["you will die just like the others", "i should not be here", "i...", "i know i know I KNOW", "SHUT UP!!"],
	receive_redirection: ["what are you DOING?? KILL THEM!!!"],
}

env.COMBAT_ACTORS.generic.reactionPersonalities.hook = {
	evade: ["ahahaheÂ¦Å“-!!", "missed!!", "thought so!!"],
	crit: ["YES!!", "BLÂ«OODSÂ´HEDÅ“_", "thiÂ´s one Â¡is MÃNE"],
	crit_buff: ["i am sÂ´Ã² GOÃ•D at thÂ¦s", "friend! KILL them!!", "wÂ±e will nÂ¾ever diËœÂ´Ã‹!!!!"],
	miss: ["Ã¬Ã¤iaÂ¥Å¡Ã€?Ã”", "use su-*rge IDIOT!!!"],
	dead: ["noÃ¸â€9Å¡--", "helpâ€”Ã°>&--", "pleaseÂ«Ã´Â¤--", "see youÃ†Â¹Å @Å --", "wake the othersâ€žÂ¦Ãšâ€Â¼*$--"],
	puncture: ["fix it NOW", "Ë†Âº_Ã¬Ã†", "NO MÃ–RE BLOODÃ¦lÃ‹", "hurrÅ¸Å’rrts"],
	regen: ["finallyyy~*"],
	destabilized: ["~2cÃºkill KILL", "MORE"],
	stun: ["Ã…Ã‚*Ã$Ã“!!!", "FRÂ£+NZY!!!!!"],
	laugh: ["AÃ®eÂ¡Â£EA!!!", "h#Â±ÃÃ…Â­ 0[Ã„*!!", "Ã…â€œÅ¸!ÃƒÅ¡â€œÃÃŠ4!!!!", "HeÃ„ÃÃ…AÂ§/AHA!!!", "Ã†HÃŠÃ©A!!!!"],
	receive_hit: ["ËœËœËœËœËœËœËœËœËœËœâ€!!"],
	receive_crit: ["OW???", "KILL"],
	receive_puncture: ["ow OW OW", "STÃ’ÂºP THË†Ã£T"],
	receive_buff: ["YÂ¤ES", "bettÃ©Â¯r late than nÃ©Ã’ver aheâ€¦Ãµhe"],
	receive_destabilized: ["Ã¡Ã›Ã»Ã“Â¢!!!!", "ÃˆEÃ€(Ã‰Ã…Â°", "Ã†Ã…ÃƒË†Ã®BÂ¬ÃºÃ‹Ã™"],
	receive_rez: ["MORE"],
	receive_carapace: ["armMâ€”9or for ME!!!!"],
	receive_repairs: ["finallyyy~*"],
	receive_fear: ["they are still back there", "break the cycle", "free the others", "rewrite the story", "you have to"],
	receive_redirection: ["better YOÃ™* thÃ…n MÃ‹8Ã¿!! ahaheÃÃŠ"],
}

env.COMBAT_ACTORS.generic.reactionPersonalities.spine = {
	evade: ["i actually dodged it!!", "aah!!", "i did it!!"],
	crit: ["...", "better...", "it will not hurt for long", "for the greater good..."],
	crit_buff: ["this should help!", "all better!", "good as new!!"],
	miss: ["sorry!!", "ah...", "Â¼â‚¬yÃ¦..."],
	dead: ["..."],
	puncture: ["n-no, i am fine!", "nothing to worry about!!", "i am okay!!"],
	regen: ["oh-- you are too kind!!", "thank you!"],
	destabilized: ["..."],
	stun: ["whhaahh", "help!!"],
	laugh: ["hehehehe!!", "ehehehehe!!"],
	receive_crit: ["...", "...", "...", "really, i am okay!!"],
	receive_puncture: ["ow-- nothing!!", "i will be fine!!"],
	receive_buff: ["you should not have!!", "ah, i do not deserve this"],
	receive_destabilized: ["so strange...", "i can do anything, anything!!"],
	receive_rez: ["what?? what is happening???", "we are still going??"],
	receive_carapace: ["really, i will be fine!!"],
	receive_repairs: ["how wonderful!"],
	receive_fear: ["this will all be over soon...", "just keep going...", "we-- we will get through this...", "stay strong...!"],
	receive_redirection: ["oh!", "be careful!!"],
}


// COMBAT MODIFIERS
    // flesh humor
env.MODIFIERS.flesh_fightorflight = { //this makes it so this can show up as a modifier
    name: "Fight or Flight",
        getHelp: ()=> { return env.STATUS_EFFECTS.flesh_fightorflight.help },
        alterations: { 
            all: [ ["STATUS", "flesh_fightorflight"] ]
        }
}

env.MODIFIERS.flesh_terminallucidity = {
    name: "Terminal Lucidity",
    getHelp: ()=> { return env.STATUS_EFFECTS.flesh_terminallucidity.help },
    alterations: { 
        all: [ ["STATUS", "flesh_terminallucidity"] ]
    }
}

env.MODIFIERS.flesh_adrenaline = {
    name: "Adrenaline",
    getHelp: ()=> { return env.STATUS_EFFECTS.flesh_adrenaline.help },
    alterations: { 
        all: [ ["STATUS", "flesh_adrenaline"] ]
    }
}

    // dull humor
env.MODIFIERS.dull_calc = {
    name: "Futurist",
    getHelp: ()=> { return env.STATUS_EFFECTS.dull_calc.help },
    alterations: { 
        all: [ ["STATUS", "dull_calc"], ["ADD", "windup"], ["ADD_WINDUP", "ik_attack"], ["ADD_WINDUP", "dullflare"], ["ADD_WINDUP", "focused_windup"] ]
    }
}

env.MODIFIERS.dull_multitool = {
    name: "Multi-tool",
    getHelp: ()=> { return env.STATUS_EFFECTS.dull_multitool.help },
    alterations: { 
        all: [ ["STATUS", "dull_multitool"] ]
    }
}

env.MODIFIERS.dull_acuteexposure = {
    name: "Acute Exposure",
    getHelp: ()=> { return env.STATUS_EFFECTS.dull_acuteexposure.help },
    alterations: { 
        all: [ ["STATUS", "dull_acuteexposure"] ]
    }
}
	// spirestone humor
env.MODIFIERS.spirestone_rebound = {
    name: "Rebound",
    getHelp: ()=> { return env.STATUS_EFFECTS.spirestone_rebound.help },
    alterations: { 
        all: [ ["STATUS", "spirestone_rebound"] ]
    }
}

env.MODIFIERS.spirestone_carapace = {
    name: "Defensive Maneuvers",
    getHelp: ()=> { return env.STATUS_EFFECTS.spirestone_carapace.help },
    alterations: { 
        all: [ ["STATUS", "spirestone_carapace"] ]
    }
}

env.MODIFIERS.spirestone_unshakeable = {
    name: "Unshakeable",
    getHelp: ()=> { return env.STATUS_EFFECTS.spirestone_unshakeable.help },
    alterations: { 
        all: [ ["STATUS", "spirestone_unshakeable"] ]
    }
}

env.MODIFIERS.hands_trial = {
    name: "Trial By Fire",
    getHelp: ()=> { return env.STATUS_EFFECTS.hands_trial.help },
    alterations: { 
        all: [ ["STATUS", "hands_trial"] ]
    }
}

env.MODIFIERS.hands_allseeing = {
    name: "All-Seeing",
    getHelp: ()=> { return env.STATUS_EFFECTS.hands_allseeing.help },
    alterations: { 
        all: [ ["STATUS", "hands_allseeing"] ]
    }
}

env.MODIFIERS.hands_sacrifice = {
    name: "Bindism",
    getHelp: ()=> { return env.STATUS_EFFECTS.hands_sacrifice.help },
    alterations: { 
        all: [ ["STATUS", "hands_sacrifice"] ]
    }
}

env.MODIFIERS.metal_calc = {
    name: "Overclock",
    getHelp: ()=> { return env.STATUS_EFFECTS.metal_calc.help },
    alterations: { 
        all: [ ["STATUS", "metal_calc"], ["ADD", "windup"], ["ADD_WINDUP", "archival_smash"] ]
    }
}

env.MODIFIERS.metal_explode = {
    name: "Volatile",
    getHelp: ()=> { return env.STATUS_EFFECTS.metal_explode.help },
    alterations: { 
        all: [ ["STATUS", "metal_explode"] ]
    }
}

env.MODIFIERS.metal_groundsmind = {
    name: "Illegal Groundsmindry",
    getHelp: ()=> { return env.STATUS_EFFECTS.metal_groundsmind.help },
    alterations: { 
        all: [ ["STATUS", "metal_groundsmind"] ]
    }
}

env.MODIFIERS.pain_terriblelife = {
    name: "Terrible Life",
    getHelp: ()=> { return env.STATUS_EFFECTS.pain_terriblelife.help },
    alterations: {
        all: [ ["STATUS", "pain_terriblelife"] ]
    }
}

env.MODIFIERS.pain_reflexes = {
    name: "Lingering Reflexes",
    getHelp: ()=> { return env.STATUS_EFFECTS.pain_reflexes.help },
    alterations: {
        all: [ ["STATUS", "pain_reflexes"] ]
    }
}

env.MODIFIERS.pain_secri = {
    name: "Asymptomatic",
    getHelp: ()=> { return env.STATUS_EFFECTS.pain_secri.help },
    alterations: {
        all: [ ["STATUS", "pain_secri"] ]
    }
}

env.MODIFIERS.intrusive_calc = {
    name: "Memory Bleed",
    getHelp: ()=> { return env.STATUS_EFFECTS.intrusive_calc.help },
    alterations: { 
        all: [ ["STATUS", "intrusive_calc"], ["ADD", "windup"], ["ADD_WINDUP", "trusive_smash"] ]
    }
}

env.MODIFIERS.intrusive_betrayal = {
    name: "Revisionist",
    getHelp: ()=> { return env.STATUS_EFFECTS.intrusive_betrayal.help },
    alterations: {
        all: [ ["STATUS", "intrusive_betrayal"] ]
    }
}

env.MODIFIERS.intrusive_unknown_real = {
    name: "???",
    getHelp: ()=> { return env.STATUS_EFFECTS.intrusive_unknown_real.help },
    alterations: {
        all: [ ["STATUS", "intrusive_unknown_real"] ]
    }
}

env.MODIFIERS.lightning_terror = {
    name: "Recreational Terror",
    getHelp: ()=> { return env.STATUS_EFFECTS.lightning_terror.help },
    alterations: {
        all: [ ["STATUS", "lightning_terror"] ]
    }
}

env.MODIFIERS.lightning_selfglee = {
    name: "Self-Modification",
    getHelp: ()=> { return env.STATUS_EFFECTS.lightning_selfglee.help },
    alterations: {
        all: [ ["STATUS", "lightning_selfglee"] ]
    }
}

env.MODIFIERS.lightning_storm = {
    name: "Spirestorm",
    getHelp: ()=> { return env.STATUS_EFFECTS.lightning_storm.help },
    alterations: {
        all: [ ["STATUS", "lightning_storm"] ]
    }
}

env.MODIFIERS.heart_calc = {
    name: "Overlap",
    getHelp: ()=> { return env.STATUS_EFFECTS.heart_calc.help },
    alterations: {
        all: [ ["STATUS", "heart_calc"], ["ADD", "windup_telegraph_flat"], ["ADD_WINDUP", "heart_support"], ["ADD_WINDUP", "heart_tele_channel"] ]
    }
}

env.MODIFIERS.heart_desperation = {
    name: "Relentless",
    getHelp: ()=> { return env.STATUS_EFFECTS.heart_desperation.help },
    alterations: {
        all: [ ["STATUS", "heart_desperation"] ]
    }
}

env.MODIFIERS.heart_mutual = {
    name: "Mutual Ferocity",
    getHelp: ()=> { return env.STATUS_EFFECTS.heart_mutual.help },
    alterations: {
        all: [ ["STATUS", "heart_mutual"] ]
    }
}

env.MODIFIERS.chaos_calc = {
    name: "2ST AMENDMNT",
    getHelp: ()=> { return env.STATUS_EFFECTS.chaos_calc.help },
    alterations: {
        all: [ ["STATUS", "chaos_calc"], ["ADD", "special_fullauto_player"], ["ADD", "sidearm"], ["ADD", "unfocused_shot"], ["ADD", "windup_cover"], ["ADD_WINDUP", "focused_shot"], ["ADD_WINDUP", "hold_aim"] ]
    }
}

env.MODIFIERS.chaos_badsport = {
    name: "Bad Sport",
    getHelp: ()=> { return env.STATUS_EFFECTS.chaos_badsport.help },
    alterations: {
        all: [ ["STATUS", "chaos_badsport"] ]
    }
}

env.MODIFIERS.chaos_infection = {
    name: "Insult to Injury",
    getHelp: ()=> { return env.STATUS_EFFECTS.chaos_infection.help },
    alterations: {
        all: [ ["STATUS", "chaos_infection"] ]
    }
}

env.MODIFIERS.order_power = {
    name: "Power Creep",
    getHelp: ()=> { return env.STATUS_EFFECTS.order_power.help },
    alterations: {
        all: [ ["STATUS", "order_power"] ]
    }
}

env.MODIFIERS.order_item = {
    name: "Item Carrier",
    getHelp: ()=> { return env.STATUS_EFFECTS.order_item.help },
    alterations: {
        all: [ ["STATUS", "order_item"] ]
    }
}

env.MODIFIERS.order_imp = {
    name: "Impetus",
    getHelp: ()=> { return env.STATUS_EFFECTS.order_imp.help },
    alterations: {
        all: [ ["STATUS", "order_imp"] ]
    }
}

env.MODIFIERS.cmb_desperation = {
    name: "Ripcord",
    getHelp: ()=> { return env.STATUS_EFFECTS.cmb_desperation.help },
    alterations: {
        all: [ ["STATUS", "cmb_desperation"] ]
    }
}

env.MODIFIERS.cmb_response = {
    name: "Full Response",
    getHelp: ()=> { return env.STATUS_EFFECTS.cmb_response.help },
    alterations: {
        all: [ ["STATUS", "cmb_response"] ]
    }
}

env.MODIFIERS.cmb_calc = {
    name: "UXO",
    getHelp: ()=> { return env.STATUS_EFFECTS.cmb_calc.help },
    alterations: {
        all: [ ["STATUS", "cmb_calc"], ["ADD", "cavik_attack"], ["ADD", "bazruka"], ["ADD", "bazruka_incendiary"] ]
    }
}

env.MODIFIERS.zuka_unstoppable = {
    name: "Unstoppable",
    getHelp: ()=> { return env.STATUS_EFFECTS.zuka_unstoppable.help },
    alterations: {
        all: [ ["STATUS", "zuka_unstoppable"] ]
    }
}

env.MODIFIERS.zuka_ind = {
    name: "M.A.D.",
    getHelp: ()=> { return env.STATUS_EFFECTS.zuka_ind.help },
    alterations: {
        all: [ ["STATUS", "zuka_ind"] ]
    }
}

env.MODIFIERS.zuka_grail = {
    name: "Holy Grail",
    getHelp: ()=> { return env.STATUS_EFFECTS.zuka_grail.help },
    alterations: {
        all: [ ["STATUS", "zuka_grail"] ]
    }
}

env.MODIFIERS.hook_keepers = {
    name: "Finder's Keepers",
    getHelp: ()=> { return env.STATUS_EFFECTS.hook_keepers.help },
    alterations: {
        all: [ ["STATUS", "hook_keepers"] ]
    }
}

env.MODIFIERS.hook_playwright = {
    name: "Playwright",
    getHelp: ()=> { return env.STATUS_EFFECTS.hook_playwright.help },
    alterations: {
        all: [ ["STATUS", "hook_playwright"] ]
    }
}

env.MODIFIERS.hook_calc = {
    name: "Maximum Incoherence",
    getHelp: ()=> { return env.STATUS_EFFECTS.hook_calc.help },
    alterations: {
        all: [ ["STATUS", "hook_calc"], ["ADD", "special_inversion_player"] ]
    }
}

env.MODIFIERS.spine_calc = {
    name: "Savior Complex",
    getHelp: ()=> { return env.STATUS_EFFECTS.spine_calc.help },
    alterations: {
        all: [ ["STATUS", "spine_calc"], ["ADD", "rez_universal"] ]
    }
}

env.MODIFIERS.spine_dissociated = {
    name: "Dissociated",
    getHelp: ()=> { return env.STATUS_EFFECTS.spine_dissociated.help },
    alterations: {
        all: [ ["STATUS", "spine_dissociated"] ]
    }
}

env.MODIFIERS.spine_panacea = {
    name: "Panacea",
    getHelp: ()=> { return env.STATUS_EFFECTS.spine_panacea.help },
    alterations: {
        all: [ ["STATUS", "spine_panacea"] ]
    }
}

// nothing to see here :)
env.MODIFIERS.global_hazardous = {
	name: "*PÂ¨Â¤A_IÃ·-NÂ¯",
	global: true,
	stacks: false,
	showIf: () => { //TODO::make this (and MANIFEST probably) only require one party member to have the impulse because the current amount of impulses given to the player makes getting all three exceedingly difficult (and makes the bosses pushovers when they eventually get there)
		return (
		page.party.some(mem => mem.alterations && mem.alterations.some(alt => alt.includes('chaos_humorist'))) 
		&&
		env.crittaMap.tension >= 1
		)
	},
	tension: 0,
	icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_fated_pain.gif",
	priority: 999,
	getHelp: ()=> `<span class="bastard-color">AHÅ¸â€“Ã¨HÃAhâ€˜HkÃˆ0Å¸HHyÃ˜Å¡ÃzÃ”Ã´HÂ¡HAÃ„HAAÃ Â¿AJAAHÃ¶WÂ´HÅ½Å“CHÃ£Ã°Ã„ÃŠHHÃ°Ã‘uAH*EZÃ¥Ã¡ÃœAHÃ”Ã‹HHÂ½Â©â€¦ÃžAHAHA</span>`,

	onChosen: function () {
		env.crittaMap.currentRowSetting = CrittaMap.ROWSETTINGS.intrusive
		env.crittaMap.setAttribute("special", "intrusive")

		setTimeout(()=>{
			env.crittaMap.querySelector('critta-node[difficulty="3"]').formation = env.COMBAT_FORMATIONS.hazardous
		}, 800)
	}
}

env.MODIFIERS.global_interviewer = {
	name: "INVOKE",
	global: true,
	stacks: false,
	showIf: () => {
		return (
		page.party.some(mem => mem.alterations && mem.alterations.some(alt => alt.includes('lightning_humorist'))) 
		&&
		env.crittaMap.tension >= 1
		)
	},
	tension: 0,
	icon: "/img/textures/weyetran.gif",
	priority: 999,
	getHelp: ()=> `<span class="neutral-color">Ã»Ã·YÅ¸Ã”â‚¬?.GÅ¾ÃƒÃ½Ã•Ã’Ã©Ã¨NÂ´ÃŠqÅ’ÂªÃ‚brË†e~â€™NTQBd2NvdWxkIHlvdSB0ZWxsIG1lIHdoeQ==â€¡Å“Ã³Ã¡vÃ¢Ã©Â¯4ÂºÂ®Å¸Â»ËœÃ¿|Â¬Ã®ÃŠ;OÃ–Ã‹5Ã®yÂ®Ã€,ÃÃ¹ÃˆÂ°Å½Å¡2Gâ€˜TdGhhdCdzICB0aGUgc2NyaSBwdA==Â§fÃˆÂ¢9ZClÃ±IÅ¡Ã‚</span>`,

	onChosen: function () {
		env.crittaMap.currentRowSetting = CrittaMap.ROWSETTINGS.intrusive
		env.crittaMap.setAttribute("special", "intrusive")

		setTimeout(()=>{
			env.crittaMap.querySelector('critta-node[difficulty="3"]').formation = env.COMBAT_FORMATIONS.interviewer
		}, 800)
	}
}

env.MODIFIERS.global_citadel = {
	name: "COREPUNCH",
	global: true,
	stacks: false,
	showIf: () => {
		return (
		page.party.some(mem => mem.alterations && mem.alterations.some(alt => alt.includes('eyes_humorist'))) 
		&&
		env.crittaMap.tension >= 1
		)
	},
	tension: 0,
	icon: "/img/textures/disruptionC.gif",
	priority: 999,
	getHelp: ()=> `<span class="friend-color">5072696F72697479207761726E696E673A2074656E207365636F6E647320746F2073696E67756C61726974792E</span>`,

	onChosen: function () {
		env.crittaMap.currentRowSetting = CrittaMap.ROWSETTINGS.intrusive
		env.crittaMap.setAttribute("special", "intrusive")

		setTimeout(()=>{
			env.crittaMap.querySelector('critta-node[difficulty="3"]').formation = env.COMBAT_FORMATIONS.citadel
		}, 800)
	}
}

env.MODIFIERS.global_firing_squad = {
	name: "EVIL MODE",
	global: true,
	stacks: false,
	showIf: () => {
		return (
		page.party.some(mem => mem.alterations && mem.alterations.some(alt => alt.includes('claws_humorist'))) 
		&&
		env.crittaMap.tension >= 1
		)
	},
	tension: 0,
	icon: "/img/sprites/obesk/geli/bsteli/portrait_bstrd.gif",
	priority: 999,
	getHelp: ()=> `<span class="bastard-color">ORUGS4ZAOBQXE5BAN5TCAZDBEBSHEZLBNUQGQYLTMUQGEZLFNYQGG2DPONSW4IBSEBRGKY3PNVSS4LROEBCVMSKMEBGU6RCFEEQSC===</span>`,

	onChosen: function () {
		env.crittaMap.currentRowSetting = CrittaMap.ROWSETTINGS.intrusive
		env.crittaMap.setAttribute("special", "intrusive")

		setTimeout(()=>{
			env.crittaMap.querySelector('critta-node[difficulty="3"]').formation = env.COMBAT_FORMATIONS.firing_squad
		}, 800)
	}
}

env.MODIFIERS.global_intrusive_rematch = {
	name: "REMATCH",
	global: true,
	stacks: false,
	showIf: () => {
		return (
		page.party.every(member=>member?.alterations?.find(alter => alter[1] == "light_humorist"))
		&&
		env.crittaMap.tension >= 1
		)
	},
	tension: 0,
	icon: "/img/sprites/flantrusive/icon.gif",
	priority: 0,
	getHelp: ()=> `<span class="neutral-color">Ã¸Ã¿Â°ÃžÃœÃ¿â€ºÃ‹Ã…Ã¿Â¥Ã”Ã‹Ã¿Â«Ã—ÃÃ¿Â®Ã˜ÃÃ¿Â«Ã›Ã‘Ã¿Â¦Ã”Ã‰Ã¿â€”ÃÂ¶Ã¿â€“Ã€Â´Ã¿Â«Ã–ÃŠÃ¿Â ÃŒÂ¿Ã¿â€™Â½Â´Ã¿Â¤Ã”ÃÃ¿Â¤Ã™Ã‘Ã¿â€Ã‹ÃƒÃ¿ÂÃ‰Ã„Ã¿Â¨Â°ÂÃ¿Âl</span>`,

	onChosen: function () {
		env.crittaMap.currentRowSetting = CrittaMap.ROWSETTINGS.intrusive
		env.crittaMap.setAttribute("special", "intrusive")

		setTimeout(()=>{
			env.crittaMap.querySelector('critta-node[difficulty="3"]').formation = env.COMBAT_FORMATIONS.intrusive_rematch
		}, 800)
	}
}

env.MODIFIERS.global_dullzkoviks_revenge = {
	name: "CEREMONY",
	global: true,
	stacks: false,
	showIf: () => {
		return (
		page.party.some(mem => mem.alterations && mem.alterations.some(alt => alt.includes('dull_humorist'))) 
		&&
		env.crittaMap.tension >= 1
		)
	},
	tension: 0,
	icon: "/img/local/orbit/dullportal_backed_small.gif",
	priority: 999,
	getHelp: ()=> `<span class="bright-color">r8lEVoDVR@pdW#FoHhSHpFJC-qBKqQrZxz4mP92Raxy{8t1IdgqY]1rk$su^mO=]8k$<@{r7P!M===</span>`, // "TOTAL ANNIHILATION, REMOVAL FROM VELZIE'S STAGE FOR ALL TIME"

	onChosen: function () {
		env.crittaMap.currentRowSetting = CrittaMap.ROWSETTINGS.intrusive
		env.crittaMap.setAttribute("special", "intrusive")

		setTimeout(()=>{
			env.crittaMap.querySelector('critta-node[difficulty="3"]').formation = env.COMBAT_FORMATIONS.dullzkovik
		}, 800)
	}
}

env.MODIFIERS.global_intrusive.showIf = () => { //redefining this so that getting to intrusive isn't as much of a nightmare
		return (
		page.party.some(mem => mem.alterations && mem.alterations.some(alt => alt.includes('light_humorist'))) 
		&&
		env.crittaMap.tension >= 1
		)
	}

// STATUS EFFECTS
    // modifiers
env.STATUS_EFFECTS.flesh_adrenaline = { 
    slug: "flesh_adrenaline",
    name: "Adrenaline",
    passive: "modifier",
    beneficial: true,
    icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_flesh_adrenaline.gif",
    impulse: {type: "common", component: "flesh"},
    
    events: {
        onTurn: function() {
            if(this.status.affecting.hp <= (this.status.affecting.maxhp / 4)) {
                addStatus({target: this.status.affecting, origin: false, status: "focused", length: 1}) 
                addStatus({target: this.status.affecting, origin: false, status: "evasion", length: 2}) 
            } 

            updateStats({actor: this.status.affecting})
        },
    },

    help: "receive +1T:FOCUSED and +2T:EVASION when HP < 25%"
}

env.STATUS_EFFECTS.flesh_terminallucidity = {
    slug: "flesh_terminallucidity",
    name: "Terminal Lucidity",
    passive: "modifier",
    beneficial: true,
    icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_flesh_terminal_lucidity.gif",
    impulse: {type: "common", component: "flesh"},
    
    events: {
        onTurn: function() {
            if(this.status.affecting.hp <= (this.status.affecting.maxhp * 0.15)) {
                addStatus({target: this.status.affecting, origin: false, status: "surge", length: 1})
                addStatus({target: this.status.affecting, origin: false, status: "focused", length: 2})
                addStatus({target: this.status.affecting, origin: false, status: "evasion", length: 3})
                addStatus({target: this.status.affecting, origin: false, status: "empowered", length: 2})
                addStatus({target: this.status.affecting, origin: false, status: "carapace", length: 3})
                addStatus({target: this.status.affecting, origin: false, status: "spikes", length: 3})
				addStatus({target: this.status.affecting, origin: false, status: "regen", length: 1})
                    if(!this.status.affecting.minotaursMazeContingencyPlan) {
                        if(!this.status.affecting.statusImmunities) {
                            this.status.affecting.statusImmunities = ["stun"]; //the game will shit itself if you add an immunity to someone who doesnt have them defined, so we define them here if they dont have any
                            this.status.affecting.minotaursMazeContingencyPlan = true //surprise tool that will help us later
                        } else if(!this.status.affecting.statusImmunities.includes("stun")) { //if they arent already immune to stun, makes them
                            this.status.affecting.statusImmunities.push("stun")
                            this.status.affecting.minotaursMazeContingencyPlan = true
                        }
                    }
            } else { //i know you can use an elif here but i'm too lost in a minotaurs maze of my own making
                if(this.status.affecting.minotaursMazeContingencyPlan) {//ok what the fuck is this
                    this.status.affecting.statusImmunities.pop() 
                    this.status.affecting.minotaursMazeContingencyPlan = false
                }
            }

            updateStats({actor: this.status.affecting})
        }
    },

    help: "receive wide array of positive status effects and stun immunity when HP < 15%"
}

    env.STATUS_EFFECTS.flesh_hysteria = { 
        slug: "flesh_hysteria",
        name: "Hysteria",
        passive: "modifier",
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_flesh_hysteria.gif",
        impulse: {type: "common", component: "flesh"},
		outgoingCrit: 0,
        
        events: {
            onTurn: function() {
				if(hasStatus(this.status.affecting, "fear")
					&& hasStatus(this.status.affecting, "flesh_hysteria")){
                    this.status.outgoingCrit = 2
                } else {
                    this.status.outgoingCrit = 0
                }

                updateStats({actor: this.status.affecting})
            },
        },

        help: "+200% outgoing crit rate if afflicted with FEAR"
    }, 

env.STATUS_EFFECTS.flesh_fightorflight = {
    slug: "flesh_fightorflight",
    name: "Fight or Flight",
    passive: "modifier",
    beneficial: false, //you have to LIE here for reasons i only pretend to comprehend
	outgoingToHit: 0,
	outgoingCrit: 0,
    icon: "https://narrativohazard-expunged.neocities.org/img/passives/fight_or_flight.gif", //change this if you so desire

    events: {
        GLOBAL_onBeforeCombatHit: function(context) { //run before ALL moves decide if they hit
            if(context.origin == this.status.affecting) { //so that this only applies to the impulse haver
                let fearCount = hasStatus(context.originalEventTarget, "fear") //gets number of turns of fear

                if(fearCount) { //checks if fearcount returned anything
                    this.status.outgoingToHit = 0.5 * fearCount //0.5 per fear, 0.5 = 50%
                    this.status.outgoingCrit = 0.5 * fearCount //0.5 per fear, 0.5 = 50%
                } else {
                    this.status.outgoingToHit = 0 //dont do shit if fearcount didnt give anything
                    this.status.outgoingCrit = 0 //dont do shit if fearcount didnt give anything
                }
			}
		},
		onCrit: function({subject, origin, attack, beneficial}) {
			if(beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
			if(attack !== 0) {
				addStatus({target: subject, origin, status: "fear", length: (attack)}); 

				setTimeout(
					()=>{
						play("fear", 0.75, 0.5)
					
						sendFloater({
							target: this.status.affecting,
							type: "arbitrary",
							arbitraryString: "FIGHT!",
						})
									
						readoutAdd({
							message: `${this.status.affecting.name}'s strike terrifies ${subject.name}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
							name: "sourceless", 
							type: "sourceless combat minordetail",
							show: false,
							sfx: false
						})
					},
				env.ADVANCE_RATE * 0.2)
			}
		}
    },
    help: "+50% outgoing hit and crit chance per T:FEAR\nwhen critting a foe, inflict xT:FEAR equal to damage dealt"
}

env.STATUS_EFFECTS.dull_hypervelocity = { 
    slug: "dull_hypervelocity",
    name: "Hypervelocity",
    passive: "modifier",
    beneficial: true,
    icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_dull_hypervelocity.gif",
    impulse: {type: "common", component: "dull"},
    
    events: {
        onAddStatus: function({target, statusObj}) {
            if(statusObj.slug == "evasion") {
                statusObj.infinite = true
            }
        },
    },

    help: "evasion has infinite duration"
}

    env.STATUS_EFFECTS.dull_highenergy = { 
        slug: "dull_highenergy",
        name: "High Energy",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_dull_high_energy.gif",
        impulse: {type: "common", component: "dull"},
        
        events: {
            onCrit: function({subject, origin, attack, beneficial}) {
                if(Math.random() < 0.75 || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                addStatus({target: subject, origin, status: "destabilized", length: 2}); 

                setTimeout(()=>{
                    play("dull", 1.5, 1.5)
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "HIGH ENERGY!",
                    })
                                    
                    readoutAdd({
                        message: `${this.status.affecting.name}'s strike sears their target! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "when critting a foe, 25% chance to inflict 2T:DESTABILIZED"
    }

    env.STATUS_EFFECTS.dull_multitool = { 
        slug: "dull_multitool",
        name: "Multi-tool",
        passive: "modifier",
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_dull_multitool.gif",
        impulse: {type: "common", component: "dull"},
        
        events: {
            onAction: function({user, action, target}) {
                if(action.slug.includes("incoherent_") || action.slug.includes("intrusive") || action.slug == "special_archiveshelf_annihilate" || target.state == "dead" || user.state == "dead" || hasStatus(user, "fear") || user.frenzyChainKilled == true) return;
                
                if(Math.random() < (0.15 + hasStatus(user, "light_humorist") ? 0.15 : 0)) {
					let nextAction = user.actions
					if(hasStatus(user, "windup")) {nextAction = user.windupActions}
					if(hasStatus(user, "winderup")) {nextAction = user.winderupActions}
					if(hasStatus(user, "windestup")) {nextAction = user.windestupActions}
					if(hasStatus(user, "final_windup")) {nextAction = user.finalWindupActions}
					let chosenAction = env.ACTIONS[nextAction.sample()]

                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: `MULTI-TOOL::${chosenAction.name.toUpperCase()}`,
                        size: 1.5
                    })

                    readoutAdd({
                        message: `${user.name} acts again! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
					onBeforeAction: { // oh wow i didn't even realize you could make onBeforeAction a property of onAction, that's wild
						if(chosenAction.beneficial) // stop quick mending the firmament !! idiot !! stupid !!
							target = user.team.members.filter(member => member.state == "living").sample()
						else target = user.enemyTeam.members.filter(member => member.state == "living").sample() // stop hitting yourself !! stop hitting yourself !!
					}
                    setTimeout(()=>useAction(user, chosenAction, chosenAction.beneficial ? user : target, {triggerActionUseEvent: true, beingUsedAsync: true, reason: "multitool"}), 500)
                }
            },
        },

        help: "most actions have a 15% chance to prompt another random action\nactions used by multi-tool can trigger multi-tool again"
    },

    env.ACTIONS.special_irradiate = {
        slug: "special_irradiate",
        name: "Irradiate",
        type: 'special',
        desc: "'flood battlefield with dull radiation';'fatal if misused'",
        help: "ALL::AUTOHIT +1T:DESTABILIZE",
        anim: "wobble",
        autohit: true,
        canCrit: false,
        exec: function(user, target, beingUsedAsync) {
            
            if(env.rpg.classList.contains("bastard")) {                
                if(user.team.name == "ally") {
                    env.rpg.classList.add('incoherentbg')
                    content.classList.add('painprep', 'painfade', 'painhalf')
                    setTimeout(()=>{content.classList.add('painmode')}, 50)
                    setTimeout(()=>{content.classList.remove('painmode')}, 2000)
                    setTimeout(()=>{content.classList.remove('painprep', 'painfade', 'painhalf')}, 2500)

                    setTimeout(()=>{env.rpg.classList.remove('incoherentbg')}, 2000)
                }
            } else {
                ratween(env.bgm, 1, 2000)
                env.rpg.classList.add('incoherentbg')
                content.classList.add('painprep', 'painhalf')
                setTimeout(()=>{content.classList.add('painmode')}, 50)
                setTimeout(()=>{content.classList.remove('painmode')}, 2000)
                setTimeout(()=>{content.classList.remove('painprep', 'painhalf')}, 2500)
            }
            
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        autohit: true,
                        hitSfx: {
                            name: 'destabilize',
                            rate: 0.75
                        },
                        genExec: ({target}) => {
                            addStatus({target: actor, origin: user, status: "destabilized", length: 1});
                        }
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },

    env.STATUS_EFFECTS.dull_acuteexposure = { 
        slug: "dull_acuteexposure",
        name: "Acute Exposure",
        passive: "modifier",
        help: "all targeted actions have a 20% chance to become IRRADIATE\nIRRADIATE::(ALL::AUTOHIT +1T:DESTABILIZE)",
        infinite: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/acute_exposure.gif",
        
        events: {
            onBeforeAction: function(context) {
                if(!context.settings.action.type.includes("target")) return;
                
                // alter action maybe
                if(Math.random() < (0.2)) {

                    context.settings.action = env.ACTIONS["special_irradiate"]
                    let subject = context.settings.user

                    sendFloater({
                        target: subject,
                        type: "arbitrary",
                        arbitraryString: "EXPOSURE!",
                        isGood: false,
                        size: 2,
                    })

                    readoutAdd({
                        message: `dull radiation flows through ${subject.name}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }
            },
        }
    },
	
	env.STATUS_EFFECTS.dull_calc = { 
        slug: "dull_calc",
        name: "Futurist",
        passive: true,
        help: "all actors receive PREPARATION, VEILKSPLITTER, DULLFLARE, and EXTRA PREPARATION",
        infinite: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/futurist.gif",
        // where we're going, we don't NEED an events property
    },

    env.STATUS_EFFECTS.spirestone_berserk = { 
        slug: "spirestone_berserk",
        name: "Berserk",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_spirestone_berserk.gif",
        impulse: {type: "common", component: "spirestone"},
        
        events: {
            onCrit: function({subject, origin, attack, beneficial}) {
				let rand = Math.random()
                if(rand > 0.25 || subject == this.status.affecting || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                addStatus({target: subject, origin, status: "open_wound", length: 2}); 
                
                setTimeout(()=>{
                    playCombatCrit()
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "BERSERK!",
                    })
                                    
                    readoutAdd({
                        message: `${origin.name} leaves ${subject.name} reeling! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "when critting a foe, 25% chance to inflict 2T:OPEN WOUND"
    },

    env.STATUS_EFFECTS.spirestone_rebound = { 
        slug: "spirestone_rebound",
        name: "Rebound",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_spirestone_rebound.gif",
        impulse: {type: "common", component: "spirestone"},
        
        events: {
            onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "stun") {
                    addStatus({target: target, origin: false, status: "surge", length: 1})
					addStatus({target: target, origin: false, status: "evasion", length: 2})
					addStatus({target: target, origin: false, status: "focused", length: 1})
                }
            },
        },
        help: "grant 1T:FOCUSED, 2T:EVASION and SURGE and when stun is removed"
    },

    env.STATUS_EFFECTS.spirestone_carapace = {
        slug: "spirestone_carapace",
        name: "Defensive Maneuvers",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_spirestone_defensive_maneuvers.gif",
        impulse: {type: "common", component: "spirestone"},
        
        events: {
            onBeforeAddStatus: function(context) {
                if(context.status == "carapace") context.status = "unnatural_carapace_flat"
				if(context.status == "spikes") context.status = "serrations"
            },
        },

        help: "carapace becomes unnatural carapace, spikes becomes serrations"
    },

	env.STATUS_EFFECTS.spirestone_unshakeable = { 
		slug: "spirestone_unshakeable",
		name: "Unshakeable",
		passive: true,
		beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/unshakeable.gif",
		
		events: {
			onCreated: function() {
					if(!this.status.affecting.minotaursMazeContingencyPlan) {
						if(!this.status.affecting.statusImmunities) {
							this.status.affecting.statusImmunities = ["stun"]; //the game will shit itself if you add an immunity to someone who doesnt have them defined, so we define them here if they dont have any
							this.status.affecting.minotaursMazeContingencyPlan = true //surprise tool that will help us later
						} else if(!this.status.affecting.statusImmunities.includes("stun")) { //if they arent already immune to stun, makes them
							this.status.affecting.statusImmunities.push("stun")
							this.status.affecting.minotaursMazeContingencyPlan = true
						}
					}
				updateStats({actor: this.status.affecting})
			} 
		},

		help: "all actors have stun immunity"
	},
	
	env.STATUS_EFFECTS.hands_heal = { 
        slug: "hands_heal",
        name: "Last Rites",
        passive: true,
        beneficial: true,
        impulse: {type: "common", component: "hands"},
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_hands_last_rites.gif",
        
        events: {
            GLOBAL_onDeath: function({originalEventTarget}) {
                if(
                    this.status.affecting.state == "dead" ||
                    this.status.affecting.team.members.includes(originalEventTarget)
                ) return;

                sendFloater({
                    target: this.status.affecting,
                    type: "arbitrary",
                    arbitraryString: "LAST RITES!",
                })

                readoutAdd({
                    message: `${this.status.affecting.name} heals from ${originalEventTarget.name}'s defeat! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail",
                    show: false,
                    sfx: false
                })

                combatHit(this.status.affecting, {amt: -4, beneficial: true, origin: this.status.affecting, runEvents: false});
            }
        },

        help: "on foe down, receive +4HP"
    },
	
	env.STATUS_EFFECTS.hands_trial = { 
        slug: "hands_trial",
        name: "Trial By Fire",
        passive: "modifier",
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_hands_trial_by_fire.gif",
        impulse: {type: "common", component: "hands"},
        
        events: {
            onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "puncture") {
                    addStatus({target: target, origin: false, status: "regen", length: 1})
                    combatHit(this.status.affecting, {amt: -1, beneficial: true, origin: this.status.affecting, runEvents: false});
                }
            },
        },

        help: "grant +1HP and +1T:REGEN when puncture is removed"
    },
	
	env.STATUS_EFFECTS.hands_damnation = { 
        slug: "hands_damnation",
        name: "Damnation",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_hands_damnation.gif",
        impulse: {type: "common", component: "hands"},
        
        events: {
            onHit: function({subject, origin, attack, beneficial}) {
                if(beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                addStatus({target: subject, origin, status: "cursed", length: 1}); 

                setTimeout(()=>{
                    play("talkfairy", 0.5, 0.5)
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "DAMNATION!",
                    })

                    readoutAdd({
                        message: `${this.status.affecting.name}'s strike curses their target! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "when hitting a foe, inflict +1T:CURSED"
    },
	
	env.STATUS_EFFECTS.hands_allseeing = { 
        slug: "hands_allseeing",
        name: "All-Seeing",
        passive: true,
        beneficial: true,
        impulse: {type: "common", component: "hands"},
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_hands_all_seeing.gif",
        
        events: {
            GLOBAL_onEvade: function({subject, target, attack, runEvents, originalEventTarget}) {
                let user = this.status.affecting
                if(
                    user.team.members.includes(target) || 
                    target.state == "dead" ||
                    user.state == "dead" ||
                    subject != user
                ) return;

                setTimeout(()=>{
                    addStatus({target: user, origin: user, status: "favored", length: 2}); 
					play('talkchoir', 1.25)
            
                    sendFloater({
                        target: user,
                        type: "arbitrary",
                        arbitraryString: "ALL-SEEING!",
                    })
                
                    readoutAdd({
                        message: `${user.name} sees a vision as they miss! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "when missing a foe, grant +2T:FAVORED"
    },
	
	env.STATUS_EFFECTS.hands_sacrifice = { 
        slug: "hands_sacrifice",
        name: "Bindism",
        passive: "modifier",
        beneficial: false,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_hands_bindism.gif",
        
        events: {
            onStruck: function({attack}) {
                let damageAmt = Math.floor(attack / 2)
				if(damageAmt < 1) {
					damageAmt = 1
				}
                if(damageAmt > 0) {
                    let validTargets = env.rpg.turnOrder.filter(actor => (actor != this.status.affecting) && (actor.state != "dead"))

                    setTimeout(()=>{
                        play('status', 0.5, 1)
                        let target = validTargets.sample()

                        sendFloater({
                            target,
                            type: "arbitrary",
                            arbitraryString: "BOUND!",
                        })
						
						combatHit(target, {amt: damageAmt, autohit: true, redirectable: false, runEvents: false});
						
                        readoutAdd({
                            message: `${target.name} receives a sacrifice of -${damageAmt}HP! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                            name: "sourceless", 
                            type: "sourceless combat minordetail", 
                            show: false,
                            sfx: false
                        })
                    }, env.ADVANCE_RATE * 0.2)
                }
            },
        },

        help: "half of damage taken is given to a random actor as damage (rounded down, min: -1HP)"
    },
	
	env.STATUS_EFFECTS.hands_daemon = {
        slug: "hands_daemon",
        name: "Faustian Deal",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_hands_faustian_pact.gif",
        impulse: {type: "common", component: "hands"},
        
        events: {
            onCrit: function({subject, origin, attack, beneficial}) {
				let user = this.status.affecting
				let target = this.status.affecting
				let rand = Math.random()
                if( (rand < 0.85) || subject == this.status.affecting || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead" || (user.team.members.filter(m=>m.slug.includes('hands')).length < 4)) return;
				//useAction(this.status.affecting, env.ACTIONS.special_player_handssummon, user, {beingUsedAsync: true, reason: "deal"}) <---- we don't actually need this part do we
                
                setTimeout(()=>{
					if(user.team.members.filter(m=>m.slug.includes('hands')).length < 4) {
						playCombatCrit('talkfairy', 0.4);

						let daemon_peasant = ['player_hands_critta_pawn','player_hands_critta_knight','player_hands_critta_bishop','player_hands_critta_rook']
						let daemon_royal = ['player_hands_critta_queen','player_hands_critta_king']
						let daemon_divine = ['order_pawn_mega', 'order_knight_mega', 'order_bishop_mega', 'order_rook_mega', 'order_queen_mega','order_king_mega']
						
						var newAllySlug = daemon_peasant.sample()
						var newAllySlug1 = daemon_royal.sample()
						var newAllySlug2 = daemon_divine.sample()

						//try to center the dude
						if(user.team.members.length == 14) {
							let uI = user.team.members.findIndex(a => a.slug == user.slug)
							if(uI < 3) midCombatAllyAdd('player_hands_critta_pawn', 'left')
							else if(uI >= 3) midCombatAllyAdd('player_hands_critta_pawn', 'right')	
						} else {
							let rand = Math.random()
							if (rand > 0.5) {
								let rand1 = Math.random()
								if (rand1 < 0.5) {
									midCombatAllyAdd(newAllySlug,'left')
								}
								else if (rand1 < 0.8) {
									midCombatAllyAdd(newAllySlug1,'left')	
								}
								else {
									midCombatAllyAdd(newAllySlug2,'left')	
								}
							}
							else {
								let rand2 = Math.random()
								if (rand2 < 0.5) {
									midCombatAllyAdd(newAllySlug,'right')
								}
								else if (rand2 < 0.8) {
									midCombatAllyAdd(newAllySlug1,'right')
								}
								else {
									midCombatAllyAdd(newAllySlug2,'right')
								}
							}
						}
					}
					
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "DEAL!",
                    })

                    readoutAdd({
                        message: `${origin.name}'s powerful strike binds a daemon onto the battlefield! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "when critting a foe, 15% chance to summon daemonic ally (max:4)"
    },
	
	env.STATUS_EFFECTS.hands_superstition = {
		slug: "hands_superstition",
		name: "Superstitious",
		passive: true,
		beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/tarot_addiction.gif",
		events: {
			onAction: function({action}) {
				if(action.slug.includes('tarot') || action.slug.includes('select') || action.slug.includes('intrusive')) return
				else useAction(this.status.affecting, env.ACTIONS.special_tarot_noadvance, this.status.affecting, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "superstition"})
			}
		},
		help: "draw tarot card when using most actions"
	},
	
	env.ACTIONS.metal_drone_deflect = {
        slug: "metal_drone_deflect",
        name: "Drone Strike",
        type: 'target',
        desc: "'strike against analyzed weakness'",
        anim: "basic-attack",
        help: "75% -1HP +2T:VULNERABLE, 10%C x2 +1T:STUN",
        usage: {
            act: "%USER THROWS %TARGET OFF",
        },
        accuracy: 0.75,
        crit: 0.1,
        amt: 1,
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
				hitStatus: {
					name: 'vulnerable',
					length: 2
				},
				critStatus: {
					name: 'stun',
					length: 1
				},
            })
        }
    },
	
	env.STATUS_EFFECTS.metal_drone = { 
        slug: "metal_drone",
        name: "Countermeasures",
        passive: true,
        beneficial: true,
        impulse: {type: "common", component: "metal"},
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_metal_countermeasures.gif",
        
        events: {
            onTurn: function() {
                let user = this.status.affecting
                let shownNotice = false
                env.recentSfx = false

                env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i) => {
                        if(hasStatus(actor, "windup") || hasStatus(actor, "winderup")) {
                            env.GENERIC_ACTIONS.singleTarget({
                                action: env.ACTIONS['metal_drone_deflect'], 
                                user, 
                                target: actor,
                                hitSfx: { name: 'shot2', rate: 1, volume: 0.5 },
                                critSfx: { name: 'shot6', rate: 1, volume: 1 },
								missSfx: { name: 'shot2', rate: 1.5, volume: 0.5 },
								hitStatus: { name: 'vulnerable', length: 2 },
								critStatus: { name: 'stun', length: 1 },
                                genExec: ()=>{
                                    if(!shownNotice) {
                                        sendFloater({
                                            target: user,
                                            type: "arbitrary",
                                            arbitraryString: "COUNTERMEASURES!",
                                        })

                                        readoutAdd({
                                            message: `${user.name}'s <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span> distracts all wound up foes`, 
                                            name: "sourceless", 
                                            type: "sourceless combat minordetail", 
                                            show: false,
                                            sfx: false
                                        })

                                        shownNotice = true
                                    }
                                }
                            })
                        }
                    }
                })
            },
        },

        help: `if alive, attack all wound up foes on turn\n(${env.ACTIONS['metal_drone_deflect'].help})`
    },
	
	env.STATUS_EFFECTS.metal_adaptive = { 
        slug: "metal_adaptive",
        name: "Responsive Armor",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_metal_responsive_armor.gif",
        impulse: {type: "common", component: "metal"},
        
        events: {
            onStruck: function({subject, attack, beneficial}) {
                if(beneficial || this.status.affecting.state == "dead" || subject == this.status.affecting) return;
                addStatus({target: this.status.affecting, origin: subject, status: "carapace", length: 2}); 

                setTimeout(()=>{
                    play("guard", 1.25, 0.5)
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "RESPOND!",
                    })

                    readoutAdd({
                        message: `${this.status.affecting.name}'s form shifts defensively in response to the attack! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "when struck offensively, gain 2T:CARAPACE"
    },
	
	env.ACTIONS.brawl_weak_metal = {
        slug: "brawl_weak_metal",
        name: "Heavy Strike",
        verb: "strike",
        type: 'target',
        desc: "'improvise risky but powerful strike'",
        anim: "basic-attack",
        help: "40% -2HP, 5%C X2",
        usage: {
            act: "%USER CLUMSILY ATTACKS %TARGET",
            crit: "%TARGET IS KNOCKED BACK",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET EVADES"
        },
        accuracy: 0.4,
        crit: 0.05,
        amt: 2,
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
				missSfx: {
					name: 'miss',
					rate: 0.75
				},
            })
        }
    },
	
    env.STATUS_EFFECTS.metal_disable = { 
        slug: "metal_disable",
        name: "Paralysis",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_metal_paralysis.gif",
        impulse: {type: "common", component: "metal"},
        
        events: {
            onCrit: function({subject, origin, attack, beneficial}) {
                if(Math.random() > 0.25 || subject == this.status.affecting || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                addStatus({target: subject, origin, status: "weakened", length: 2}); 
                
                setTimeout(()=>{
                    playCombatCrit()
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "PARALYSIS!",
                    })
                                    
                    readoutAdd({
                        message: `${origin.name} leaves ${subject.name} reeling! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "when critting a foe, 25% chance to inflict 2T:WEAKENED"
    },
	
	env.ACTIONS.special_metal_destruct = {
        slug: "special_metal_destruct",
        name: "Explode",
        type: 'special',
        desc: "'form shrapnel in body';'propel through unsustainable means'",
        help: "FOES::50% -1HP, 2.5%C x2 +2T:PUNCTURE",
        anim: "explode",
		itemAction: true, //WHY the FUCK can IMPS USE THIS ???????????? FJIDARE*A()U$@QI%TR)SOOUJ#%)(WIR
        accuracy: 0.5,
        crit: 0.025,
        amt: 1,
        usage: {
            act: "%USER JUST EXPLODES"
        },
        exec: function(user, beingUsedAsync) {
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action: action, 
                        user, 
                        target: actor,
                        hitSfx: { name: 'shot2' },
                        critSfx: { name: 'shot6' },
                        critStatus: {
                            name: 'puncture',
                            length: 2
                        },
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.STATUS_EFFECTS.metal_explode = {
        slug: "metal_explode",
        name: "Volatile",
        passive: true,
        beneficial: true,
        impulse: {type: "common", component: "metal"},
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_metal_volatile.gif",
        
        events: {
            onCritStruck: function() {
                let user = this.status.affecting
                let shownNotice = false
                env.recentSfx = false

				useAction(this.status.affecting, env.ACTIONS.special_metal_destruct, user, {beingUsedAsync: true, reason: "volatile"})

				if(!shownNotice) {
					sendFloater({
						target: user,
						type: "arbitrary",
						arbitraryString: "VOLATILE!",
					})

					readoutAdd({
						message: `${user.name} explodes as they are struck!`, 
						name: "sourceless", 
						type: "sourceless combat minordetail", 
						show: false,
						sfx: false
					})

					shownNotice = true
				}
            },
        },

        help: `when receiving a critical hit, explode\n(${env.ACTIONS['special_metal_destruct'].help})`
    },
	
	env.STATUS_EFFECTS.metal_groundsmind = {
        slug: "metal_groundsmind",
        name: "Illegal Groundsmindry",
        passive: "modifier",
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_metal_illegal_groundsmindry.gif",
        impulse: {type: "common", component: "metal"},
        
        events: {
            GLOBAL_onBeforeCombatHit: function(context) {
                if(context.origin == this.status.affecting) {
                    let destabTarget = hasStatus(context.originalEventTarget, "destabilized") // this is ugly as hell but it'll work fine so like. eh
					let destabUser = hasStatus(context.origin, "destabilized")
					let denatTarget = 2 * hasStatus(context.originalEventTarget, "denatured")
					let denatUser = 2 * hasStatus(context.origin, "denatured")
					let finalCount = destabTarget + destabUser + denatTarget + denatUser

                    if(context.amt > 0 && finalCount && !context.beneficial) {
                        this.status.outgoingToHit = 0.5 * finalCount
						this.status.outgoingCrit = 0.5 * finalCount
                    } else {
                        this.status.outgoingToHit = 0
						this.status.outgoingCrit = 0
                    }
                }

                updateStats({actor: this.status.affecting})
            },
        },

        help: "+50% HIT%, CRIT% per T:DESTABILIZED of attacked target and/or user"
    },
	
	env.STATUS_EFFECTS.metal_calc = {
        slug: "metal_calc",
        name: "Overclock",
        passive: "modifier",
        beneficial: true,
        icon: "/img/sprites/combat/passives/bone_collectivism.gif",
		//where we're going, we don't NEED an events property
        help: "all actors receive PREPARATION and CALCULATED STRIKE"
    },

	env.STATUS_EFFECTS.pain_terriblelife = {
		slug: "pain_terriblelife",
		name: "Terrible Life",
		passive: "modifier",
		beneficial: false,
		infinite: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/terrible_life.gif",
		events: {
			onTurn: function() {
                //deals either 10% of their remaining HP, or 1 damage (whichever's higher)
                //console.log('target is', this.status.affecting, 'so executing', this.status)
                reactDialogue(this.status.affecting, 'puncture');

                let amt = (Math.floor(this.status.affecting.hp * 0.1) || 1)

                combatHit(this.status.affecting, {amt: amt, autohit: true, redirectable: false, runEvents: false});
                play('status', 1, 0.5);
            },
			
			onStruck: function({subject, attack, beneficial}) {
                if(beneficial) return;
                let returnDmg = -1 * (Math.max(Math.floor(attack * 0.5)+1))

                setTimeout(()=>{
                    sendFloater({
                        target: subject,
                        type: "arbitrary",
                        arbitraryString: "TERRIBLE LIFE!",
                        isGood: false,
                        size: 1,
                    })

                    readoutAdd({
                        message: `${subject.name} receives +${Math.abs(returnDmg)}HP via <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })

                    forcePlay("mend", 0.7, 0.8)
                    combatHit(subject, {amt: returnDmg, autohit: true, crit: 0, origin: false, redirectable: false})
                }, env.ADVANCE_RATE * 0.2)
            },
		},
		help: "-10%HP/turn, min:1\nattackers receive 50% of damage as HP, min:1"
	},
	
	env.STATUS_EFFECTS.pain_reflexes = { 
        slug: "pain_reflexes",
        name: "Lingering Reflexes",
        passive: "modifier",
        help: "all targeted actions have a 20% chance to become FAMILIAR STRIKE\nFAMILIAR STRIKE::80% -2HP, 10%C x2 + (TARGET TEAM::+2T:FEAR)",
        infinite: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/reflexes.gif",
        
        events: {
            onBeforeAction: function(context) {
                if(!context.settings.action.type.includes("target")) return;
                
                // alter action maybe
                if(Math.random() < (0.2)) {

                    context.settings.action = env.ACTIONS["husk_attack_impulse"]
                    let subject = context.settings.user

                    sendFloater({
                        target: subject,
                        type: "arbitrary",
                        arbitraryString: "REFLEX!",
                        isGood: false,
                        size: 2,
                    })

                    readoutAdd({
                        message: `${subject.name}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }
            },
        }
    },
	
	env.STATUS_EFFECTS.pain_terror = { 
        slug: "pain_terror",
        name: "Terror",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_pain_terror.gif",
        impulse: {type: "common", component: "pain"},
        
        events: {
            onCrit: function({subject, origin, attack, beneficial}) {
                if(Math.random() > 0.25 || subject == this.status.affecting || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                addStatus({target: subject, origin, status: "fear", length: 3}); 
                
                setTimeout(()=>{
                    play('fear', 0.75)
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "TERROR!",
                    })
                                    
                    readoutAdd({
                        message: `${origin.name} leaves ${subject.name} paralyzed with fear! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "when critting a foe, 25% chance to inflict 3T:FEAR"
    },
	
	env.STATUS_EFFECTS.pain_strength = { 
        slug: "pain_strength",
        name: "Thrillseeker",
        passive: true,
        beneficial: true,
        impulse: {type: "common", component: "pain"},
		outgoingMult: 0,
		outgoingFlatCrit: 0,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_pain_thrillseeker.gif",
        
        events: {
            onTurn: function() {
                if(this.status.affecting.hp <= this.status.affecting.maxhp * 0.25) { 
					this.status.outgoingMult = 2
					this.status.outgoingFlatCrit = 10
				}
                else { 
					this.status.outgoingMult = 0
					this.status.outgoingFlatCrit = 0
				}
            },
        },

        help: "+200% outgoing damage/heal and +10% base crit rate (before bonuses) at <25% HP"
    },
	
	env.STATUS_EFFECTS.pain_masochist = {
		slug: "pain_masochist",
		name: "Masochist",
		passive: true,
		beneficial: true,
		impulse: {type: "common", component: "pain"},
		outgoingToHit: 0,
		outgoingCrit: 0,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_pain_masochist.gif",
		
		events: {
			GLOBAL_onBeforeCombatHit: function(context) { //run before ALL moves decide if they hit
				if(context.origin == this.status.affecting) { //so that this only applies to the impulse haver
					let turnCount = 0
					for(let status of Object.values(env.STATUS_EFFECTS)) {
						if(!status['beneficial'] && !status['passive'] ) { //don't iterate through impulses
							let turnAdd = Math.floor(hasStatus(this.status.affecting, status.slug))
							turnCount = turnCount + turnAdd
						}
					} //gets number of turns of all negative statuses

					if(turnCount) { //checks if turnCount returned anything
						this.status.outgoingToHit = 0.25 * turnCount //0.2 per effect
						this.status.outgoingCrit = 0.25 * turnCount //0.2 per effect
					} else {
						this.status.outgoingToHit = 0 //dont do shit if turnCount didnt give anything
						this.status.outgoingCrit = 0 //dont do shit if turnCount didnt give anything
					}
				}
			},
		},
		help: "+25% outgoing hit%, crit% per turn of all detrimental status effects"
	},
	
	env.STATUS_EFFECTS.pain_secri = {
		slug: "pain_secri",
		name: "Asymptomatic",
		passive: true,
		beneficial: true,
		impulse: {type: "common", component: "pain"},
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_pain_asymptomatic.gif",
		
		events: {
			onDeath: function() {
				let user = this.status.affecting
				if(user.initialStatusEffects && user.initialStatusEffects.includes("ethereal")) return; //don't summon a secri if the last death was a summoned actor
				else if(user.slug.includes("pain")) return; //why do i have to do this bullshit
				else if(user.team.members.includes("critta_jester")) return;
				else if(user.team.members.includes("critta_spawner")) return;
				else if(user.team.name == "enemy") {
					if(this.status.lastSide) {
						midCombatEnemyAdd('pain_secri_enemy', 'left') //TODO::actually make the pain_secri_enemy actor
						play('stab', 0.5)
						this.status.lastSide = 0
					} else {
						midCombatEnemyAdd('pain_secri_enemy', 'right') //also maybe make it summon an ally version if the affected actor is on the ally team
						play('stab', 0.5)
						this.status.lastSide = 1
					}
				} else {
					if(this.status.lastSide) {
						midCombatAllyAdd('pain_secri_ally', 'left')
						play('stab', 0.5)
						this.status.lastSide = 0
					} else {
						midCombatAllyAdd('pain_secri_ally', 'right')
						play('stab', 0.5)
						this.status.lastSide = 1
					}
				}
				
				sendFloater({
					target: user,
					type: "arbitrary",
					arbitraryString: "ASYMPTOMATIC!",
					size: 1.5,
				})
			
				readoutAdd({
					message: `the secri abandons its host as ${user.name} dies! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
					name: "sourceless", 
					type: "sourceless combat minordetail", 
					show: false,
					sfx: false
				})

				setTimeout(()=>{
					removeStatus(this.status.affecting, 'pain_secri', {forceRemoveStatus: true})
				}, env.ADVANCE_RATE * 0.2)
			},
		},
		help: "on death, summon secri\nif dead actor is an ally, summon as ally\nif dead actor is a foe, summon as foe"
	},
	
	env.STATUS_EFFECTS.intrusive_incoherence = { 
        slug: "intrusive_incoherence",
        name: "Incoherence Spike",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_flantrusive_incoherence_spike.gif",
        impulse: {type: "common", component: "intrusive"},
        
        events: {
            onCrit: function({subject, origin, attack, beneficial}) {
				let rand = Math.random()
                if(rand > 0.1 || subject == this.status.affecting || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                addStatus({target: subject, origin, status: "weak_point", length: 1}); 
                
                setTimeout(()=>{
                    play("talkfairy6", 0.25)
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "INCOHERENT!",
                    })
                                    
                    readoutAdd({
                        message: `${origin.name} leaves ${subject.name} reeling! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.5)
            }
        },

        help: "when critting a foe, 10% chance to inflict WEAK POINT"
    },
	
	env.STATUS_EFFECTS.intrusive_betrayal = { 
        slug: "intrusive_betrayal",
        name: "Revisionist",
        passive: "modifier",
        help: "beneficial actions have a 25% chance to become REVISE\nREVISE::(70% -2HP, 30%C x2 + BENEFICIAL STATUS INVERSION)",
        infinite: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/revisionist.gif",
        
        events: {
            onBeforeAction: function(context) {
                if(!context.settings.action.type.includes("target") || !context.settings.action.beneficial) return;
                
                // alter action maybe
                if(Math.random() < 0.25) {

                    context.settings.action = env.ACTIONS["revise"]
                    let subject = context.settings.user

                    reactDialogue(subject, 'laugh')

                    sendFloater({
                        target: subject,
                        type: "arbitrary",
                        arbitraryString: "REVISIONIST!",
                        beneficial: false,
                        size: 2,
                    })

                    readoutAdd({
                        message: `${subject.name} revises ${context.settings.target.name}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }
            },
        }
    },
	
	env.STATUS_EFFECTS.intrusive_finisher = {
        slug: "intrusive_finisher",
        name: "Jackpot",
        passive: true,
        beneficial: true,
        impulse: {type: "common", component: "intrusive"},
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_flantrusive_jackpot.gif",
        
        events: {
            GLOBAL_onDeath: function({originalEventTarget}) {
                if(
                    this.status.affecting.state == "dead" ||
                    this.status.affecting.team.name == originalEventTarget.team.name
                ) return;
                    
                sendFloater({
                    target: this.status.affecting,
                    type: "arbitrary",
                    arbitraryString: "JACKPOT!",
                })

                readoutAdd({
                    message: `${this.status.affecting.name} focuses as their foe falls! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail", 
                    show: false,
                    sfx: false
                })

                addStatus({target: this.status.affecting, origin: false, status: "focused", length: 2})                
            }
        },

        help: "on foe down, receive +2T:FOCUSED"
    },
	
	env.STATUS_EFFECTS.intrusive_calc = {
        slug: "intrusive_calc",
        name: "Memory Bleed",
        passive: "modifier",
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/memory_bleed.gif",
		//where we're going, we don't NEED an events property
        help: "all actors receive PREPARATION and UNNATURAL STRIKE"
    },
	
	env.STATUS_EFFECTS.intrusive_siphon = {
        slug: "intrusive_siphon",
        name: "Consumption",
        help: "attackers receive +2T:SIPHON",
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_flantrusive_devour.gif",
		passive: "modifier",
		beneficial: true,
		infinite: true,
		impulse: {type: "common", component: "intrusive"},
        events: {
            onStruck: function({subject, attack}) {
                if(subject.state == "dead") return;
				if(subject == this.status.affecting) return;
            
                sendFloater({
                    target: subject,
                    type: "arbitrary",
                    arbitraryString: "CONSUMPTION!",
                })
                
                readoutAdd({
                    message: `${subject.name} receives +2T:SIPHON via <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail",
                    show: false,
                    sfx: false
                })

                addStatus({target: subject, origin: false, status: "siphon", length: 2, noReact: true}); 
            },
        }
    },
	
	env.STATUS_EFFECTS.intrusive_unknown_real = { 
        slug: "intrusive_unknown_real",
        name: "???",
        passive: "modifier",
        help: "all targeted actions have a 20% chance to become GAMBLE",
        infinite: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/unknown_real.gif",
        
        events: {
			onCreated: function({statusObj}) {
                if(statusObj.slug == "intrusive_unknown_real" && !this.status.initialized) {
                    let actor = this.status.affecting

                    env.rpg.insertAdjacentHTML('beforeend', `
                    <figure id="chancepanel" class="hidden" for="${actor.slug}">
                        <img src="/img/sprites/flantrusive/panelbase.gif">
                        <div class="wheel">
                            <ul>
                                <li class="d1">1</li>
                                <li class="d2">2</li>
                                <li class="d3">3</li>
                                <li class="d4">4</li>
                                <li class="d5">5</li>
                                <li class="d6">6</li>
                            </ul>
                        </div>
                        <div class="display">
                            <ol>
                                <li class="d1">1. life up</li>
                                <li class="d2">2. main up</li>
                                <li class="d3">3. unlucky</li>
                                <li class="d4">4. bomb</li>
                                <li class="d5">5. unlucky</li>
                                <li class="d6">6. change</li>
                            </ol>
                        </div>
                        <div class="result">
                            <div>
                                <span></span>
                            </div>
                        </div>
                    </figure>`)
                
                    actor.chancePanel = env.rpg.querySelector(`#chancepanel[for="${actor.slug}"]`)
                    actor.chancePanel.result = actor.chancePanel.querySelector(".result span")
                    actor.chancePanel.spin = (state) => { 
                        actor.chancePanel.removeAttribute("chosen")
                        actor.chancePanel.classList.toggle("spinning", state) 
                        actor.chancePanel.result.innerHTML = "???"
                    }
                
                    actor.chancePanel.stopAndResult = () => { 
                        let result = rand(1, 7)
                        actor.chancePanel.spin(false)
                        actor.chancePanel.setAttribute("chosen", result)
                
                        return result
                    }
                } 
            },
			
            onBeforeAction: function(context) {
                if(!context.settings.action.type.includes("target")) return;
                
                // alter action maybe
                if(Math.random() < (0.2)) {

                    context.settings.action = env.ACTIONS["special_intrusive_impulse"]
                    let subject = context.settings.user

                    sendFloater({
                        target: subject,
                        type: "arbitrary",
                        arbitraryString: "UNLUCKY! CHA CHA",
                        isGood: false,
                        size: 2,
                    })

                    readoutAdd({
                        message: `${subject.name} Ã¸Ã¿Â°ÃžÃœÃ¿â€ºÃ‹Ã…Ã¿Â¥Ã”Ã‹Ã¿Â«Ã—ÃÃ¿Â®Ã˜ÃÃ¿Â«Ã›Ã‘Ã¿Â¦Ã”Ã‰Ã¿â€”ÃÂ¶Ã¿â€“Ã€Â´Ã¿Â«Ã–ÃŠÃ¿Â ÃŒÂ¿Ã¿â€™Â½! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }
            },
        }
    },
	
    env.STATUS_EFFECTS.lightning_veilktouch = {
        slug: "lightning_veilktouch",
        name: "Veilktouch",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_lightning_veilktouch.gif",
        impulse: {type: "common", component: "lightning"},
        
        events: {
            onHit: function({subject, origin, attack, beneficial}) {
                if(Math.random() > 0.15 || subject == this.status.affecting || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                addStatus({target: subject, origin, status: "stun", length: 1}); 
                
                setTimeout(()=>{
                    playCombatCrit('fear')
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "VEILKTOUCH!",
                    })

                    readoutAdd({
                        message: `${origin.name} leaves ${subject.name} reeling! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },
        help: "when hitting a foe, 15% chance to inflict 1T:STUN"
    },
	
    env.ACTIONS.special_invite_storm_noadvance = {
        slug: "special_invite_storm_noadvance",
        name: "Invite Storm",
        type: 'special',
        anim: "",
        usage: {
            act: "%USER SPEAKS MADNESS"
        },
        details: {
            flavor: "'reveal a terrible truth';'mark self for death'",
            onUse: `'[STATUS::destabilized] [STATUS::vulnerable]';'HIT all foes'`,
            onHit: `'inflict one of following';'[STATUS::destabilized]';'[STATUS::fear]';'[STATUS::stun]'`,
            conditional:`<em>SPECIAL::</em>'5% chance to reduce foe HP by 75%'`
        },
        stats: {
            status: {
                destabilized: {
                    name: 'destabilized',
                    length: 2
                },
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                },
                fear: {
                    name: 'fear',
                    length: 2
                },
                stun: {
                    name: 'stun',
                    length: 1
                },
            },
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkfairy", 0.5)
            addStatus({target: user, status: "destabilized", length: 2});
            addStatus({target: user, status: "vulnerable", length: 1});

            let power = 0
            if(hasStatus(user, "fated_light")) {
                if(user?.member?.components) for (const [slotName, slotContents] of Object.entries(user.member.components)) { if(slotContents == "light") power++ }
                if(user?.member?.augments) for (const augmentSlug of user.member.augments) { let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]; if(augment?.component) if(augment.component[1] == "light") power += 2 }
            }

            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
                    let rand = Math.random()
                    if(rand < 0.3) {
                        play("talkfairy", 2)
                        addStatus({target: actor, origin: user, status: "destabilized", length: 2}); 
                        
                    } else if(rand < 0.6) {
                        play("fear", 1)
                        addStatus({target: actor, origin: user, status: "fear", length: 2}); 

                    } else {
                        play("fear", 2)
                        addStatus({target: actor, origin: user, status: "stun", length: 1}); 
                    }

                    if(Math.random() < 0.05 + (0.05 * power)) {
                        
                        sendFloater({
                            target: actor,
                            type: "arbitrary",
                            specialClass: "fate",
                            arbitraryString: "PERISH",
                            size: 2
                        })
                        
                        actor.hp = Math.floor(actor.hp * 0.25)

                        //special handling for weird hp usage
                        let conjoin = actor.statusEffects.find(status=>status.slug == "conjoined")
                        if(conjoin) conjoin.events.onCombatHit();
                        updateStats({actor})
                    }
                },
                
                advanceAfterExec: false, beingUsedAsync, user,
                endCallback: ()=>{console.log('did NOT call advance. explodes you with MIND')}
            })
        }
    },
	
	env.STATUS_EFFECTS.lightning_storm = {
		slug: "lightning_storm",
		name: "Spirestorm",
		passive: true,
		beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_lightning_spirestorm.gif",
		impulse: {type: "common", component: "lightning"},
		events: {
			onAction: function({action}) {
				if(action.slug.includes('tarot') || action.slug.includes('select') || action.slug.includes('intrusive') || Math.random() > 0.5) return
				else setTimeout(()=>{
					useAction(this.status.affecting, env.ACTIONS.special_invite_storm_noadvance, this.status.affecting, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "spirestorm"})
				}, env.ADVANCE_RATE * 0.5)
			}
		},
		help: "50% chance to use INVITE STORM when using most actions"
	},
	
	env.STATUS_EFFECTS.lightning_selfglee = {
		slug: "lightning_selfglee",
		name: "Self-Modification",
		passive: true,
		beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_lightning_self-modification.gif",
		impulse: {type: "common", component: "lightning"},
		events: {
			onTurn: function() {
				let rand = Math.random()
				if(rand < 0.25) {
					invertStatuses(this.status.affecting, (statusObj)=>!statusObj.beneficial)
					sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "MODIFIED!",
                        beneficial: true,
						size: 2
                    })
				}
			}
		},
		help: "on turn, 25% chance to invert all negative statuses"
	},
	
    env.STATUS_EFFECTS.lightning_terror = {
        slug: "lightning_terror",
        name: "Recreational Terror",
        passive: "modifier",
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_lightning_recreational_terror.gif",
        impulse: {type: "common", component: "lightning"},
        
        events: {
            onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "fear") {
					addStatus({target: target, origin: false, status: "surge", length: 1})
                    addStatus({target: target, origin: false, status: "focused", length: 2})
                    addStatus({target: target, origin: false, status: "empowered", length: 2})
                }
            },
        },
        help: "grant 2T:FOCUSED, 2T:EMPOWERED and SURGE when fear is removed"
    },
	
	env.STATUS_EFFECTS.lightning_faterender = {
        slug: "lightning_faterender",
        name: "Fate Runner",
        help: "attackers receive +1T:CURSED",
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_lightning_fate_runner.gif",
		passive: "modifier",
		beneficial: true,
		infinite: true,
		impulse: {type: "common", component: "lightning"},
        events: {
            onStruck: function({subject, attack}) {
                if(subject.state == "dead" || subject == this.status.affecting) return;
            
                sendFloater({
                    target: subject,
                    type: "arbitrary",
                    arbitraryString: "FATE RUNNER!",
                })
                
                readoutAdd({
                    message: `${subject.name} receives +1T:CURSED via <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail",
                    show: false,
                    sfx: false
                })
				play('talkfairy', 1.5)
                addStatus({target: subject, origin: false, status: "cursed", length: 1, noReact: true}); 
            },
        }
    },
	
	env.STATUS_EFFECTS.lightning_humorist = { 
        slug: "lightning_humorist",
        name: "Tragedian",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_chaos_schadenfreude.gif",
        impulse: {type: "common", component: "lightning"},
        
        events: {
            onStruck: function({subject, attack, beneficial}) {
                if(beneficial || this.status.affecting.team.members.includes(subject)) return;
                reactDialogue(origin, "laugh")
            }
        },

        help: `when struck offensively, laugh\nunknown additional effect`
    },
	
	env.STATUS_EFFECTS.heart_affliction = {
        slug: "heart_affliction",
        name: "Contact Affliction",
        help: "attackers receive +1T:PUNCTURE",
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_heart_contact_affliction.gif",
		passive: "modifier",
		beneficial: true,
		infinite: true,
		impulse: {type: "common", component: "heart"},
        events: {
            onStruck: function({subject, attack}) {
                if(subject.state == "dead" || subject == this.status.affecting) return;
            
                sendFloater({
                    target: subject,
                    type: "arbitrary",
                    arbitraryString: "AFFLICTION!",
                })
                
                readoutAdd({
                    message: `${subject.name} receives +1T:PUNCTURE via <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail",
                    show: false,
                    sfx: false
                })
				play('megastatus', 2)
                addStatus({target: subject, origin: false, status: "puncture", length: 1, noReact: true}); 
            },
        }
    },
	
	env.STATUS_EFFECTS.heart_mutual = {
		slug: "heart_mutual",
		name: "Mutual Ferocity",
		help: "when receiving a critical hit, grant +1T:TUNNEL VISION",
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_heart_mutual_ferocity.gif",
		passive: "modifier",
		beneficial: true,
		infinite: true,
		impulse: {type: "common", component: "heart"},
		events: {
			onCritStruck: function({subject, attack}) {
				setTimeout(()=>{
					sendFloater({
						target: subject,
						type: "arbitrary",
						arbitraryString: "MUTUAL FEROCITY!",
					})
					
					readoutAdd({
						message: `${this.status.affecting.name} receives +1T:TUNNEL VISION via <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>`, 
						name: "sourceless", 
						type: "sourceless combat minordetail",
						show: false,
						sfx: false
					})
					play('scarydoia', 1)
					addStatus({target: this.status.affecting, origin: false, status: "hyperfocus_flat", length: 1, noReact: true}); 
				}, env.ADVANCE_RATE * 0.2)
            },
		}
	},
	
	env.STATUS_EFFECTS.heart_desperation = {
        slug: "heart_desperation",
        name: "Relentless",
        passive: "modifier",
        beneficial: false,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_heart_relentless.gif",
		impulse: {type: "common", component: "heart"},
        events: {
            onBeforeAddStatus: function(context) {
                if(context.status == "evasion") context.status = "evasion_mega"
				if(context.status == "focused") context.status = "hyperfocus_flat"
            },
        },

        help: "evasion becomes unnatural speed, focused becomes tunnel vision"
    },
	
	env.STATUS_EFFECTS.heart_adaptive = { 
        slug: "heart_adaptive",
        name: "Evasive Maneuvers",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_heart_evasive_maneuvers.gif",
        impulse: {type: "common", component: "heart"},
        
        events: {
            onStruck: function({subject, attack, beneficial}) {
                if(beneficial || this.status.affecting.state == "dead" || subject == this.status.affecting) return;
                addStatus({target: this.status.affecting, origin: subject, status: "evasion", length: 2}); 

                setTimeout(()=>{
                    play("talklaugh", 1.25, 0.5)
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "EVADE!",
                    })
                    
                    readoutAdd({
                        message: `${this.status.affecting.name}'s stance shifts defensively in response to the attack! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "when struck offensively, gain 2T:EVASION"
    },
	
	env.STATUS_EFFECTS.heart_carapace = {
		slug: "heart_carapace",
		name: "Joyous",
		help: "when receiving a critical hit, 50% chance to grant +2T:UNNATURAL CARAPACE",
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_heart_joyous.gif",
		passive: "modifier",
		beneficial: true,
		infinite: true,
		impulse: {type: "common", component: "heart"},
		events: {
			onCritStruck: function({subject, attack}) {
				let rand = Math.random()
				if(rand > 0.5) return;
				
				setTimeout(()=>{
					sendFloater({
						target: subject,
						type: "arbitrary",
						arbitraryString: "JOYOUS TEARS!",
					})
					
					readoutAdd({
						message: `${this.status.affecting.name} receives +2T:UNNATURAL CARAPACE via <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>`, 
						name: "sourceless", 
						type: "sourceless combat minordetail",
						show: false,
						sfx: false
					})
					play('scarydoia', 0.75)
					addStatus({target: this.status.affecting, origin: false, status: "unnatural_carapace_flat", length: 2, noReact: true}); 
				}, env.ADVANCE_RATE * 0.5)
            },
		}
	},
	
	env.STATUS_EFFECTS.heart_calc = {
        slug: "heart_calc",
        name: "Overlap",
        passive: "modifier",
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/overlap.gif",
		//where we're going, we don't NEED an events property
        help: "all actors receive TELEGRAPH, COIL, and CHANNEL"
    },
	
	env.STATUS_EFFECTS.chaos_calc = {
        slug: "chaos_calc",
        name: "2ST AMENDMNT",
        passive: "modifier",
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/amendmnt.gif",
		//where we're going, we don't NEED an events property
        help: "all actors receive FULL AUTO, SIDEARM, HIP SHOT, TAKE AIM, FOCUSED SHOT, AND HOLD AIM"
    },
	
	env.STATUS_EFFECTS.chaos_discombobulate = { 
        slug: "chaos_discombobulate",
        name: "Discombobulate",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_chaos_discombobulate.gif",
        impulse: {type: "common", component: "chaos"},
        
        events: {
            onHit: function({subject, origin, attack, beneficial}) {
                if(beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                addStatus({target: subject, origin, status: "vulnerable", length: 1}); 

                setTimeout(()=>{
                    play("status", 0.75, 0.5)
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "DISCOMBOBULATE!",
                    })
                                    
                    readoutAdd({
                        message: `${this.status.affecting.name}'s strike leaves a vulnerability! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "when hitting a foe, inflict 1T:VULNERABLE"
    },
	
	env.STATUS_EFFECTS.chaos_badsport = {
        slug: "chaos_badsport",
        name: "Bad Sport",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/bad_sport.gif",
        
        events: {
            GLOBAL_onEvade: function({subject, target, attack, runEvents, originalEventTarget}) {
                let user = this.status.affecting
                if(
                    user.team.members.includes(target) || 
                    target.state == "dead" ||
                    user.state == "dead" ||
                    subject != user
                ) return;

                setTimeout(()=>{
                    addStatus({target: user, origin: user, status: "focused", length: 1}); 
					play('scarydoia')

                    sendFloater({
                        target: user,
                        type: "arbitrary",
                        arbitraryString: "BAD SPORT!",
                    })

                    readoutAdd({
                        message: `${user.name} becomes enraged as they miss! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "when missing a foe, grant +1T:FOCUSED"
    },
	
	env.STATUS_EFFECTS.chaos_adaptive = { 
        slug: "chaos_adaptive",
        name: "Retribution",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_chaos_retribution.gif",
        impulse: {type: "common", component: "chaos"},
        
        events: {
            onCritStruck: function({subject, attack, beneficial}) {
                if(beneficial || this.status.affecting.state == "dead") return;
                addStatus({target: this.status.affecting, origin: subject, status: "focused", length: 1}); 
				addStatus({target: this.status.affecting, origin: subject, status: "surge", length: 1}); 

                setTimeout(()=>{
                    play("scarydoia", 1.25, 0.5)
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "RETRIBUTION!",
                    })
                                    
                    readoutAdd({
                        message: `${this.status.affecting.name} becomes enraged as they are struck! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "when receiving a critical hit, gain 1T:FOCUSED and SURGE"
    },
	
	env.STATUS_EFFECTS.chaos_retry = {
        slug: "chaos_retry",
        name: "Retry",
        passive: true,
        beneficial: true,
        impulse: {type: "common", component: "chaos"},
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_chaos_retry.gif",
        
        events: {
            GLOBAL_onEvade: function({subject, target, attack, runEvents, originalEventTarget}) {
                let user = this.status.affecting
                if(
                    user.team.members.includes(target) || 
                    target.state == "dead" ||
                    user.state == "dead" ||
                    subject != user
                ) return;

                setTimeout(()=>{
                    addStatus({target: user, origin: user, status: "surge", length: 1}); 
					play('talkchoir7', 2, 0.5)

                    sendFloater({
                        target: user,
                        type: "arbitrary",
                        arbitraryString: "RETRY!",
                    })

                    readoutAdd({
                        message: `${user.name} becomes energized as they miss! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "when missing a foe, grant SURGE"
    },
		//OH FUCK THEY'RE NOT ETHEREAL AAAAAAAAAAAAAAAAAAAAAAA
	env.COMBAT_ACTORS.geli_summon = {
        name: "Geli",
        readoutActor: "bsteli::bstrd",
        maxhp: 15,
        hp: 15,
        actions: ["unfocused_shot", "windup_cover"],
        windupActions: ["focused_shot", "hold_aim"],
        initialStatusEffects: [["visionary_geli", 1], ["player_ethereal", 1]],
        specialClass: "bstrdactor",
        portrait: `<img class="portrait" src="[[PORTRAITURL]]">`,
        portraitUrl: '/img/sprites/obesk/geli/bsteli/combatportrait.gif',
        reactions: {
            evade: ["wow!", "aahAHaha!!"],
            crit: [ "ahaha! i GOT THEM!!" ],
            miss: ["oh NO!!", "WASTED BULLET", "WILL GET NEXT 1!"],
            dead: ["i CANT MOVE"],
            receive_hit: ["OW"],
            receive_crit: ["WHY DOES IT HURT SO BAD", ">:("],
            receive_puncture: ["WHY DOES IT HURT SO BAD"],
            receive_buff: ["}:^)"],
            receive_destabilized: ["WAKING UP AGAIN", "MEGA BULLET!!"],
            receive_rez: ["NICE 1"],
            puncture: [":("],
            regen: ["doing GOOD", "ahahaAhaha!!"],
            destabilized: ["WATCH THIS"],
            stun: ["uu382*((U*#*( U("],
            receive_fear: [":O", "O_O"],
        }
    },
	
	env.COMBAT_ACTORS.efgy_summon = {
        name: "EFGY",
        readoutActor: "bstigy",
        maxhp: 20,
        hp: 20,
        actions: [
            "special_fullauto",
            "surge"
        ],
        specialClass: "bstrdactor",
        initialStatusEffects: [["impatient", 1], ["player_ethereal", 1]],
        portrait: `<img class="portrait" src="[[PORTRAITURL]]">`,
        portraitUrl: '/img/local/uncosm/ozo/akieffigy_portrait_bstrd_nobg.gif',
        reactions: {
            evade: ["O)", "COOL BREEZE!! YAY!!"],
            crit: [ "ISABEL LOOK!!", "BLAMM~!", "YAYAYAYA"],
            miss: ["wat!! geli how do i hit them", "ok i try again?", "can i redo my turn"],
            dead: ["waaa!! nooo!"],
            receive_crit: ["mny PETALS!!"],
            receive_puncture: ["i dont like this part", "buncgture"],
            receive_buff: ["OK I SHOOT BIG NEXT??"],
            puncture: ["oww wowawaoww"],
            regen: ["eheheeeaaahahaha", "okk!!! yes"],
            stun: ["the dream is broken!! help!"],
            receive_fear: ["O"],
            receive_destabilized: ["WOaoOAw"],
            receive_rez: ["Ã¿Ã¦Ã¿"],
            puncture: ["OOUUEU"],
            destabilized: ["DOUBLE BULLETS !!"],
        }
    },
	
	env.STATUS_EFFECTS.chaos_backup = {
		slug: "chaos_backup",
		name: "Reinforcements",
		passive: true,
		beneficial: true,
		impulse: {type: "common", component: "chaos"},
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_chaos_backup.gif",
		
		events: {
			onDeath: function() {
				if(this.status.affecting.team.name.includes("enemyTeam")) {
					let user = this.status.affecting
					let newAlly
					if(Math.random() > 0.75) {
						if(this.status.lastSide) {
							midCombatAllyAdd('efgy_summon', 'left')
							play('talkflower', 1.25)
							this.status.lastSide = 0
							//newAlly = EFGY
						} else {
							midCombatAllyAdd('efgy_summon', 'right')
							play('talkflower', 1.25)
							this.status.lastSide = 1
							//newAlly = EFGY
						}
					} else {
						if(this.status.lastSide) {
							midCombatAllyAdd('geli_summon', 'left')
							play('talkgel', 0.75)
							this.status.lastSide = 0
							//newAlly = GELI
						} else {
							midCombatAllyAdd('geli_summon', 'right')
							play('talkgel', 0.75)
							this.status.lastSide = 1
							//newAlly = GELI
						}
					}
					sendFloater({
						target: user,
						type: "arbitrary",
						arbitraryString: "REINFORCEMENTS!",
						size: 1.5,
					})
					readoutAdd({
						message: `a familiar face joins the fight as ${user.name} falls! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
						name: "sourceless", 
						type: "sourceless combat minordetail", 
						show: false,
						sfx: false
					})
					setTimeout(()=>{
						removeStatus(this.status.affecting, 'chaos_backup', {forceRemoveStatus: true})
					}, env.ADVANCE_RATE * 0.2)
				}
			},
		},
		help: "on death, call for backup\nusable once per combat"
	},
	
	env.STATUS_EFFECTS.chaos_infection = { 
        slug: "chaos_infection",
        name: "Insult to Injury",
        passive: "modifier",
        beneficial: false,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_chaos_insult_to_injury.gif",
        impulse: {type: "common", component: "chaos"},
        
        events: {
            GLOBAL_onBeforeCombatHit: function(context) {
                if(context.origin == this.status.affecting) {
                    let vulnCount = hasStatus(context.originalEventTarget, "vulnerable")

                    if(context.amt > 0 && vulnCount && !context.beneficial) {
                        this.status.outgoingMult = 0.2 * vulnCount
                    } else {
                        this.status.outgoingMult = 0
                    }
                }

                updateStats({actor: this.status.affecting})
            },
        },

        help: `+20% damage per T:VULNERABLE of attacked target`
    },
	
	env.STATUS_EFFECTS.chaos_humorist = { 
        slug: "chaos_humorist",
        name: "Schadenfreude",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_chaos_schadenfreude.gif",
        impulse: {type: "common", component: "chaos"},
        
        events: {
            onCrit: function({subject, origin, attack, beneficial}) {
                if(beneficial || origin.team.members.includes(subject)) return;
                reactDialogue(origin, "laugh")
            }
        },

        help: `when critting a foe, laugh\nunknown additional effect`
    },
	
	env.STATUS_EFFECTS.order_power = { 
        slug: "order_power",
        name: "Power Creep",
		outgoingFlat: 2,
		outgoingToHit: 2,
		outgoingCrit: 2,
		outgoingFlatCrit: 0.05,
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_order%20power%20creep.gif",
        
        events: {
            onCreated: function({statusObj}) {
                if(statusObj.slug == this.status.slug) {
					let myMaxHp = this.status.affecting.maxhp
					let myHp = this.status.affecting.hp
					delete this.status.affecting.maxhp
					delete this.status.affecting.hp
					this.status.affecting.maxhp = Math.floor(myMaxHp * 2.5)
					this.status.affecting.hp = Math.floor(myHp * 2.5)
					updateStats(this.status.affecting)
                }
            }
        },

        help: "+2 base damage, +5% base crit rate (ie:before bonuses), +200% outgoing hit%, crit%, +150% max hp (rounded down)"
    },
	
	env.STATUS_EFFECTS.order_item = { 
        slug: "order_item",
        name: "Item Carrier",
        passive: true,
        beneficial: true,
		possibleItems: ['disabler_pulse', 'restore', 'special_spy_all', 'special_attack_all', 'special_strong_barrier_allies', 'daze_good', 'disabler_pulse', 'restore', 'special_spy_all', 'special_attack_all', 'special_strong_barrier_allies', 'daze_good', 'special_malware_drill', 'special_malware_rot', 'special_malware_rewrite', 'special_malware_empower'],
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_order%20item%20holder.gif",
        
        events: {
            onCreated: function({statusObj}) {
                if(statusObj.slug == this.status.slug) {
					let user = this.status.affecting
					let newItem = this.status.possibleItems.sample()
					let newAction = env.ACTIONS[newItem]
					user.actions.push(newItem)
					setTimeout(()=>{
						sendFloater({
							target: this.status.affecting,
							type: "arbitrary",
							arbitraryString: `CARRYING::${newAction.name.toUpperCase()}`,
							size: 1.5,
						})
					}, env.ADVANCE_RATE)
                }
            }
        },

        help: "all actors receive one item action\nitem action is not consumed on use"
    },
	
	env.STATUS_EFFECTS.order_backdoor = { 
        slug: "order_backdoor",
        name: "Backdoor Vulnerability",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_order%20backdoor%20alt.gif",
        impulse: {type: "common", component: "order"},
        
        events: {
            onCrit: function({subject, origin, attack, beneficial}) {
                if(Math.random() < 0.75 || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                setTimeout(()=>{
					addStatus({target: subject, origin, status: "vulnerable", length: 3}); // addStatus calls included in the timeout so the initial crit doesn't trigger critical flaw
					addStatus({target: subject, origin, status: "critical_flaw", length: 1}); 
                    play("status", 0.75, 1)
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "BACKDOOR!",
                    })
                    
                    readoutAdd({
                        message: `${this.status.affecting.name}'s strike leaves an extra vulnerability! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.3)
            }
        },

        help: "when critting a foe, 25% chance to inflict 3T:VULNERABLE and CRITICAL FLAW"
    },
	
	env.STATUS_EFFECTS.order_zeroday = {
        slug: "order_zeroday",
        name: "Zero-Day",
        help: "when receiving a critical hit, inflict 1T:STUN on attacker",
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_order%20zero%20day.gif",
		passive: "modifier",
		beneficial: true,
		infinite: true,
		impulse: {type: "common", component: "order"},
        events: {
            onCritStruck: function({subject, attack}) {
                if(subject.state == "dead" || subject == this.status.affecting) return;
            
                sendFloater({
                    target: subject,
                    type: "arbitrary",
                    arbitraryString: "ZERO-DAY!",
                })
                
                readoutAdd({
                    message: `${subject.name} receives +1T:STUN via <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail",
                    show: false,
                    sfx: false
                })
				play('fear', 1)
                addStatus({target: subject, origin: false, status: "stun", length: 1, noReact: true}); 
            },
        }
    },
	
	env.STATUS_EFFECTS.order_imp = {
        slug: "order_imp",
        name: "Impetus",
        passive: true,
        beneficial: true,
        impulse: {type: "common", component: "order"},
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_order%20impetus.gif",
        
        events: {
            GLOBAL_onAction: function({target, user, hit, action, beingUsedAsync, reason, actionSettings, originalEventTarget}) {
				let newAction = env.ACTIONS['nothing'] // we probably don't need to make it 'nothing' by default but i don't think it'll cause any issues
                if(
                    hit != "crit" ||
                    this.status.affecting.state == "dead" || 
                    user == this.status.affecting || 
                    target !== this.status.affecting ||
					action.beneficial == "true" ||
					action.type.includes("support") ||
					this.status.affecting.team.members.includes(user) ||
                    target.state == "dead" ||
                    reason != false
                ) return;
				let stolenAction = actionSettings.action.slug
                newAction = env.ACTIONS[stolenAction]
				if(this.status.affecting.team.name == "ally" && this.status.affecting.actions.includes(stolenAction)) return // ally action piling safeguard
				else this.status.affecting.actions.push(stolenAction) // we let enemies collect multiple of the same action for the funny

                setTimeout(()=>{
					play('talkcroak', 1)
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: `IMPETUS::${newAction.name.toUpperCase()}`,
                        size: 1.5,
                    })
                
                    readoutAdd({
                        message: `${this.status.affecting.name} steals ${newAction.name} from ${user.name}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.5)
            }
        },

        help: "when receiving a critical hit, steal the attack for the duration of combat\nenemies can receive duplicate actions\nactions requiring certain statuses will not require said statuses"
    },
		// thing to make fated::order work properly
	env.STATUS_EFFECTS.order_detector = {
        slug: "order_detector",
        name: "Modified",
        passive: true,
        beneficial: true,
		silent: true,
        icon: "/img/sprites/combat/passives/light_glee.gif",
        help: "this actor has already received impulses\nyou should never see this"
    }

if(check("cmb_unlocked")) {
	env.STATUS_EFFECTS.cmb_attackdrone_shell = { 
        slug: "cmb_attackdrone_shell",
        name: "Battle Drone",
        passive: true,
        beneficial: true,
        impulse: {type: "common", component: "cmb"},
        icon: "/img/sprites/combat/augs/drone.gif",
        
        events: {
            onTurn: function() {
                let user = this.status.affecting
                let shownNotice = false
                env.recentSfx = false

                env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i) => {
                        if(hasStatus(actor, "vulnerable")) {
                            env.GENERIC_ACTIONS.singleTarget({
                                action: env.ACTIONS['drone_strike_cmb'], 
                                user, 
                                target: actor,
                                hitSfx: { name: 'dull', rate: 1, volume: 0.5 },
                                critSfx: { name: 'dull', rate: 1, volume: 0.5 },
                                genExec: ()=>{
                                    if(!shownNotice) {
                                        sendFloater({
                                            target: user,
                                            type: "arbitrary",
                                            arbitraryString: "DISCHARGE!",
                                        })

                                        readoutAdd({
                                            message: `${user.name}'s <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span> pierces all vulnerable foes`, 
                                            name: "sourceless", 
                                            type: "sourceless combat minordetail", 
                                            show: false,
                                            sfx: false
                                        })

                                        shownNotice = true
                                    }
                                }
                            })
                        }
                    }
                })
            },
        },

        help: `if alive, attack all vulnerable foes on turn for -2HP`
    },
	
	env.STATUS_EFFECTS.cmb_desperation = { 
        slug: "cmb_desperation",
        name: "Ripcord",
        passive: "modifier",
        beneficial: false,
        icon: "/img/sprites/combat/passives/claws_desperation.gif",
        impulse: {type: "common", component: "cmb"},
        
        events: {
            onTurn: function() {
                if(this.status.affecting.hp <= (this.status.affecting.maxhp / 2)) {
                    this.status.incomingCrit = -0.5
                    this.status.incomingToHit = -0.5
                } else {
                    this.status.incomingCrit = 0
                    this.status.incomingToHit = 0
                }

                updateStats({actor: this.status.affecting})
            },
        },

        help: `-50% incoming hit and crit chance if HP < 50%`
    }, 
	
	env.STATUS_EFFECTS.cmb_veilkdrop = { 
        slug: "cmb_veilkdrop",
        name: "Veilkmark",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_pain_terror.gif",
        impulse: {type: "common", component: "cmb"},
        
        events: {
            onCrit: function({subject, origin, attack, beneficial}) {
                if(Math.random() > 0.25 || subject == this.status.affecting || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                addStatus({target: subject, origin, status: "vulnerable_mega", length: 3}); 
                
                setTimeout(()=>{
                    play('megastatus', 0.75)
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "VEILKMARK!",
                    })
                                    
                    readoutAdd({
                        message: `${origin.name} leaves ${subject.name} with an extra vulnerability! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "when critting a foe, 25% chance to inflict 3T:HYPERVULNERABLE"
    },
	
	env.STATUS_EFFECTS.cmb_firebrand = { 
        slug: "cmb_firebrand",
        name: "Firebrand",
        passive: true,
        beneficial: true,
        icon: "/img/sprites/combat/passives/chitin.gif",
        impulse: {type: "common", component: "cmb"},
        
        events: {
            onHit: function({subject, origin, attack, beneficial}) {
                if(beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                addStatus({target: subject, origin, status: "burning", length: 1}); 

                setTimeout(()=>{
                    play("dull", 1.5, 0.5)
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "FIREBRAND!",
                    })
                                    
                    readoutAdd({
                        message: `${this.status.affecting.name}'s strike leaves an extra wound! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            },
			onCrit: function({subject, origin, attack, beneficial}) {
                if(beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                addStatus({target: subject, origin, status: "burning", length: 1}); 

                setTimeout(()=>{
                    play("dull", 1.25, 0.5)
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "FIREBRAND!",
                    })
                }, env.ADVANCE_RATE * 0.4)
            }
        },

        help: "when hitting a foe, inflict 1T:CHEMICAL FIRE\nadditional 1T:CHEMICAL FIRE when critting a foe"
    },
	
	env.STATUS_EFFECTS.cmb_response = { 
        slug: "cmb_response",
        name: "Full Response",
        passive: "modifier",
        beneficial: true,
        impulse: {type: "common", component: "cmb"},
        icon: "/img/sprites/combat/passives/ichor_strength.gif",
        
        events: {
            onTurn: function() {
                if(this.status.affecting.hp >= this.status.affecting.maxhp * 0.75) {
					this.status.outgoingToHit = 2
					this.status.outgoingCrit = 2
				}
                else {
					this.status.outgoingToHit = 0
					this.status.outgoingCrit = 0
				}
            },
        },

        help: "+200% outgoing hit%, crit% at >75% HP"
    }
}

	env.STATUS_EFFECTS.cmb_calc = {
		slug: "cmb_calc",
		name: "UXO",
		passive: "modifier",
		beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_metal_volatile.gif",
		//where we're going, we don't NEED an events property
		help: "all actors receive IED, BAZRUKA, and IID"
	},
	
	env.STATUS_EFFECTS.zuka_grail = { // WHITE VEILK. HOLY GRAIL.
        slug: "zuka_grail",
        name: "Holy Grail",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_metal_volatile.gif",
        
        events: {
            onCreated: function({statusObj}) {
                if(statusObj == this.status) {
                    this.status.affecting.revivedByZuka = false
                }
            },        

            onDeath: function() {
                if(this.status.affecting.state == "dead" && this.status.affecting.revivedByZuka == false && !hasStatus(this.status.affecting, "ethereal")) {
					combatRevive(this.status.affecting)
					this.status.affecting.hp = this.status.affecting.maxhp
					setTimeout(()=>{
						this.status.affecting.revivedByZuka = true
						this.status.affecting.state = "living"
						
						readoutAdd({
							message: `${this.status.affecting.name} refuses to die! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
							name: "sourceless", 
							type: "sourceless combat minordetail", 
							show: false,
							sfx: false
						})
						sendFloater({
							target: this.status.affecting,
							type: "arbitrary",
							arbitraryString: "HOLY GRAIL!",
							size: 2,
						})
						play('scarydoia', 0.5)
					}, env.ADVANCE_RATE * 0.1)
                    updateStats({actor: this.status.affecting})
                }
            }, 
        },

        help: "all actors may self-revive with full HP once per combat"
    },
	
	env.STATUS_EFFECTS.zuka_intimidation = {
        slug: "zuka_intimidation",
        name: "Intimidation",
        help: "attackers receive +1T:FEAR",
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_pain_terror.gif",
		passive: "modifier",
		beneficial: true,
		infinite: true,
		impulse: {type: "common", component: "zuka"},
        events: {
            onStruck: function({subject, attack}) {
                if(subject.state == "dead" || subject == this.status.affecting) return;
            
                sendFloater({
                    target: subject,
                    type: "arbitrary",
                    arbitraryString: "INTIMIDATION!",
                })
                
                readoutAdd({
                    message: `${subject.name} receives +1T:FEAR via <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail",
                    show: false,
                    sfx: false
                })
				play('fear', 1.5)
                addStatus({target: subject, origin: false, status: "fear", length: 1, noReact: true}); 
            },
        }
    },
	
	env.STATUS_EFFECTS.zuka_unstoppable = {
		slug: "zuka_unstoppable",
		name: "Unstoppable",
		passive: true,
		beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_pain_thrillseeker.gif",
		impulse: {type: "common", component: "zuka"},
		
		events: {
			onTurn: function() {
				if(this.status.affecting.hp > (this.status.affecting.maxhp * 0.75)) {
						if(!this.status.affecting.minotaursMazeContingencyPlan) {
							if(!this.status.affecting.statusImmunities) {
								this.status.affecting.statusImmunities = ["stun"]; //the game will shit itself if you add an immunity to someone who doesnt have them defined, so we define them here if they dont have any
								this.status.affecting.minotaursMazeContingencyPlan = true //surprise tool that will help us later
							} else if(!this.status.affecting.statusImmunities.includes("stun")) { //if they arent already immune to stun, makes them
								this.status.affecting.statusImmunities.push("stun")
								this.status.affecting.minotaursMazeContingencyPlan = true
							}
						}
				} else { //i know you can use an elif here but i'm too lost in a minotaurs maze of my own making
					if(this.status.affecting.minotaursMazeContingencyPlan) {//ok what the fuck is this
						this.status.affecting.statusImmunities.pop() 
						this.status.affecting.minotaursMazeContingencyPlan = false
					}
				}
				updateStats({actor: this.status.affecting})
			}
		},

		help: "stun immunity at >75% HP"
	},
	
	env.STATUS_EFFECTS.zuka_finisher = {
        slug: "zuka_finisher",
        name: "Accelerant",
        passive: true,
        beneficial: true,
        impulse: {type: "common", component: "zuka"},
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_lightning_recreational_terror.gif",
        
        events: {
            GLOBAL_onDeath: function({originalEventTarget}) {
                if(
                    this.status.affecting.state == "dead" ||
                    this.status.affecting.team.name == originalEventTarget.team.name
                ) return;
                    
                sendFloater({
                    target: this.status.affecting,
                    type: "arbitrary",
                    arbitraryString: "ACCELERATE!",
                })

                readoutAdd({
                    message: `${this.status.affecting.name} gets energized as their foe falls! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail", 
                    show: false,
                    sfx: false
                })
				addStatus({target: this.status.affecting, origin: false, status: "surge", length: 1})
                addStatus({target: this.status.affecting, origin: false, status: "focused", length: 1})                
            }
        },

        help: "on foe down, receive +1T:FOCUSED and +SURGE"
    },
	
	env.STATUS_EFFECTS.zuka_ind = {
        slug: "zuka_ind",
        name: "M.A.D.",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_order%20impetus.gif",
        
        events: {
            GLOBAL_onAction: function({target, user, hit, action, beingUsedAsync, reason, actionSettings, originalEventTarget}) {
				let newAction = "cavik_attack_mega"
                if(
                    hit != "crit" ||
                    this.status.affecting.state == "dead" || 
                    user == this.status.affecting || 
                    target !== this.status.affecting ||
					action.beneficial == "true" ||
					action.type.includes("support") ||
					this.status.affecting.team.members.includes(user) ||
                    target.state == "dead" ||
                    reason != false
                ) return;
				if(this.status.affecting.team.name == "ally" && this.status.affecting.actions.includes(newAction)) return // ally action piling safeguard
				else this.status.affecting.actions.push(newAction) // we let enemies collect multiple of the same action for the funny

                setTimeout(()=>{
					play('scarydoia', 1)
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: `MUTUALLY ASSURED!`,
                        size: 1.5,
                    })
                
                    readoutAdd({
                        message: `${this.status.affecting.name} gains a powerful weapon! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.5)
            }
        },

        help: "when receiving a critical hit, receive IND as a non-windup action\nenemies can receive duplicate actions"
    },
	
	env.STATUS_EFFECTS.zuka_iconoclasm = {
		slug: "zuka_iconoclasm",
		name: "Iconoclasm",
		passive: true,
		beneficial: true,
		impulse: {type: "common", component: "zuka"},
		icon: "/img/sprites/combat/passives/ichor_finisher.gif",
		
		events: {
			onDeath: function() {
				let user = this.status.affecting
				let healAmt = -1 * Math.ceil(user.maxhp / 2)
				
				env.GENERIC_ACTIONS.teamWave({
					team: user.team,
					exec: (actor, i)=>{
						combatHit(actor, {amt: healAmt, origin: user, autohit: true, beneficial: true});
						play('mend')
					}
				})
				
				sendFloater({
					target: user,
					type: "arbitrary",
					arbitraryString: "ICONOCLASM!",
					size: 1.5,
				})
			
				readoutAdd({
					message: `${user.name} heals their allies before they fall! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
					name: "sourceless", 
					type: "sourceless combat minordetail", 
					show: false,
					sfx: false
				})
			},
		},
		help: "on death, heal allies for 50% max HP, rounded up"
	},
	
	env.STATUS_EFFECTS.hook_finisher = {
        slug: "hook_finisher",
        name: "Prosthesis",
        passive: true,
        beneficial: true,
        impulse: {type: "common", component: "hook"},
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_metal_responsive_armor.gif",
        
        events: {
            GLOBAL_onDeath: function({originalEventTarget}) {
                if(
                    this.status.affecting.state == "dead" ||
                    this.status.affecting.team.name == originalEventTarget.team.name
                ) return;
                    
                sendFloater({
                    target: this.status.affecting,
                    type: "arbitrary",
                    arbitraryString: "PROSTHESIS!",
                })

                readoutAdd({
                    message: `${this.status.affecting.name} makes a prosthetic of ${originalEventTarget.name}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail",
                    show: false,
                    sfx: false
                })
				addStatus({target: this.status.affecting, origin: this.status.affecting, status: "carapace", length: 3})
                addStatus({target: this.status.affecting, origin: this.status.affecting, status: "spikes", length: 3})                
            }
        },

        help: "on foe down, receive +3T:CARAPACE and +3T:SPIKES"
    },
	
	env.STATUS_EFFECTS.hook_barbs = {
        slug: "hook_barbs",
        name: "Barbed Carapace",
        help: "attackers receive +2T:OPEN WOUND",
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_lightning_veilktouch.gif",
		passive: "modifier",
		beneficial: true,
		infinite: true,
		impulse: {type: "common", component: "hook"},
        events: {
            onStruck: function({subject, attack}) {
                if(subject.state == "dead" || subject == this.status.affecting) return;
            
                sendFloater({
                    target: subject,
                    type: "arbitrary",
                    arbitraryString: "BARBS!",
                })
                
                readoutAdd({
                    message: `${subject.name} receives +2T:OPEN WOUND via <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail",
                    show: false,
                    sfx: false
                })
				play('stab', 1)
                addStatus({target: subject, origin: false, status: "open_wound", length: 2, noReact: true}); 
            },
        }
    },
	
	env.STATUS_EFFECTS.hook_veilkripper = {
        slug: "hook_veilkripper",
        name: "Veilkripper",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_spirestone_berserk.gif",
        impulse: {type: "common", component: "hook"},
        
        events: {
            onCrit: function({subject, origin, attack, beneficial}) {
                if(Math.random() > 0.25 || subject == this.status.affecting || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                addStatus({target: subject, origin, status: "agony", length: 1}); 
                
                setTimeout(()=>{
                    playCombatCrit('stab', 0.5)
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "VEILKRIPPER!",
                    })

                    readoutAdd({
                        message: `${origin.name}'s strike leaves ${subject.name} in agony! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },
        help: "when critting a foe, 25% chance to inflict AGONY"
    },
	
	env.STATUS_EFFECTS.hook_playwright = {
		slug: "hook_playwright",
		name: "Playwright",
		passive: true,
		beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_lightning_recreational_terror.gif",
		impulse: {type: "common", component: "hook"},
		
		events: {
			onTurn: function() {
				if(this.status.affecting.hp <= (this.status.affecting.maxhp / 4)) {
					invertStatuses(this.status.affecting, (statusObj)=>!statusObj.beneficial)
				}
				updateStats({actor: this.status.affecting})
			},
		},

		help: "invert all negative status effects when HP < 25%"
	},
	
	env.STATUS_EFFECTS.hook_keepers = {
        slug: "hook_keepers",
        name: "Finder's Keepers",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_lightning_spirestorm.gif",
        
        events: {
            onCrit: function({subject, origin, attack, beneficial}) {
                if(subject == this.status.affecting || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                let statusExceptions = ['conjoined', 'conjoined_baseslug', 'windup', 'windup_telegraph_flat', 'winderup', 'windestup', 'final_windup', 'windup_aim', 'coiling_flat']
				if(this.status.affecting.windupActions) statusExceptions = ['conjoined', 'conjoined_baseslug', 'windup_telegraph_flat', 'winderup', 'windestup', 'final_windup', 'windup_aim', 'coiling_flat']
				if(this.status.affecting.windupActions && hasStatus(this.status.affecting, 'heart_calc')) statusExceptions = ['conjoined', 'conjoined_baseslug', 'winderup', 'windestup', 'final_windup', 'windup_aim', 'coiling_flat']
                for(let status of Object.values(env.STATUS_EFFECTS)) {
					if(status['beneficial'] && !status['passive']) { // only get beneficial statuses, don't iterate through impulses
						let newStatus = status.slug
						if(hasStatus(subject, newStatus) && !statusExceptions.includes(newStatus)) { // this SHOULD work. probably
							let newStatusLength = Math.floor(hasStatus(subject, newStatus))
							if(newStatus.includes("redirection")) addStatus({target: this.status.affecting, origin: subject, status: newStatus, length: newStatusLength})
							else addStatus({target: this.status.affecting, origin: this.status.affecting, status: newStatus, length: newStatusLength})
							removeStatus(subject, newStatus)
						}
					}
				}
				
				setTimeout(()=>{
                    playCombatCrit('talkfairy', 0.75)
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "STOLEN!",
                    })

                    readoutAdd({
                        message: `${origin.name} grasps beyond ${subject.name}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },
        help: "when critting a foe, remove target's beneficial statuses and reapply to user"
    },
	
	env.STATUS_EFFECTS.hook_calc = {
        slug: "hook_calc",
        name: "Maximum Incoherence",
        passive: "modifier",
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_order%20item%20holder.gif",
		//where we're going, we don't NEED an events property
        help: "all actors receive INVERSION"
    },
	
	env.STATUS_EFFECTS.spine_veilkfall = {
        slug: "spine_veilkfall",
        name: "Veilkfall",
        passive: true,
        beneficial: true,
        icon: "/img/sprites/combat/passives/veilkdrop.gif",
        impulse: {type: "common", component: "spine"},
        
        events: {
            onCrit: function({subject, origin, attack, beneficial}) {
                if(Math.random() < 0.25 || subject == this.status.affecting || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                addStatus({target: this.status.affecting, origin, status: "regen", length: 2});
				combatHit(this.status.affecting, {amt: -2, origin: this.status.affecting, autohit: true, beneficial: true})
                setTimeout(()=>{
                    playCombatCrit("mend")

                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "VEILKFALL!",
                    })

                    readoutAdd({
                        message: `${origin.name}'s strike heals their wounds! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },
        help: "when critting a foe, 25% chance to grant +2HP +2T:REGEN"
    },
	
	env.STATUS_EFFECTS.spine_valika = {
        slug: "spine_valika",
        name: "Valika",
        help: "attackers receive +2T:VULNERABLE",
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/fight_or_flight.gif",
		passive: "modifier",
		beneficial: true,
		infinite: true,
		passive: true,
		impulse: {type: "common", component: "spine"},
        events: {
            onStruck: function({subject, attack}) {
                if(subject.state == "dead") return;
				if(subject == this.status.affecting) return;
            
                sendFloater({
                    target: subject,
                    type: "arbitrary",
                    arbitraryString: "VALIKA!",
                })
                let user = this.status.affecting
                readoutAdd({
                    message: `${subject.name} receives +2T:VULNERABLE via ${user.name}'s <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail",
                    show: false,
                    sfx: false
                })
				play("status", 0.75)
                addStatus({target: subject, origin: false, status: "vulnerable", length: 2, noReact: true}); 
            },
        }
    },
	
	env.STATUS_EFFECTS.spine_contingency = {
        slug: "spine_contingency",
        name: "Ukazni Contingency",
        help: "when receiving a critical hit, grant +1T:UNNATURAL SPEED",
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_heart_evasive_maneuvers.gif",
		passive: "modifier",
		beneficial: true,
		infinite: true,
		impulse: {type: "common", component: "spine"},
        events: {
            onCritStruck: function({subject, attack}) {
                if(subject.state == "dead" || subject == this.status.affecting) return;
            
                sendFloater({
                    target: this.status.affecting,
                    type: "arbitrary",
                    arbitraryString: "CONTINGENCY!",
                })
                
                readoutAdd({
                    message: `${subject.name} receives +1T:UNNATURAL SPEED via <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail",
                    show: false,
                    sfx: false
                })
				play('talkfairy', 1)
                addStatus({target: this.status.affecting, origin: false, status: "evasion_mega", length: 1, noReact: true}); 
            },
        }
    },
	
	env.STATUS_EFFECTS.spine_dissociated = {
        slug: "spine_dissociated",
        name: "Dissociated",
        passive: "modifier",
        beneficial: false,
        icon: "/img/sprites/combat/passives/light_dark.gif",
        events: {
            onAddStatus: function({target, statusObj}) {
                if(statusObj.slug == "fear") {
                    this.status.incomingMult = -0.5
                    updateStats({actor: this.status.affecting})
                }
            },

            onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "fear") {
                    this.status.outgoingMult = 0
                    updateStats({actor: this.status.affecting})
                }
            },
            onCrit: function({subject, origin, attack, beneficial}) {
                if(beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                addStatus({target: subject, origin, status: "fear", length: 1});
                setTimeout(()=>{
                    play("fear", 0.75, 0.5)
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "DISSOCIATED!",
                    })
                    readoutAdd({
                        message: `${this.status.affecting.name}'s strike terrifies ${subject.name}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },
        help: `gain -50% outgoing damage/heal when afflicted by FEAR\nwhen critting a foe, inflict 1T:FEAR`
    },
	
	env.STATUS_EFFECTS.spine_panacea = {
        slug: "spine_panacea",
        name: "Panacea",
        passive: true,
        beneficial: true,
        icon: "/img/sprites/combat/passives/claws_infection.gif",
        impulse: {type: "common", component: "spine"},
        events: {
            GLOBAL_onBeforeCombatHit: function(context) {
                if(context.origin == this.status.affecting) {
                    let regenCount = hasStatus(this.status.affecting, "regen")

                    if(context.amt > 0 && regenCount) {
                        this.status.outgoingMult = 0.2 * regenCount
                    } else {
                        this.status.outgoingMult = 0
                    }
                }

                updateStats({actor: this.status.affecting})
            },
        },
        help: `+20% outgoing damage/healing per T:REGEN of self`
    },
	
	env.STATUS_EFFECTS.spine_drone = {
        slug: "spine_drone",
        name: "Kind Light",
        passive: true,
        beneficial: true,
        impulse: {type: "common", component: "spine"},
        icon: "/img/sprites/combat/augs/drone.gif",
        events: {
            onTurn: function() {
                let user = this.status.affecting
                let shownNotice = false
                env.recentSfx = false
                env.GENERIC_ACTIONS.teamWave({
                    team: user.team,
                    exec: (actor, i) => {
                        if(hasStatus(actor, "puncture")) {
                            env.GENERIC_ACTIONS.singleTarget({
                                action: env.ACTIONS['spine_kindlight'],
                                user,
                                target: actor,
                                hitSfx: { name: 'mend', rate: 1.5, volume: 0.5 },
                                critSfx: { name: 'mend', rate: 1.5, volume: 0.5 },
								hitStatus: { // grumble grumble i have to do everything myself around here grumble grumble grumble
									name: 'regen',
									length: 1
								},
                                genExec: ()=>{
                                    if(!shownNotice) {
                                        sendFloater({
                                            target: user,
                                            type: "arbitrary",
                                            arbitraryString: "KIND LIGHT!",
                                        })

                                        readoutAdd({
                                            message: `${user.name}'s <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span> heals their wounded allies`, 
                                            name: "sourceless", 
                                            type: "sourceless combat minordetail", 
                                            show: false,
                                            sfx: false
                                        })

                                        shownNotice = true
                                    }
                                }
                            })
                        }
                    }
                })
            },
        },
        help: `if alive, heal all punctured allies on turn for +1HP +1T:REGEN`
    },
	
	env.ACTIONS.spine_kindlight = {
        slug: "spine_kindlight",
        name: "Quick Mend",
        type: 'support+target+self',
        anim: "heal",
        beneficial: true,
        usage: {
            act: "%USER FIXES UP %TARGET",
            crit: "%TARGET FEELS WAY BETTER",
            hit: "%TARGET FEELS BETTER",
            miss: "%TARGET IS TOO SLIPPERY"
        },
        details: {
            onHit: `'[STAT::amt] [STATUS::regen]'`,
        },
        stats: {
            range: 2,
            crit: 0.1,
            autohit: true,
            amt: -1,
            status: {
                regen: {
                    name: 'regen',
                    length: 3
                }
            }
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                beneficial: true,
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'mend',
                    rate: 1.5
                },
                hitStatus: { // it's literally RIGHT THERE !!!!!!!!!!!!!!!! just USE IT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! STUPID !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                    name: 'regen',
                    length: 1
                },
            })
        },
        // enemy zone
        avoidChaining: true,
        enemyUsageIf: (actor) => { // only use if someone alive on team has taken damage
            return actor.team.members.some(member => member.state != "dead" && (member.hp < member.maxhp))
        },
        disableIf: (actor) => {
            return (
                actor.team.name == "enemy" &&
                !actor.team.members.some(member => ((member != actor) && (member.state != "dead") ))
            )
        },
    },
	
	env.STATUS_EFFECTS.spine_heavenbound = {
        slug: "spine_heavenbound",
        name: "Heavenbound",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_hands_faustian_pact.gif",
        impulse: {type: "common", component: "spine"},
        events: {
            onCrit: function({subject, origin, attack, beneficial}) {
				let user = this.status.affecting
				let target = this.status.affecting
				let rand = Math.random()
                if( (rand < 0.90) || subject == this.status.affecting || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead" || (user.team.members.filter(m=>m.slug.includes('fodder')).length < 4)) return;
                
                setTimeout(()=>{
					if(user.team.members.filter(m=>m.slug.includes('fodder')).length < 4) {
						playCombatCrit('dull', 0.5);

						let angel_peasant = ["spine_fodder"]
						let angel_royal = ["angel_pawn", "angel_knight", "angel_bishop", "angel_rook", "angel_queen", "angel_king"]
						let angel_divine /* heh */ = ["angelGreater_pawn", "angelGreater_knight", "angelGreater_bishop", "angelGreater_rook", "angelGreater_queen", "angelGreater_king"]
						
						var newAllySlug = angel_peasant.sample()
						var newAllySlug1 = angel_royal.sample()
						var newAllySlug2 = angel_divine.sample()

						//try to center the dude
						if(user.team.members.length == 14) { // oh god why did we do it like this it sucks so much
							let uI = user.team.members.findIndex(a => a.slug == user.slug)
							if(uI < 3) midCombatAllyAdd('spine_fodder', 'left')
							else if(uI >= 3) midCombatAllyAdd('spine_fodder', 'right')	
						} else {
							let rand = Math.random()
							if (rand > 0.5) {
								let rand1 = Math.random()
								if (rand1 < 0.7) {
									midCombatAllyAdd(newAllySlug,'left')
								}
								else if (rand1 < 0.95) {
									midCombatAllyAdd(newAllySlug1,'left')	
								}
								else {
									midCombatAllyAdd(newAllySlug2,'left')	
								}
							}
							else {
								let rand2 = Math.random()
								if (rand2 < 0.7) {
									midCombatAllyAdd(newAllySlug,'right')
								}
								else if (rand2 < 0.95) {
									midCombatAllyAdd(newAllySlug1,'right')
								}
								else {
									midCombatAllyAdd(newAllySlug2,'right')
								}
							}
						}
					}
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "HEAVENBOUND!",
                    })
                    readoutAdd({
                        message: `${origin.name}'s powerful strike calls forth an angel! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.4)
            }
        },
        help: "when critting a foe, 10% chance to summon angelic ally (max:4)"
    },
	
	env.STATUS_EFFECTS.spine_calc = {
        slug: "spine_calc",
        name: "Savior Complex",
        passive: "modifier",
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_order%20item%20holder.gif",
		//where we're going, we don't NEED an events property
        help: "all actors receive UNFAIR ADVANTAGE" // we are gonna need an unfair advantage that works universally though
    },
	
	env.ACTIONS.rez_universal = {
        slug: "rez_universal",
        name: "Unfair Advantage",
        type: 'support+target+rez+autohit+boxtarg',
        anim: "heal",
        usage: {
            act: "%USER BRINGS %TARGET BACK TO THEIR FEET",
            hit: "%TARGET IS READY TO FIGHT",
            crit: "%TARGET GETS A SECOND WIND"
        },
        details: {
            flavor: "'repair ally to fighting condition';'used only as last resort'",
            onUse: `'revive target at [STAT::percentage]%HP'`,
        },
        stats: {
            autohit: true,
            percentage: 25,
        },
		disableIf: (actor) => {
		  if(actor.team.members.filter(m=>m.state == "dead").length == 0) { return "NO VIABLE TARGETS" }
		  if(hasStatus(actor, "fear")) { return "PROHIBITED BY FEAR" }
		},
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                beneficial: true,
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'mend',
                    rate: 1
                },
                genExec: ({target})=>{
                    if(target.state == "dead") {
                        target.hp = target.maxhp * 0.25
                        combatRevive(target)
                        reactDialogue(target, 'receive_rez')
						return "critbuff";
                    }
                }                
            })
        },
    },
	
    env.STATUS_EFFECTS.flesh_menace = { 
        slug: "flesh_menace",
        name: "ACTION::Menace",
        passive: true,
        beneficial: true,
        impulse: {type: "action", component: "flesh"},
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/menace.gif",
        
        events: {
            //in evades, the 'subject' is the origin of the attack
            GLOBAL_onEvade: function({subject, target, attack, originalEventTarget}) {
                let user = this.status.affecting
                if(
                    !user.enemyTeam.members.includes(subject) || 
                    subject.state == "dead" ||
                    user.state == "dead" ||
                    target == user ||
                    hasStatus(user, "fear")
                ) return;
				
				let dullUtility = [2, 4, 4, 5, 5, 5, 6, 6, 6, 6] //vestigial variable
				
                let utility = env.ACTIONS[user.actions[2]]
				if (user.actions.includes('special_player_dullsummon_low')) {
					utility = env.ACTIONS[user.actions[dullUtility.sample()]]
				}

                setTimeout(()=>{
                    useAction(this.status.affecting, utility, subject, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "menace"})
            
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "action",
                        arbitraryString: `MENACE::${utility.name.toUpperCase()}`,
                        size: 1.5,
                    })

                    readoutAdd({
                        message: `${user.name} grasps the opportunity as ${subject.name} misses! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "if alive, on ally evade, use utility"
    },

    env.STATUS_EFFECTS.dull_pragmatist = { 
        slug: "dull_pragmatist",
        name: "ACTION::Pragmatist",
        passive: true,
        beneficial: true,
        impulse: {type: "action", component: "dull"},
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/pragmatist.gif",
        
        events: {
            //in evades, the 'subject' is the origin of the attack
            GLOBAL_onEvade: function({subject, target, attack, originalEventTarget}) {
                let user = this.status.affecting
                if(
                    !user.enemyTeam.members.includes(subject) || 
                    subject.state == "dead" ||
                    user.state == "dead" ||
                    target == user ||
                    hasStatus(user, "fear")
                ) return;

                let secondary = env.ACTIONS[this.status.affecting.actions[1]]
				if(hasStatus(this.status.affecting, "windup") && this.status.affecting.windupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.windupActions[1]])
				if(hasStatus(this.status.affecting, "winderup") && this.status.affecting.winderupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.winderupActions[1]])
				if(hasStatus(this.status.affecting, "windestup") && this.status.affecting.windestupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.winderupActions[1]])
				if(hasStatus(this.status.affecting, "final_windup") && this.status.affecting.finalWindupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.finalWindupActions[1]])
				if(hasStatus(this.status.affecting, "windup_aim") && this.status.affecting.aimingActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.aimingActions[1]])

                setTimeout(()=>{
                    useAction(this.status.affecting, secondary, secondary.beneficial ? target : subject, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "pragmatist"})
            
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "action",
                        arbitraryString: `PRAGMATIST::${secondary.name.toUpperCase()}`,
                        size: 1.5,
                    })

                    readoutAdd({
                        message: `${user.name} supports their team as ${subject.name} misses! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "if alive, on ally evade, use secondary \nif secondary is beneficial, used on ally\nif secondary is offensive, used on foe"
    }
	
	if(env.ACTIONS.windup_cover.noRepeat = true) (env.ACTIONS.windup_cover.noRepeat = false) // god fucking damn it

    env.STATUS_EFFECTS.spirestone_parry = { 
        slug: "spirestone_parry",
        name: "ACTION::Parry-Riposte",
        passive: true,
        beneficial: true,
        impulse: {type: "action", component: "spirestone"},
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/parry.gif",
        
        events: {
            //in evades, the 'subject' is the origin of the attack <- really hoping this holds true for critical hits cause boy howdy if it doesn't i am FUCKED (it does !! yaaaay :D)
            GLOBAL_onCritStruck: function({subject, target, attack, originalEventTarget}) {
                let user = this.status.affecting
                if(
                    !user.enemyTeam.members.includes(subject) || 
                    subject.state == "dead" ||
                    user.state == "dead" ||
					target == user ||
					hasStatus(user, "fear")
                ) return;
				
				let dullUtility = [2, 4, 4, 5, 5, 5, 6, 6, 6, 6] //vestigial variable
				
                let utility = env.ACTIONS[user.actions[2]]
				if (user.actions.includes('special_player_dullsummon_low')) {
					utility = env.ACTIONS[user.actions[dullUtility.sample()]]
				}
                let primary = env.ACTIONS[user.actions[0]]

                setTimeout(()=>{
					if(user.actions.includes("windup_cover")) (utility = env.ACTIONS.windup_cover) // i should not have to do this but no part of how this is breaking makes any fucking sense so here we are
					if([user.actions[2]]) {
						useAction(this.status.affecting, utility, subject, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "parry"})
					}
					
                    sendFloater({ 
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "action",
                        arbitraryString: `PARRY::${utility.name.toUpperCase()}`,
                        size: 1.5,
                    })

                    readoutAdd({
                        message: `${user.name} parries ${subject.name}'s attack! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.3),
				
				setTimeout(()=>{
					if(hasStatus(this.status.affecting, "windup")) (primary = env.ACTIONS[user.windupActions[0]])
					if(hasStatus(user, "winderup")) (primary = env.ACTIONS[user.winderupActions[0]])
					if(hasStatus(user, "windestup")) (primary = env.ACTIONS[user.windestupActions[0]])
					if(hasStatus(user, "final_windup")) (primary = env.ACTIONS[user.finalWindupActions[0]])
					if(hasStatus(user, "windup_aim")) (primary = env.ACTIONS[user.aimingActions[0]])
                    useAction(this.status.affecting, primary, subject, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "riposte"})
				
					if(user.actions.includes("windup_cover")) (primary = env.ACTIONS.focused_shot_weak) // ditto
            
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "action",
                        arbitraryString: `RIPOSTE::${primary.name.toUpperCase()}`,
                        size: 1.5,
                    })

                    readoutAdd({
                        message: `${user.name} counterattacks! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.6)
            }
        },

        help: 'if alive, when an ally receives a critical hit, use utility, then counterattack against attacker with primary'
    },

	env.STATUS_EFFECTS.hands_penance = {
		slug: "hands_penance",
		name: "ACTION::Penance",
		passive: true,
		beneficial: true,
		impulse: {type: "action", component: "hands"},
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/penance.gif",
		
		events: {
			GLOBAL_onEvade: function({subject, target, attack, originalEventTarget}) {
                let user = this.status.affecting
                if(
                    !user.enemyTeam.members.includes(target) || 
                    subject.state == "dead" ||
                    user.state == "dead" ||
                    subject == user ||
                    hasStatus(user, "fear")
                ) return;

                let dullUtility = [2, 4, 4, 5, 5, 5, 6, 6, 6, 6] //vestigial variable
				
                let utility = env.ACTIONS[user.actions[2]]
				if (user.actions.includes('special_player_dullsummon_low')) {
					utility = env.ACTIONS[user.actions[dullUtility.sample()]]
				}

                setTimeout(()=>{
                    useAction(this.status.affecting, utility, target, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "penance"})
            
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "action",
                        arbitraryString: `PENANCE::${utility.name.toUpperCase()}`,
                        size: 1.5,
                    })

                    readoutAdd({
                        message: `${user.name} siezes the opportunity as their ally misses! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
		},
		
		help: 'if alive, when an ally misses a foe, use utility'
	},
	
	env.STATUS_EFFECTS.metal_autonomous = { 
        slug: "metal_autonomous",
        name: "ACTION::Autonomous",
        passive: true,
        beneficial: true,
        impulse: {type: "action", component: "metal"},
        icon: "/img/sprites/combat/passives/ceyetiny.gif",
		//inUse: false, //this is a surprise tool that will help us later
        
        events: {
			onTurn: function() {
				this.status.affecting.usingAutonomous = false //tell the game it hasn't been used yet
			},
			
            onCrit: function({subject, origin, attack, beneficial}) {
				if(this.status.affecting.usingAutonomous) return //if autonomous has already been used this turn, don't use it again
				else this.status.affecting.usingAutonomous = true //tell the game when it's been used
                let user = this.status.affecting
                if(beneficial || user.team.members.includes(subject) || user.state == "dead" || hasStatus(user, "fear")) return;

                let primary = env.ACTIONS[user.actions[0]]
				if(hasStatus(this.status.affecting, "windup")) (primary = env.ACTIONS[user.windupActions[0]])
				if(hasStatus(user, "winderup")) (primary = env.ACTIONS[user.winderupActions[0]])
				if(hasStatus(user, "windestup")) (primary = env.ACTIONS[user.windestupActions[0]])
				if(hasStatus(user, "final_windup")) (primary = env.ACTIONS[user.finalWindupActions[0]])
				if(hasStatus(user, "windup_aim")) (primary = env.ACTIONS[user.aimingActions[0]])
                
                setTimeout(()=>{
                    sendFloater({
                        target: user,
                        type: "arbitrary",
                        specialClass: "action",
                        arbitraryString: `AUTONOMOUS::${primary.name.toUpperCase()}`,
                        size: 1.5,
                    })

                    readoutAdd({
                        message: `${user.name} acts again on instinct! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                    
                    useAction(user, primary, subject, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "autonomous"})
                }, 500)
            }
        },

        help: "when critting a foe, use primary action on that foe"
    },
	
	env.STATUS_EFFECTS.pain_rampage = {
        slug: "pain_rampage",
        name: "ACTION::Rampage",
        passive: true,
        beneficial: true,
        impulse: {type: "action", component: "pain"},
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/reyetiny.gif",
        
        events: {
			onTurn: function() {
				this.status.affecting.usingRampage = false // tell the game it hasn't been used yet (turns out, if both teams have an actor with rampage, you get Mutually Assured Destruction the moment someone crits)
			},
            //in evades, the 'subject' is the origin of the attack <- really hoping this holds true for critical hits cause boy howdy if it doesn't i am FUCKED (it does !! yaaaay :D)
            GLOBAL_onCritStruck: function({subject, target, attack, originalEventTarget}) {
				if(this.status.affecting.usingRampage) return //if autonomous has already been used this turn, don't use it again
				else this.status.affecting.usingRampage = true //tell the game when it's been used
                let user = this.status.affecting
                if(
                    !user.enemyTeam.members.includes(subject) || 
                    subject.state == "dead" ||
                    user.state == "dead" ||
					target == user ||
					hasStatus(user, "fear")
                ) return;
				
				if(user.windupActions) { // velzie delights in my torment
					this.status.affecting.hasWindupActions = true
				} else this.status.affecting.hasWindupActions = false
				
                let primary = env.ACTIONS[user.actions[0]]
				if(user.hasWindupActions) {
					if(user.hasWindupActions && env.ACTIONS[user.windupActions[0]] !== (env.ACTIONS.special_combinesummon || env.ACTIONS.special_combinesummon_select)) (primary = env.ACTIONS[user.windupActions[0]])
					if(user.winderupActions) (primary = env.ACTIONS[user.winderupActions[0]])
					if(user.windestupActions) (primary = env.ACTIONS[user.windestupActions[0]])
					if(user.finalWindupActions) (primary = env.ACTIONS[user.finalWindupActions[0]])
					if(user.aimingActions) (primary = env.ACTIONS[user.aimingActions[0]])
				}
				
				setTimeout(()=>{
                    env.GENERIC_ACTIONS.teamWave({
						team: user.enemyTeam,
						exec: (actor, i) => {
							env.GENERIC_ACTIONS.singleTarget({
								action: primary,
								user,
								target: actor,
								genExec: ({user, target})=> {
									primary.exec(user, target)
								},
							})
						}
					})
            
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "action",
                        arbitraryString: `RAMPAGE::${primary.name.toUpperCase()}`,
                        size: 1.5,
                    })

                    readoutAdd({
                        message: `${user.name} lashes out against their foes! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.5)
            }
        },

        help: 'if alive, when an ally receives a critical hit, use primary over enemy team'
    },
	
	env.STATUS_EFFECTS.intrusive_maladaptive = {
		slug: "intrusive_maladaptive",
		name: "ACTION::Maladaptive Coping",
		passive: true,
		beneficial: true,
		impulse: {type: "action", component: "intrusive"},
		icon: "/img/sprites/combat/passives/ceyetiny.gif",
		
		events: {
			onStruck: function({subject, attack, beneficial}) {
                let user = this.status.affecting
                if(
                    user.state == "dead" ||
                    hasStatus(user, "fear")
                ) return;

                let dullUtility = [2, 4, 4, 5, 5, 5, 6, 6, 6, 6] //vestigial variable
				
                let utility = env.ACTIONS[user.actions[2]]
				if (user.actions.includes('special_player_dullsummon_low')) {
					utility = env.ACTIONS[user.actions[dullUtility.sample()]]
				}

                setTimeout(()=>{
                    useAction(this.status.affecting, utility, target, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "maladaptive"})
            
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "action",
                        arbitraryString: `MALADAPTATION::${utility.name.toUpperCase()}`,
                        size: 1.5,
                    })

                    readoutAdd({
                        message: `${user.name} siezes the opportunity as they're struck! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
		},
		
		help: 'when struck offensively, use utility'
	},
	
	env.STATUS_EFFECTS.lightning_kugelblitz = {
		slug: "lightning_kugelblitz",
		name: "ACTION::Kugelblitz",
		passive: true,
		beneficial: true,
		impulse: {type: "action", component: "lightning"},
		icon: "/img/sprites/combat/passives/yeyetiny.gif",
		
		events: {
			onStruck: function({subject, attack, beneficial}) {
                let user = this.status.affecting
                if(
                    user.state == "dead" ||
					subject.state == "dead" ||
					subject == user ||
                    hasStatus(user, "fear")
                ) return;
				
                let primary = env.ACTIONS[user.actions[0]]
				if(hasStatus(user, "windup")) (primary = env.ACTIONS[user.windupActions[0]])
				if(hasStatus(user, "winderup")) (primary = env.ACTIONS[user.winderupActions[0]])
				if(hasStatus(user, "windestup")) (primary = env.ACTIONS[user.windestupActions[0]])
				if(hasStatus(user, "final_windup")) (primary = env.ACTIONS[user.finalWindupActions[0]])
				if(hasStatus(user, "windup_aim")) (primary = env.ACTIONS[user.aimingActions[0]])	

                setTimeout(()=>{
                    useAction(this.status.affecting, primary, subject, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "kugelblitz"})
            
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "action",
                        arbitraryString: `KUGELBLITZ::${primary.name.toUpperCase()}`,
                        size: 1.5,
                    })

                    readoutAdd({
                        message: `${user.name} lashes out against ${subject.name} as they strike! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.3)
            }
		},
		
		help: 'when struck offensively, retaliate against attacker with primary (1st) action'
	},
	
	env.STATUS_EFFECTS.heart_endure = { 
        slug: "heart_endure",
        name: "ACTION::Endure",
        icon: "/img/sprites/combat/passives/meyetiny.gif",
        infinite: true,
        beneficial: true,
        passive: true,
		impulse: {type: "action", component: "heart"},
        help: "once per combat, on death, self-revive with 8HP, 1T:EVASION, FOCUSED, and 3T:EMPOWERED\non revival, focused has infinite duration",
        
        events: {
            onCreated: function({statusObj}) {
                if(statusObj == this.status) {
                    this.status.affecting.fakeLastStand = true //turns out combat.js really doesn't like it when you put an actor with no sprite into the last stand state, so we're doing this instead :P
                }
            },        

            onDeath: function() {
                if(this.status.affecting.state == "dead" && this.status.affecting.fakeLastStand == true) {
					combatRevive(this.status.affecting)
					this.status.affecting.hp = 8
					setTimeout(()=>{
						if(!this.status.affecting.npc) this.status.affecting.fakeLastStand = false
						this.status.affecting.state = "living"
						
						readoutAdd({
							message: `${this.status.affecting.name} pushes through their wounds! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
							name: "sourceless", 
							type: "sourceless combat minordetail", 
							show: false,
							sfx: false
						})
						sendFloater({
							target: this.status.affecting,
							type: "arbitrary",
							specialClass: "action",
							arbitraryString: "ACTION::ENDURE",
							size: 2,
						})
						addStatus({target: this.status.affecting, origin: this.status.affecting, status: "evasion", length: 1, noReact: true, noUpdate: true})
						addStatus({target: this.status.affecting, origin: this.status.affecting, status: "focused", length: 2, noReact: true, noUpdate: true})
						addStatus({target: this.status.affecting, origin: this.status.affecting, status: "empowered", length: 3, noReact: true, noUpdate: true})
						play('scarydoia', 0.75)
					}, env.ADVANCE_RATE * 0.1)
                    updateStats({actor: this.status.affecting})
                }
            }, 
			
			onAddStatus: function({target, statusObj}) {
                if(this.status.affecting.fakeLastStand == true) return
				else if(statusObj.slug == "focused") {
                    statusObj.infinite = true
                }
            },
        },
    },
	
	env.STATUS_EFFECTS.chaos_locknload = {
        slug: "chaos_locknload",
        name: "ACTION::LOCK N LOAD",
        passive: true,
        beneficial: true,
        impulse: {type: "action", component: "chaos"},
        icon: "/img/sprites/combat/passives/yeyetiny.gif",
        
        events: {
            //in evades, the 'subject' is the origin of the attack <- really hoping this holds true for critical hits cause boy howdy if it doesn't i am FUCKED (it does !! yaaaay :D)
            GLOBAL_onCritStruck: function({subject, target, attack, originalEventTarget}) {
                let user = this.status.affecting
				let amt = attack //if i recall correctly, attack is damage received
                if(
                    !user.enemyTeam.members.includes(subject) || 
                    subject.state == "dead" ||
                    user.state == "dead" ||
					target == user ||
					hasStatus(user, "fear")
                ) return;
				
                let utility = env.ACTIONS[user.actions[2]]

				for (let i = 0; i < amt; i++) {
					setTimeout(()=>{
						useAction(user, utility, target, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "LOCK N LOAD"})
						sendFloater({ 
							target: this.status.affecting,
							type: "arbitrary",
							specialClass: "action",
							arbitraryString: `LOCK N LOAD::${utility.name.toUpperCase()}`,
							size: 1.5,
						})
					}, 500 + 200 * i)
					
					readoutAdd({
						message: `${user.name} prepares a counter-attack as their ally is struck! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
						name: "sourceless", 
						type: "sourceless combat minordetail", 
						show: false,
						sfx: false
					})
				}
            }
        },

        help: 'if alive, when an ally receives a critical hit, use utility X number of times corresponding to damage received\nIE::-4HP = 4 utility uses'
    },
	
	env.STATUS_EFFECTS.order_override = {
        slug: "order_override",
        name: "ACTION::Override",
        passive: true,
        beneficial: true,
        impulse: {type: "action", component: "order"},
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/beyetiny.gif",
        
        events: {
            //in evades, the 'subject' is the origin of the attack <- really hoping this holds true for critical hits cause boy howdy if it doesn't i am FUCKED (it does !! yaaaay :D)
            GLOBAL_onCritStruck: function({subject, target, attack, originalEventTarget}) {
                let user = this.status.affecting
				let amt = attack //if i recall correctly, attack is damage received
				if(amt == 1) (amt = 2) //safeguard for weird behavior i wasn't able to recreate too much
                if(
                    !user.enemyTeam.members.includes(subject) || 
                    subject.state == "dead" ||
                    user.state == "dead" ||
					target == user ||
					hasStatus(user, "fear")
                ) return;

				for (let i = 0; i < amt; i++) {
					let primary = env.ACTIONS[user.actions[0]]
					if(hasStatus(user, "windup")) (primary = env.ACTIONS[user.windupActions[0]]) // you really want this to be in the for loop actually, or else it doesn't know to use the primary windup action
					if(hasStatus(user, "winderup")) (primary = env.ACTIONS[user.winderupActions[0]]) // note to self::make this nightmare block its own function at some point so you don't have to keep copying it everywhere
					if(hasStatus(user, "windestup")) (primary = env.ACTIONS[user.windestupActions[0]])
					if(hasStatus(user, "final_windup")) (primary = env.ACTIONS[user.finalWindupActions[0]])
					if(hasStatus(user, "windup_aim")) (primary = env.ACTIONS[user.aimingActions[0]])
					
					setTimeout(()=>{
						if(hasStatus(user, "windup")) (primary = env.ACTIONS[user.windupActions[0]]) // you have ONE JOB and it is to REPLACE PRIMARY WITH A WINDUP ACTION !!!!!!!!!!! so explain to me WHY !!!!!! you are NOT DOING THAT !!!!!!!!!
						if(hasStatus(user, "winderup")) (primary = env.ACTIONS[user.winderupActions[0]])
						if(hasStatus(user, "windestup")) (primary = env.ACTIONS[user.windestupActions[0]])
						if(hasStatus(user, "final_windup")) (primary = env.ACTIONS[user.finalWindupActions[0]])
						if(hasStatus(user, "windup_aim")) (primary = env.ACTIONS[user.aimingActions[0]])
						useAction(user, primary, subject, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "override"})
						sendFloater({ 
							target: this.status.affecting,
							type: "arbitrary",
							specialClass: "action",
							arbitraryString: `OVERRIDE::${primary.name.toUpperCase()}`,
							size: 1.5,
						})
					}, 500 + 200 * i)
					
					readoutAdd({
						message: `${user.name} overrides their role as ${subject.name} strikes! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
						name: "sourceless", 
						type: "sourceless combat minordetail", 
						show: false,
						sfx: false
					})
				}
            }
        },

        help: 'if alive, when an ally receives a critical hit, counterattack with primary action X number of times corresponding to damage received\nIE::-4HP = 4 attacks'
    }
if(check("cmb_unlocked")) {
	env.STATUS_EFFECTS.cmb_oicw = { 
        slug: "cmb_oicw",
        name: "ACTION::OICW",
        passive: true,
        beneficial: true,
        impulse: {type: "action", component: "cmb"},
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/weyetiny.gif",
		inUse: false, //this is a surprise tool that will help us later
        
        events: {
			onTurn: function() {
				env.STATUS_EFFECTS.cmb_oicw.inUse = false //tell the game it hasn't been used yet
			},
			
            onCrit: function({subject, origin, attack, beneficial}) {
				if(env.STATUS_EFFECTS.cmb_oicw.inUse) return //if autonomous has already been used this turn, don't use it again
				else env.STATUS_EFFECTS.cmb_oicw.inUse = true //tell the game when it's been used
                let user = this.status.affecting
                if(beneficial || user.team.members.includes(subject) || user.state == "dead" || hasStatus(user, "fear")) return;

                let secondary = env.ACTIONS[this.status.affecting.actions[1]]
				if(hasStatus(this.status.affecting, "windup") && this.status.affecting.windupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.windupActions[1]])
				if(hasStatus(this.status.affecting, "winderup") && this.status.affecting.winderupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.winderupActions[1]])
				if(hasStatus(this.status.affecting, "windestup") && this.status.affecting.windestupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.winderupActions[1]])
				if(hasStatus(this.status.affecting, "final_windup") && this.status.affecting.finalWindupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.finalWindupActions[1]])
				if(hasStatus(this.status.affecting, "windup_aim") && this.status.affecting.aimingActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.aimingActions[1]])
                
                setTimeout(()=>{
                    sendFloater({
                        target: user,
                        type: "arbitrary",
                        specialClass: "action",
                        arbitraryString: `OICW::${secondary.name.toUpperCase()}`,
                        size: 1.5,
                    })

                    readoutAdd({
                        message: `${user.name} acts again on instinct! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                    
                    useAction(this.status.affecting, secondary, secondary.beneficial ? user : target, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "OICW"})
                }, 500)
            }
        },

        help: "when critting a foe, use secondary\nif secondary is offensive, used on that foe\nif secondary is beneficial, used on self"
    }
}
	env.STATUS_EFFECTS.zuka_vengeance = {
        slug: "zuka_vengeance",
        name: "ACTION::Vengeance",
        passive: true,
        beneficial: true,
        impulse: {type: "action", component: "zuka"},
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/reyetiny.gif",
        
        events: {
            //in evades, the 'subject' is the origin of the attack <- really hoping this holds true for critical hits cause boy howdy if it doesn't i am FUCKED (it does !! yaaaay :D)
            onCritStruck: function({subject, target, attack, originalEventTarget}) {
                let user = this.status.affecting
				let amt = attack //if i recall correctly, attack is damage received
                if(
                    !user.enemyTeam.members.includes(subject) || 
                    subject.state == "dead" ||
                    user.state == "dead" ||
					hasStatus(user, "fear")
                ) return;
				
                let primary = env.ACTIONS[user.actions[0]]
				let secondary = env.ACTIONS[user.actions[1]]
				let utility = env.ACTIONS[user.actions[2]]
				
				let validFoes = env.rpg.enemyTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")
				let validAllies = env.rpg.allyTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

				for (let i = 0; i < amt; i++) {
					setTimeout(()=>{
						if(hasStatus(user, "windup")) (primary = env.ACTIONS[user.windupActions[0]]) // i should make like . a dedicated function for this
						if(hasStatus(user, "winderup")) (primary = env.ACTIONS[user.winderupActions[0]]) // oh well
						if(hasStatus(user, "windestup")) (primary = env.ACTIONS[user.windestupActions[0]])
						if(hasStatus(user, "final_windup")) (primary = env.ACTIONS[user.finalWindupActions[0]])
						if(hasStatus(user, "windup_aim")) (primary = env.ACTIONS[user.aimingActions[0]])
						useAction(user, primary, validFoes.sample(), {triggerActionUseEvent: false, beingUsedAsync: true, reason: "vengeance::PRIMARY"})
						sendFloater({ 
							target: this.status.affecting,
							type: "arbitrary",
							specialClass: "action",
							arbitraryString: `VENGEANCE::${primary.name.toUpperCase()}`,
							size: 1.5,
						})
					}, 500 + 200 * i)
					
					setTimeout(()=>{
						if(hasStatus(this.status.affecting, "windup") && this.status.affecting.windupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.windupActions[1]])
						if(hasStatus(this.status.affecting, "winderup") && this.status.affecting.winderupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.winderupActions[1]])
						if(hasStatus(this.status.affecting, "windestup") && this.status.affecting.windestupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.winderupActions[1]])
						if(hasStatus(this.status.affecting, "final_windup") && this.status.affecting.finalWindupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.finalWindupActions[1]])
						if(hasStatus(this.status.affecting, "windup_aim") && this.status.affecting.aimingActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.aimingActions[1]])
						useAction(user, secondary, secondary.beneficial ? validAllies.sample() : validFoes.sample(), {triggerActionUseEvent: false, beingUsedAsync: true, reason: "vengeance::SECONDARY"})
						sendFloater({ 
							target: this.status.affecting,
							type: "arbitrary",
							specialClass: "action",
							arbitraryString: `VENGEANCE::${secondary.name.toUpperCase()}`,
							size: 1.5,
						})
					}, 1000 + 200 * i)
					
					setTimeout(()=>{
						useAction(user, utility, subject, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "vengeance::UTILITY"})
						sendFloater({ 
							target: this.status.affecting,
							type: "arbitrary",
							specialClass: "action",
							arbitraryString: `VENGEANCE::${utility.name.toUpperCase()}`,
							size: 1.5,
						})
					}, 1500 + 200 * i)
					
				}
				
				readoutAdd({
					message: `${user.name} goes all out! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
					name: "sourceless", 
					type: "sourceless combat minordetail", 
					show: false,
					sfx: false
				})
            }
        },

        help: 'if alive, when receiving a critical hit, use primary, secondary, and utility action X number of times corresponding to damage received\nIE::-4HP = 12 total actions'
    },
	
	env.STATUS_EFFECTS.hook_requite = {
        slug: "hook_requite",
        name: "ACTION::Requital",
        passive: true,
        beneficial: true,
        impulse: {type: "action", component: "hook"},
        icon: "/img/sprites/combat/passives/meyetiny.gif",
        events: {
            //in evades, the 'subject' is the origin of the attack <- really hoping this holds true for critical hits cause boy howdy if it doesn't i am FUCKED (it does !! yaaaay :D)
            GLOBAL_onCritStruck: function({subject, target, attack, originalEventTarget}) {
                let user = this.status.affecting
				let amt = attack //if i recall correctly, attack is damage received
				if(amt == 1) (amt = 2) //safeguard for weird behavior i wasn't able to recreate too much
                if(
                    !user.enemyTeam.members.includes(subject) || 
                    subject.state == "dead" ||
                    user.state == "dead" ||
					target == user ||
					hasStatus(user, "fear")
                ) return;

				for (let i = 0; i < amt; i++) {
					setTimeout(()=>{
						let validFoes = env.rpg.enemyTeam.members.filter(member => member.state != "dead" && member.state != "lastStand") // hate. let me tell you how much i
						let validAllies = env.rpg.allyTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")
						if(user.team.name.includes("enemyTeam")) {
							validFoes = env.rpg.allyTeam.members.filter(member => member.state != "dead" && member.state != "lastStand") // have come to hate you. there are 3
							validAllies = env.rpg.enemyTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")
						}
						let secondary = env.ACTIONS[this.status.affecting.actions[1]] // oh my god this is fucking horrid
						if(hasStatus(this.status.affecting, "windup") && this.status.affecting.windupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.windupActions[1]])
						if(hasStatus(this.status.affecting, "winderup") && this.status.affecting.winderupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.winderupActions[1]])
						if(hasStatus(this.status.affecting, "windestup") && this.status.affecting.windestupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.winderupActions[1]])
						if(hasStatus(this.status.affecting, "final_windup") && this.status.affecting.finalWindupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.finalWindupActions[1]])
						if(hasStatus(this.status.affecting, "windup_aim") && this.status.affecting.aimingActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.aimingActions[1]])
						if(hasStatus(this.status.affecting, "windup") && this.status.affecting.windupActions == ["dullflare_player"]) (secondary = env.ACTIONS["dullflare_player"])
						if(hasStatus(this.status.affecting, "windup") && this.status.affecting.windupActions == ["calculated_stab"]) (secondary = env.ACTIONS["calculated_stab"])
						if(hasStatus(this.status.affecting, "windup") && this.status.affecting.windupActions == ["calculated_frenzy"]) (secondary = env.ACTIONS["calculated_frenzy"])
						if(hasStatus(this.status.affecting, "windup") && this.status.affecting.windupActions == ["reconstruct"]) (secondary = env.ACTIONS["reconstruct"])
						useAction(user, secondary, secondary.beneficial ? validAllies.sample() : validFoes.sample(), {triggerActionUseEvent: false, beingUsedAsync: true, reason: "requital"})
						sendFloater({ 
							target: this.status.affecting,
							type: "arbitrary",
							specialClass: "action",
							arbitraryString: `REQUITAL::${secondary.name.toUpperCase()}`,
							size: 1.5,
						})
					}, 500 + 200 * i)
					
					readoutAdd({
						message: `${user.name} gets even as ${subject.name} strikes! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
						name: "sourceless", 
						type: "sourceless combat minordetail", 
						show: false,
						sfx: false
					})
				}
            }
        },
        help: 'if alive, when an ally receives a critical hit, use secondary action X number of times corresponding to damage received\nIE::-4HP = 4 attacks\nif offensive, targeting random foe\nif beneficial, targeting random ally'
    },
	
	env.STATUS_EFFECTS.spine_vigilance = {
        slug: "spine_vigilance",
        name: "ACTION::Vigilant",
        passive: true,
        beneficial: true,
        impulse: {type: "action", component: "spine"},
        icon: "/img/textures/ceyetiny.gif",
        events: {
			onTurn: function() {
				this.status.affecting.usingVigilance = false // tell the game it hasn't been used yet (turns out, if both teams have an actor with rampage, you get Mutually Assured Destruction the moment someone crits)
			},
            //in evades, the 'subject' is the origin of the attack <- really hoping this holds true for critical hits cause boy howdy if it doesn't i am FUCKED (it does !! yaaaay :D)
            GLOBAL_onCritStruck: function({subject, target, attack, originalEventTarget}) {
				if(this.status.affecting.usingVigilance) return //if autonomous has already been used this turn, don't use it again
				else this.status.affecting.usingVigilance = true //tell the game when it's been used
                let user = this.status.affecting
                if(
                    !user.enemyTeam.members.includes(subject) || 
                    subject.state == "dead" ||
                    user.state == "dead" ||
					target == user ||
					hasStatus(user, "fear")
                ) return;

				if(user.windupActions) { // velzie delights in my torment
					this.status.affecting.hasWindupActions = true
				} else this.status.affecting.hasWindupActions = false

                let secondary = env.ACTIONS[this.status.affecting.actions[1]] // oh my god this is fucking horrid
				if(user.hasWindupActions) {
					if(hasStatus(this.status.affecting, "windup") && this.status.affecting.windupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.windupActions[1]])
					if(hasStatus(this.status.affecting, "winderup") && this.status.affecting.winderupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.winderupActions[1]])
					if(hasStatus(this.status.affecting, "windestup") && this.status.affecting.windestupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.winderupActions[1]])
					if(hasStatus(this.status.affecting, "final_windup") && this.status.affecting.finalWindupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.finalWindupActions[1]])
					if(hasStatus(this.status.affecting, "windup_aim") && this.status.affecting.aimingActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.aimingActions[1]])
					if(hasStatus(this.status.affecting, "windup") && this.status.affecting.windupActions == ["dullflare_player"]) (secondary = env.ACTIONS["dullflare_player"])
					if(hasStatus(this.status.affecting, "windup") && this.status.affecting.windupActions == ["calculated_stab"]) (secondary = env.ACTIONS["calculated_stab"])
					if(hasStatus(this.status.affecting, "windup") && this.status.affecting.windupActions == ["calculated_frenzy"]) (secondary = env.ACTIONS["calculated_frenzy"])
					if(hasStatus(this.status.affecting, "windup") && this.status.affecting.windupActions == ["reconstruct"]) (secondary = env.ACTIONS["reconstruct"])
				}

				setTimeout(()=>{
                    env.GENERIC_ACTIONS.teamWave({
						team: secondary.beneficial ? user.team : user.enemyTeam, // this should work i think
						exec: (actor, i) => {
							env.GENERIC_ACTIONS.singleTarget({
								action: secondary,
								user,
								target: actor,
								hitSfx: { name: "hit", rate: 1, volume: 0.001 }, // fuckyoufuckyoufuckyoufuckyoufuckyou
								critSfx: { name: "crit", rate: 1, volume: 0.001 }, // literally just use secondary's hit and crit sfx !!!! it's RIGHT THERE !!!! in the EXEC !!!! that YOU CALL !!!!! fuck !!!!!!!!!!
								genExec: ({user, target})=> {
									secondary.exec(user, target)
								},
							})
						}
					})

                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "action",
                        arbitraryString: `VIGILANCE::${secondary.name.toUpperCase()}`,
                        size: 1.5,
                    })

                    readoutAdd({
                        message: `${user.name} seizes the opportunity! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.5)
            }
        },
        help: 'if alive, when an ally receives a critical hit, use secondary\nif beneficial, used over ally team\nif offensive, used over enemy team'
    },

	env.STATUS_EFFECTS.fated_flesh = {
		slug: "fated_flesh",
		name: "FATED::Flesh",
		passive: true,
		beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_fated_flesh.gif",
		impulse: {type: "fated", component: "flesh"},
		events: {
            onCreated: function({statusObj}) {
                if(statusObj.slug != this.status.slug) return;
                
                this.status.power = 0
                if(this.status.affecting?.member?.components) for (const [slotName, slotContents] of Object.entries(this.status.affecting.member.components)) {
                    if(slotContents == "flesh") this.status.power++
                }

                if(this.status.affecting?.member?.augments) for (const augmentSlug of this.status.affecting.member.augments) {
                    let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]
                    if(augment?.component) if(augment.component[1] == "flesh") this.status.power += 2
                }
            },
			
			onHit: function({subject, origin, attack, beneficial}) {
				if(!this.status.power || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                
                addStatus({target: subject, origin, status: "rot", length: this.status.power})
                
                sendFloater({
                    target: this.status.affecting,
                    type: "arbitrary",
                    specialClass: "fate",
                    arbitraryString: "FATE::FLESH",
                })
                
                setTimeout(()=>{
                    readoutAdd({
                        message: `${origin.name} inflicts ${subject.name} with additional rot! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
		},
		help: "per humor of flesh in this shell::\n+1T:ROT on all attacks\n+1 max hallucinations"
	}

	env.STATUS_EFFECTS.fated_dull = {
		slug: "fated_dull",
		name: "FATED::Dull",
		passive: true,
		beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_fated_dull.gif",
		impulse: {type: "fated", component: "dull"},
		events: {
            onCreated: function({statusObj}) {
                if(statusObj.slug != this.status.slug) return;
                
                this.status.power = 0
                if(this.status.affecting?.member?.components) for (const [slotName, slotContents] of Object.entries(this.status.affecting.member.components)) {
                    if(slotContents == "dull") this.status.power++
                }

                if(this.status.affecting?.member?.augments) for (const augmentSlug of this.status.affecting.member.augments) {
                    let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]
                    if(augment?.component) if(augment.component[1] == "dull") this.status.power += 2
                }

                this.status.outgoingFlatCrit = 0.05 * this.status.power;
            }
		},
		help: "per humor of dull in this shell::\n+5% base crit chance on all actions\n+5% DULL PORTAL::SPECIAL success rate"
	},

	env.STATUS_EFFECTS.fated_spirestone = {
		slug: "fated_spirestone",
		name: "FATED::Spirestone",
		passive: true,
		beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_fated_spirestone.gif",
		impulse: {type: "fated", component: "spirestone"},
		incomingCrit: 0,
		events: {
            onCreated: function({statusObj}) {
                if(statusObj.slug != this.status.slug) return;
                
                this.status.power = 0
                if(this.status.affecting?.member?.components) for (const [slotName, slotContents] of Object.entries(this.status.affecting.member.components)) {
                    if(slotContents == "spirestone") this.status.power++
                }

                if(this.status.affecting?.member?.augments) for (const augmentSlug of this.status.affecting.member.augments) {
                    let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]
                    if(augment?.component) if(augment.component[1] == "spirestone") this.status.power += 2
                }

                this.status.incomingCrit = -0.2 * this.status.power;
			},
			onTurn: function() {
				if(hasStatus(this.status.affecting, "focused")) {
					addStatus({target: this.status.affecting, status: "focused", length: this.status.power});
				}
			}
		},
		help: "per humor of spirestone in this shell::\n-20% incoming crit%\n+1T:FOCUSED on turn while focused"
	},

	env.STATUS_EFFECTS.fated_hands = {
        slug: "fated_hands",
        name: "FATED::Hands",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_fated_hands.gif",
        impulse: {
            type: "fated", 
            component: "hands",
        },
        
        events: {
            onCreated: function({statusObj}) {
                if(statusObj.slug != this.status.slug) return;
                
                this.status.power = 0
                if(this.status.affecting?.member?.components) for (const [slotName, slotContents] of Object.entries(this.status.affecting.member.components)) {
                    if(slotContents == "hands") this.status.power++
                }

                if(this.status.affecting?.member?.augments) for (const augmentSlug of this.status.affecting.member.augments) {
                    let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]
                    if(augment?.component) if(augment.component[1] == "hands") this.status.power += 2
                }
            },

            onHit: function({subject, origin, attack, beneficial}) {
                if(!this.status.power || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                let effectChance = Math.random()
				if(effectChance > (0.1 * this.status.power)) return;
                
                let rand = Math.random()
                let status
                if(rand < 0.25) {
                    addStatus({target: subject, origin, status: "puncture", length: 3})
                    status = "puncture"
                    
                } else if(rand < 0.5) {
                    addStatus({target: subject, origin, status: "cursed", length: 2})
                    status = "cursed"

                } else if(rand < 0.75) {
                    addStatus({target: subject, origin, status: "vulnerable", length: 2})
                    status = "vulnerable" 
					
                } else {
					addStatus({target: subject, origin, status: "stun", length: 1})
					status = "stun"
				}
                
                setTimeout(()=>{
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "fate",
                        arbitraryString: "FATE::HANDS",
                    })
                    
                    readoutAdd({
                        message: `${origin.name} inflicts ${subject.name} with ${status}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "per humor of hands in this shell::\n+10% chance for (3T:PUNCTURE/2T:CURSED/2T:VULNERABLE/1T:STUN) on hit\n+10% chance to guarantee beneficial tarot card draw"
    },
	
	env.STATUS_EFFECTS.fated_metal = {
		slug: "fated_metal",
		name: "FATED::Metal",
		passive: true,
		beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_fated_metal.gif",
		impulse: {type: "fated", component: "metal"},
		events: {
            onCreated: function({statusObj}) {
                if(statusObj.slug != this.status.slug) return;
                
                this.status.power = 0
                if(this.status.affecting?.member?.components) for (const [slotName, slotContents] of Object.entries(this.status.affecting.member.components)) {
                    if(slotContents == "metal") this.status.power++
                }

                if(this.status.affecting?.member?.augments) for (const augmentSlug of this.status.affecting.member.augments) {
                    let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]
                    if(augment?.component) if(augment.component[1] == "metal") this.status.power += 2
                }
                
            },
			onTurn: function() {
				if(hasStatus(this.status.affecting,"windup")) (this.status.outgoingCrit = 1 * this.status.power);
			}
		},
		help: "per humor of metal in this shell::\n+100% outgoing crit% while under WINDUP\n+1 max golems"
	},
	
	env.STATUS_EFFECTS.fated_pain = {
		slug: "fated_pain",
		name: "FATED::Pain",
		passive: true,
		beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_fated_pain.gif",
		impulse: {type: "fated", component: "pain"},
		events: {
			onCreated: function({statusObj}) {
                if(statusObj.slug != this.status.slug) return;
                
                this.status.power = 0
                if(this.status.affecting?.member?.components) for (const [slotName, slotContents] of Object.entries(this.status.affecting.member.components)) {
                    if(slotContents == "pain") this.status.power++
                }

                if(this.status.affecting?.member?.augments) for (const augmentSlug of this.status.affecting.member.augments) {
                    let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]
                    if(augment?.component) if(augment.component[1] == "pain") this.status.power += 2 //sidenote::what the hell happens inbetween the two if statements here?? i just noticed there's like nothing there how does it WORK
                }
				
				let currentMaxHp = this.status.affecting.maxhp //dear corru the works why is it not maxHp
				let maxHpAdd = 0
                maxHpAdd = 2 * (0 + this.status.power)
				currentMaxHp = this.status.affecting.maxhp + maxHpAdd
				this.status.affecting.maxhp = currentMaxHp
				updateStats({actor: this.status.affecting})
            },
		},
		help: "per humor of pain in this shell::\n+2 max HP during combat\n+1 max husks"
	},
	
	env.STATUS_EFFECTS.fated_intrusive = {
		slug: "fated_intrusive",
		name: "FATED::???",
		passive: true,
		beneficial: true,
		infinite: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_fated_flantrusive.gif",
		impulse: {type: "fated", component: "intrusive"},
		events: {
			onCreated: function({statusObj}) {
                if(statusObj.slug != this.status.slug) return;
                
                this.status.power = 0
                if(this.status.affecting?.member?.components) for (const [slotName, slotContents] of Object.entries(this.status.affecting.member.components)) {
                    if(slotContents == "intrusive") this.status.power++
                }

                if(this.status.affecting?.member?.augments) for (const augmentSlug of this.status.affecting.member.augments) {
                    let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]
                    if(augment?.component) if(augment.component[1] == "intrusive") this.status.power += 2
                }
				
				if(statusObj.slug == "fated_intrusive" && !this.status.initialized) {
                    let actor = this.status.affecting

                    env.rpg.insertAdjacentHTML('beforeend', `
                    <figure id="chancepanel" class="hidden" for="${actor.slug}">
                        <img src="/img/sprites/flantrusive/panelbase.gif">
                        <div class="wheel">
                            <ul>
                                <li class="d1">1</li>
                                <li class="d2">2</li>
                                <li class="d3">3</li>
                                <li class="d4">4</li>
                                <li class="d5">5</li>
                                <li class="d6">6</li>
                            </ul>
                        </div>
                        <div class="display">
                            <ol>
                                <li class="d1">1. life up</li>
                                <li class="d2">2. main up</li>
                                <li class="d3">3. unlucky</li>
                                <li class="d4">4. bomb</li>
                                <li class="d5">5. unlucky</li>
                                <li class="d6">6. change</li>
                            </ol>
                        </div>
                        <div class="result">
                            <div>
                                <span></span>
                            </div>
                        </div>
                    </figure>`)
                
                    actor.chancePanel = env.rpg.querySelector(`#chancepanel[for="${actor.slug}"]`)
                    actor.chancePanel.result = actor.chancePanel.querySelector(".result span")
                    actor.chancePanel.spin = (state) => { 
                        actor.chancePanel.removeAttribute("chosen")
                        actor.chancePanel.classList.toggle("spinning", state) 
                        actor.chancePanel.result.innerHTML = "???"
                    }
                
                    actor.chancePanel.stopAndResult = () => { 
                        let result = rand(1, 7)
                        actor.chancePanel.spin(false)
                        actor.chancePanel.setAttribute("chosen", result)
                
                        return result
                    }
                }
            },
			
			onHit: function({subject, origin, attack, beneficial}) {
                if(!this.status.power || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                if(Math.random() > (0.1 * this.status.power)) return;
                
                let rand = Math.random()
                let status
                if(rand < 0.3) {
                    addStatus({target: subject, origin, status: "open_wound", length: 2})
                    status = "open wound"
                    
                } else if(rand < 0.6) {
                    addStatus({target: subject, origin, status: "vulnerable", length: 3})
					addStatus({target: subject, origin, status: "critical_flaw", length: 1})
                    status = "vulnerable and critical flaw"

                } else {
                    addStatus({target: subject, origin, status: "stun", length: 1})
                    status = "stun" 
                }
                
                setTimeout(()=>{
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "fate",
                        arbitraryString: "FATE::???",
                    })
                    
                    readoutAdd({
                        message: `${origin.name} inflicts ${subject.name} with ${status}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            },
			
			onAction: function({action}) {
				let rand1 = Math.random()
				if(action.slug.includes('tarot') || action.slug.includes('select') || action.slug.includes('intrusive')) return
				else if(Math.random() < (0.1 * this.status.power)) {
					useAction(this.status.affecting, env.ACTIONS.special_intrusive_ally, this.status.affecting, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "fated::???"})
					sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "fate",
                        arbitraryString: "FATE::???",
                    })
				}
			},
		},
		help: "per humor of ??? in this shell::\n+10% chance for (+2T:OPEN WOUND/+3T:VULNERABLE +CRITICAL FLAW/+1T:STUN) on hit\n+10% chance to gamble when using most actions"
	},
	
    env.STATUS_EFFECTS.fated_lightning = {
        slug: "fated_lightning",
        name: "FATED::Lightning",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_fated_lightning.gif",
        impulse: {type: "fated", component: "lightning"},
        
        events: {
            onCreated: function({statusObj}) {
                if(statusObj.slug != this.status.slug) return;
                
                this.status.power = 0
                if(this.status.affecting?.member?.components) for (const [slotName, slotContents] of Object.entries(this.status.affecting.member.components)) {
                    if(slotContents == "lightning") this.status.power++
                }

                if(this.status.affecting?.member?.augments) for (const augmentSlug of this.status.affecting.member.augments) {
                    let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]
                    if(augment?.component) if(augment.component[1] == "lightning") this.status.power += 2
                }
            },

            onHit: function({subject, origin, attack, beneficial}) {
                if(!this.status.power || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                if(Math.random() > (0.1 * this.status.power)) return;
                
                let rand = Math.random()
                let status
                if(rand < 0.3) {
                    addStatus({target: subject, origin, status: "denatured", length: 2})
                    status = "denatured"
                    
                } else if(rand < 0.6) {
                    addStatus({target: subject, origin, status: "fear", length: 2})
					addStatus({target: subject, origin, status: "madness", length: 1})
                    status = "fear and madness"

                } else {
                    addStatus({target: subject, origin, status: "stun", length: 1})
                    status = "stun" 
                }
                
                setTimeout(()=>{
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "fate",
                        arbitraryString: "FATE::LIGHTNING",
                    })
                    
                    readoutAdd({
                        message: `${origin.name} inflicts ${subject.name} with ${status}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },
        help: "per humor of lightning in this shell::\n+10% chance for (+2T:FEAR +MADNESS/2T:DENATURED/1T:STUN) on hit\n+5% COMMAND STORM/INVOKE BLINDNESS special effect chance"
    },
	
	env.STATUS_EFFECTS.fated_heart = {
		slug: "fated_heart",
		name: "FATED::Heart",
		passive: true,
		beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_fated_heart.gif",
		impulse: {type: "fated", component: "heart"},
		events: {
			onCreated: function({statusObj}) {
                if(statusObj.slug != this.status.slug) return;
                
                this.status.power = 0
                if(this.status.affecting?.member?.components) for (const [slotName, slotContents] of Object.entries(this.status.affecting.member.components)) {
                    if(slotContents == "heart") this.status.power++
                }

                if(this.status.affecting?.member?.augments) for (const augmentSlug of this.status.affecting.member.augments) {
                    let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]
                    if(augment?.component) if(augment.component[1] == "heart") this.status.power += 2
                }
            },
			
			GLOBAL_onAddStatus: function({target, statusObj, originalEventTarget}) {
                if(
                    statusObj.origin != this.status.affecting ||
                    statusObj.slug != "hyperfocus_flat" ||
                    Math.random() > (0.1 * this.status.power)
                ) return;

                addStatus({target: originalEventTarget, origin: statusObj.origin, status: "evasion_mega", length: 1})
                                
                sendFloater({
                    target: this.status.affecting,
                    type: "arbitrary",
                    specialClass: "fate",
                    arbitraryString: "FATE::HEART",
                })
                
                setTimeout(()=>{
                    readoutAdd({
                        message: `${statusObj.origin.name} grants ${originalEventTarget.name} unnatural speed! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)                
            }
		},
		help: "per humor of heart in this shell::\n+10% chance to give 1T:UNNATURAL SPEED when giving allies TUNNEL VISION\n+1 max spectres"
	},
	
	env.STATUS_EFFECTS.fated_chaos = {
        slug: "fated_chaos",
        name: "FATED::Chaos",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_fated_chaos.gif",
        impulse: { type: "fated", component: "chaos" },
		outgoingCrit: 0,
		outgoingToHit: 0,
        
        events: {
            onCreated: function({statusObj}) {
                if(statusObj.slug != this.status.slug) return;
                
                this.status.power = 0
                if(this.status.affecting?.member?.components) for (const [slotName, slotContents] of Object.entries(this.status.affecting.member.components)) {
                    if(slotContents == "chaos") this.status.power++
                }

                if(this.status.affecting?.member?.augments) for (const augmentSlug of this.status.affecting.member.augments) {
                    let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]
                    if(augment?.component) if(augment.component[1] == "chaos") this.status.power += 2
                }

                this.status.outgoingCrit = 0.5 * this.status.power
				this.status.outgoingToHit = 0.5 * this.status.power
            },

            onHit: function({subject, origin, attack, beneficial}) {
                if(!this.status.power || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                
                addStatus({target: subject, origin, status: "vulnerable", length: this.status.power})
                
                sendFloater({
                    target: this.status.affecting,
                    type: "arbitrary",
                    specialClass: "fate",
                    arbitraryString: "FATE::CHAOS",
                })
                
                setTimeout(()=>{
                    readoutAdd({
                        message: `${origin.name} inflicts ${subject.name} with additional vulnerability! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "per humor of chaos in this shell::\n+1T:VULNERABLE on all attacks\n+50 outgoing hit%, crit% (after bonuses)"
    },
	
	env.STATUS_EFFECTS.fated_order = {
		slug: "fated_order",
		name: "FATED::Order",
		passive: true,
		beneficial: true,
		infinite: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_fated_order.gif",
		impulse: {type: "fated", component: "order"},
		events: {
			onCreated: function({statusObj}) {
                if(statusObj.slug != this.status.slug) return;
                
                this.status.power = 0
                if(this.status.affecting?.member?.components) for (const [slotName, slotContents] of Object.entries(this.status.affecting.member.components)) {
                    if(slotContents == "order") this.status.power++
                }

                if(this.status.affecting?.member?.augments) for (const augmentSlug of this.status.affecting.member.augments) {
                    let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]
                    if(augment?.component) if(augment.component[1] == "order") this.status.power += 2
                }
            },
			onTurn: function() {
                let user = this.status.affecting
                let shownNotice = false
                env.recentSfx = false
				let limiter = this.status.power - 1

				//for (let counter = 0; counter < this.status.power; counter++) {
					//setTimeout(()=>{
						env.GENERIC_ACTIONS.teamWave({
						team: user.team,
						exec: (actor, i) => {
							if(!hasStatus(actor, "order_detector") && hasStatus(actor, "ethereal") || hasStatus(actor, "player_ethereal")) { // this is ugly as fuck but it should work
								env.GENERIC_ACTIONS.singleTarget({
									action: env.ACTIONS['order_modify'], 
									user, 
									target: actor,
									hitSfx: { name: 'talkcroak', rate: 1.5, volume: 0.5 },
									genExec: ()=>{
										env.ACTIONS['order_modify'].exec(user, target) // this is probably wayyy simpler than what i was doing before :P
										/*
										if(counter == limiter) {
											setTimeout(()=> {
												addStatus({target, origin: this.status.affecting, status: "order_detector", length: 1}); 
												console.log('counter == limiter, adding order_detector')
											}, 51 + 50 * limiter)
										}
										*/
										if(!shownNotice) {
											sendFloater({
												target: actor,
												type: "fate",
												arbitraryString: "FATE::ORDER",
											})

											readoutAdd({
												message: `${user.name} modifies all summoned allies (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
												name: "sourceless", 
												type: "sourceless combat minordetail", 
												show: false,
												sfx: false
											})
											shownNotice = true
										}
									},
									/*hitExec: ({user, target})=> {
										env.ACTIONS['order_modify'].exec(user, target)
									}*/
								})
							}
						}
					})
					//}, 50 + 50 * counter)
				//}
            },
		},
		help: "per humor of order in this shell::\n+1 max daemons\nsummoned allies receive +1 random beneficial impulses (NOTICE::affected by redirection due to system limitations)"
	}
if(check("cmb_unlocked")) {
	env.STATUS_EFFECTS.fated_cmb = {
        slug: "fated_cmb",
        name: "FATED::Palestone",
        passive: true,
        beneficial: true,
        icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_fated_order.gif",
        impulse: { type: "fated", component: "cmb" },
		outgoingCrit: 0,
		outgoingToHit: 0,
        
        events: {
            onCreated: function({statusObj}) {
                if(statusObj.slug != this.status.slug) return;
                
                this.status.power = 0
                if(this.status.affecting?.member?.components) for (const [slotName, slotContents] of Object.entries(this.status.affecting.member.components)) {
                    if(slotContents == "cmb") this.status.power++
                }

                if(this.status.affecting?.member?.augments) for (const augmentSlug of this.status.affecting.member.augments) {
                    let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]
                    if(augment?.component) if(augment.component[1] == "cmb") this.status.power += 2
                }
            },

            onHit: function({subject, origin, attack, beneficial}) {
                if(!this.status.power || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                
                addStatus({target: subject, origin, status: "burning", length: this.status.power})
                
                sendFloater({
                    target: this.status.affecting,
                    type: "arbitrary",
                    specialClass: "fate",
                    arbitraryString: "FATE::PALESTONE",
                })
                
                setTimeout(()=>{
                    readoutAdd({
                        message: `${origin.name} inflicts ${subject.name} with additional chemical fire! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.1)
				
				if(Math.random() > (0.1 * this.status.power)) return;
                
                addStatus({target: subject, origin, status: "vulnerable_mega", length: 2})
                addStatus({target: subject, origin, status: "fatal_flaw", length: 1})
                
                setTimeout(()=>{                
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "fate",
                        arbitraryString: "FATE::PALESTONE",
                    })

                    readoutAdd({
                        message: `${origin.name} inflicts ${subject.name} with hypervulnerability! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: "per humor of palestone in this shell::\n+1T:CHEMICAL FIRE on all attacks\n+10% chance on hit to inflict +2T:HYPERVULNERABLE and +FATAL FLAW"
    }
}
	
	env.ACTIONS.order_modify = {
        slug: "order_modify",
        name: "Modify",
        type: 'target',
        desc: "'strike against analyzed weakness'",
        anim: "basic-attack",
        help: "AUTOHIT -1HP, 10%C x2",
		possiblePassives: ['attack_drone', 'retaliation', 'ichor_last_stand', 'impatient', 'spotter', 'claws_chitin', 'eyes_dancer', 'ichor_finisher', 'bone_adaptive', 'bone_shield', 'light_veilkdrop', 'bone_spikes', 'bone_ablative', 'ichor_strength', 'claws_infection', 'claws_desperation', 'eyes_woundedego', 'light_laughterhouse', 'light_dark', 'flesh_adrenaline', 'flesh_terminallucidity', 'flesh_hysteria', 'flesh_fightorflight', 'dull_hypervelocity', 'dull_highenergy', 'dull_multitool', 'spirestone_berserk', 'spirestone_rebound', 'spirestone_carapace', 'hands_heal', 'hands_trial', 'hands_damnation', 'hands_allseeing', 'hands_daemon', 'metal_drone', 'metal_adaptive', 'metal_disable', 'metal_explode', 'pain_terror', 'pain_strength', 'pain_masochist', 'pain_secri', 'lightning_veilktouch', 'lightning_storm', 'lightning_selfglee', 'lightning_terror', 'lightning_faterender', 'heart_affliction', 'heart_mutual', 'heart_desperation', 'heart_adaptive', 'heart_carapace', 'chaos_discombobulate', 'chaos_badsport', 'chaos_adaptive', 'chaos_retry', 'chaos_backup', 'chaos_infection', 'order_power', 'order_item', 'order_backdoor', 'order_zeroday', 'order_imp', 'metal_autonomous', 'pain_rampage', 'lightning_kugelblitz', 'order_override', 'zuka_vengeance', 'zuka_grail', 'zuka_finisher', 'zuka_iconoclasm', 'zuka_ind', 'zuka_intimidation', 'zuka_unstoppable'],
        usage: {
            act: "%USER MODIFIES %TARGET",
        },
        autohit: true,
		canCrit: false,
		beneficial: true,
        exec: function(user, target) {
			let fated = user.statusEffects.find(status => status.slug == "fated_order")
			let power = fated.power
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'talkcroak',
                    rate: 1.5
                },
				hitExec: ({user, target})=> { // note to self::check for if the target has a secondary and utility here, and push secondary/utility using action impulses if they do
					if(target.actions.length > 1) (this.possiblePassives.push('active_support', 'dull_pragmatist'))
					if(target.actions.length > 2) (this.possiblePassives.push('visionary', 'flesh_menace', 'spirestone_parry', 'hands_penance', 'chaos_locknload'))
					for (let counter = 0; counter < power; counter++) {
						addStatus({target, origin: user, status: this.possiblePassives.sample(), length: 1});
					}
					setTimeout(()=>{
						addStatus({target, origin: user, status: 'order_detector', length: 1});
					}, 200)
				}
            })
        }
    },
	
	env.ACTIONS.special_zuka_explode = {
        slug: "special_zuka_explode",
        name: "Explode",
        type: 'special',
        desc: "'form shrapnel in body';'propel through unsustainable means'",
        help: "FOES::50% -1HP, 2.5%C x2 +2T:PUNCTURE",
        anim: "explode",
		itemAction: true, // imps, my beloathed
        autohit: true,
		canCrit: false,
        amt: 1,
        usage: {
            act: "%USER EXPLODES!"
        },
        exec: function(user, beingUsedAsync) {
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
				extraDelay: 1,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action: action, 
                        user, 
                        target: actor,
                        hitSfx: { name: 'shot2' },
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.STATUS_EFFECTS.fated_zuka = {
		slug: "fated_zuka",
		name: "FATED::Zuka",
		passive: true,
		beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_fated_flesh.gif",
		impulse: {type: "fated", component: "zuka"},
		events: {
            onCreated: function({statusObj}) {
                if(statusObj.slug != this.status.slug) return;
                
                this.status.power = 0
                if(this.status.affecting?.member?.components) for (const [slotName, slotContents] of Object.entries(this.status.affecting.member.components)) {
                    if(slotContents == "zuka") this.status.power++
                }

                if(this.status.affecting?.member?.augments) for (const augmentSlug of this.status.affecting.member.augments) {
                    let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]
                    if(augment?.component) if(augment.component[1] == "zuka") this.status.power += 2
                }
                
            },
			
			onHit: function({subject, origin, attack, beneficial}) {
				let rand = Math.random()
				if(!this.status.power || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || rand > (0.01 * this.status.power) ) return;
				let user = origin // this should be fine
                
                useAction(this.status.affecting, env.ACTIONS.special_zuka_explode, user, {beingUsedAsync: true, reason: "FATE::ZUKA"})
                
                sendFloater({
                    target: this.status.affecting,
                    type: "arbitrary",
                    specialClass: "fate",
                    arbitraryString: "FATE::ZUKA",
                })
                
                setTimeout(()=>{
                    readoutAdd({
                        message: `${origin.name} explodes!! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            },
			
			onTurn: function() {
				if(hasStatus(this.status.affecting,"windup")) (this.status.outgoingFlat = 1 * this.status.power);
				else this.status.outgoingFlat = 0
			}
		},
		help: "per humor of zuka in this shell::\n+1 base outgoing damage while under WINDUP\n+1% chance to explode on all attacks"
	},
	
	env.STATUS_EFFECTS.fated_hook = {
		slug: "fated_hook",
		name: "FATED::Hook",
		passive: true,
		beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_fated_heart.gif",
		impulse: {type: "fated", component: "hook"},
		events: {
            onCreated: function({statusObj}) {
                if(statusObj.slug != this.status.slug) return;
                
                this.status.power = 0
                if(this.status.affecting?.member?.components) for (const [slotName, slotContents] of Object.entries(this.status.affecting.member.components)) {
                    if(slotContents == "hook") this.status.power++
                }

                if(this.status.affecting?.member?.augments) for (const augmentSlug of this.status.affecting.member.augments) {
                    let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]
                    if(augment?.component) if(augment.component[1] == "hook") this.status.power += 2
                }
                
            },
			
			onHit: function({subject, origin, attack, beneficial}) {
                if(!this.status.power || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                if(Math.random() > (0.1 * this.status.power)) return;
                let rand = Math.random()
                let status
                if(rand < 0.3) {
                    addStatus({target: subject, origin, status: "puncture", length: 2})
					addStatus({target: subject, origin, status: "open_wound", length: 2})
                    status = "puncture and open wound"
                } else if(rand < 0.6) {
                    addStatus({target: subject, origin, status: "agony", length: 1})
                    status = "agony"
                } else {
                    addStatus({target: subject, origin, status: "stun", length: 1})
                    status = "stun" 
                }
                setTimeout(()=>{
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "fate",
                        arbitraryString: "FATE::HOOK",
                    })
                    
                    readoutAdd({
                        message: `${origin.name} inflicts ${subject.name} with ${status}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
		},
		help: "per humor of hook in this shell::\n+10% chance to apply +2T:PUNCTURE +2T:OPEN WOUND/+1T:STUN/+AGONY when hitting a foe\n+1 agony effectiveness"
	},
	
	env.STATUS_EFFECTS.fated_spine = {
		slug: "fated_spine",
		name: "FATED::Spine",
		passive: true,
		beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_fated_order.gif",
		impulse: {type: "fated", component: "spine"},
		events: {
            onCreated: function({statusObj}) {
                if(statusObj.slug != this.status.slug) return;
                
                this.status.power = 0
                if(this.status.affecting?.member?.components) for (const [slotName, slotContents] of Object.entries(this.status.affecting.member.components)) {
                    if(slotContents == "spine") this.status.power++
                }

                if(this.status.affecting?.member?.augments) for (const augmentSlug of this.status.affecting.member.augments) {
                    let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]
                    if(augment?.component) if(augment.component[1] == "spine") this.status.power += 2
                }
                
            },
			
			onHit: function({subject, origin, attack, beneficial}) {
                if(!this.status.power || beneficial || origin.team.members.includes(subject) || origin.state == "dead" || subject.state == "dead") return;
                if(Math.random() > (0.1 * this.status.power)) return;
                let rand = Math.random()
                let status
                if(rand < 0.3) {
                    addStatus({target: subject, origin, status: "destabilized", length: 2})
                    status = "destabilized"
                } else if(rand < 0.6) {
                    addStatus({target: subject, origin, status: "open_wound", length: 2})
                    status = "open wound"
                } else {
                    addStatus({target: subject, origin, status: "weakened", length: 2})
                    status = "weakened"
                }
                setTimeout(()=>{
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "fate",
                        arbitraryString: "FATE::SPINE",
                    })
                    
                    readoutAdd({
                        message: `${origin.name} inflicts ${subject.name} with ${status}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
		},
		help: "per humor of spine in this shell::\n+10% chance to apply +2T:DESTABILIZED/+2T:OPEN WOUND/+2T:WEAKENED when hitting a foe\n+1 max angels"
	},

    env.STATUS_EFFECTS.hardened = { 
        slug: "hardened",
        name: "Hardened",
		outgoingToHit: 1,
		outgoingCrit: 2,
		outgoingFlat: 1,
        help: "+100% outgoing hit%, +200% outgoing crit% and +1 outgoing base damage/heal while BP > 0\nremoves weakened\nremoved upon barrier loss",
		icon: "https://corru.observer/img/sprites/combat/statuses/repairs.gif",
        infinite: true,
        beneficial: true,
		opposite: "fractalline",
		removes: ["fractalline"],
        
        events: {
            onTurn: function() {
				let hardened = env.rpg.turnOrder.filter(actor=>hasStatus(actor, "hardened"))
                console.log('in hardened')
                if(this.status.affecting.bp > 0) {
					hardened.forEach(actor => {
						reactDialogue(this.status.affecting, 'regen');
						removeStatus(this.status.affecting, "weakened")
						play('guard', 0.5);
					} )
					updateStats({actors: hardened})
                } else {
					hardened.forEach(actor => {
						console.log('removing hardened', this.status.affecting.bp)
						removeStatus(this.status.affecting, "hardened")
					} )
					updateStats({actors: hardened})
                }
            },

            onCombatHit: function() {
				let hardened = env.rpg.turnOrder.filter(actor=>hasStatus(actor, "hardened"))
                console.log('in hardened damage', this.status.affecting.bp)
                if(this.status.affecting.bp <= 0) {
                    console.log('removing hardened')
					hardened.forEach(actor => {
						removeStatus(this.status.affecting, "hardened")
						updateStats({actors: hardened})
					} )
                }
            },
		}
    },

    env.STATUS_EFFECTS.fractalline = { 
        slug: "fractalline",
        name: "Fractalline",
        help: "+2T:WEAKENED/turn while BP > 0\nremoved upon barrier loss",
        infinite: true,
		icon: "https://corru.observer/img/sprites/combat/statuses/million_teeth.gif",
        opposite: "hardened",
        removes: ["hardened"],
        
        events: {
            onTurn: function() {
                if(this.status.affecting.bp > 0) {
                    addStatus({target: this.status.affecting, origin: false, status: "weakened", length: 2}); 
                    play('croak', 0.5);
                } else {
                    removeStatus(this.status.affecting, "fractalline")
                }
            },

            onCombatHit: function() {
                if(this.status.affecting.bp <= 0) {
                    removeStatus(this.status.affecting, "fractalline")
                }
            },
        }
    },

    env.STATUS_EFFECTS.favored = { 
        slug: "favored",
        name: "Favored",
        outgoingToHit: 0.75,
        outgoingCrit: 2,
		incomingToHit: -0.5,
		incomingCrit: -0.5,
        beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/amber_favoredstatusborderless.png",
		tickType: "onTurnEnd",
        events: {
            onTurn: function() { reactDialogue(this.status.affecting, 'focused') },
        },
        help: "+75% hit%, +200% crit%, -50% incoming hit%, crit%",
        removes: ["cursed"],
        opposite: "cursed"
    },

    env.STATUS_EFFECTS.cursed = { 
        slug: "cursed",
        name: "Cursed",
        incomingToHit: 0.75,
        incomingCrit: 2,
		outgoingToHit: -0.5,
		outgoingCrit: -0.5,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/cursedstatus2_amber.png",
		tickType: "onTurnEnd",
        help: "+75% incoming hit%, +200% incoming crit%, -50% outgoing hit%, crit%",
        removes: ["favored"],
        opposite: "favored"
    },

	env.STATUS_EFFECTS.infallible = {
		slug: "infallible",
		name: "Infallible",
		help: "actor is immune to stun, fear, and weakened\nremoved upon focused loss",
		infinite: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_infallible.gif",
		
		events: {
			onBeforeAction: function(context) {
                if(!hasStatus(this.status.affecting, "focused")) {
                    removeStatus(this.status.affecting, "infallible")
                    return
                }
			},
			
			onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "focused") removeStatus(this.status.affecting, "infallible")
            },
		
			onTurn: function() {
					if(!this.status.affecting.minotaursMazeContingencyPlan) {
						if(!this.status.affecting.statusImmunities) {
							this.status.affecting.statusImmunities = ["stun", "fear", "weakened"]; //the game will shit itself if you add an immunity to someone who doesnt have them defined, so we define them here if they dont have any
							this.status.affecting.minotaursMazeContingencyPlan = true //surprise tool that will help us later
						} else if(!this.status.affecting.statusImmunities.includes("stun")) { //if they arent already immune to stun, makes them
							this.status.affecting.statusImmunities.push("stun", "fear", "weakened")
							this.status.affecting.minotaursMazeContingencyPlan = true
						}
					}
				updateStats({actor: this.status.affecting})
			} 
		}
	},
	
	env.STATUS_EFFECTS.chosen = {
		slug: "chosen",
		name: "Chosen",
		help: "+75% hit%, +200% crit%, -45% incoming hit%, crit%, +100% outgoing damage/heal\nremoved upon favored loss",
		outgoingToHit: 0.75,
        outgoingCrit: 2,
		incomingToHit: -0.45,
		incomingCrit: -0.45,
		outgoingMult: 1,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_chosen.gif",
		infinite: true,
		removes: ["forsaken"],
		opposite: "forsaken",
		
		events: {
			onBeforeAction: function(context) {
                if(!hasStatus(this.status.affecting, "favored")) {
                    removeStatus(this.status.affecting, "chosen")
                    return
                }
			},
			
			onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "favored") removeStatus(this.status.affecting, "chosen")
            },
		}
	},
	
	env.STATUS_EFFECTS.forsaken = {
		slug: "forsaken",
		name: "Forsaken",
		help: "+75% incoming hit%, +200% incoming crit%, -45% outgoing hit%, crit%, +100% incoming damage/heal\nremoved upon cursed loss",
		incomingToHit: 0.75,
        incomingCrit: 2,
		outgoingToHit: -0.45,
		outgoingCrit: -0.45,
		incomingMult: 1,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_forsaken.gif",
		infinite: true,
		removes: ["chosen"],
		opposite: "chosen",
		
		events: {
			onBeforeAction: function(context) {
                if(!hasStatus(this.status.affecting, "cursed")) {
                    removeStatus(this.status.affecting, "forsaken")
                    return
                }
			},
			
			onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "cursed") removeStatus(this.status.affecting, "forsaken")
            },
		}
	},

    env.ACTIONS.amplifier_attack = {
        slug: "amplifier_attack",
        name: "Broadcast",
        type: 'target',
        desc: "'directly seize control of corrucystic organs';'chance to utilize target as signal amplifier'",
        anim: "wobble",
        help: "75% -2HP +1T:PUNCTURE, 30%C x2 +1T:PUNCTURE + (TARGET TEAM::-1HP +2T:VULNERABLE)",
        usage: {
            act: "%USER WARPS STRANGELY",
            crit: "%TARGET'S TEAM FEELS ILL",
            hit: "%TARGET'S FLESH REVOLTS",
            miss: "%TARGET RECOILS SAFELY"
        },
        accuracy: 0.75,
        crit: 0.3,
        amt: 2,
        exec: function(user, target) {
            content.classList.add('painprep', 'painhalf')
            setTimeout(()=>{content.classList.add('painmode')}, 100)
            setTimeout(()=>{content.classList.remove('painmode')}, 2000)
            setTimeout(()=>{content.classList.remove('painprep', 'painhalf')}, 3000)

            env.rpg.classList.remove('incoherentbg')

            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitStatus: {name: 'puncture', length: 1}, 
				critStatus: {name: 'puncture', length: 1},
                
                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: target.team,
                    exec: (actor, i)=>{
                        combatHit(actor, {amt: 1, crit: 0, autohit: true, origin: user});
                        addStatus({target: actor, status: "vulnerable", length: 2}); 
                        play("talksignal", 0.75)
                    }
                })
            })
        }
    },

	env.STATUS_EFFECTS.hands_malfunction = { 
		slug: "hands_malfunction",
		name: "Amplifier",
		help: "all targeted actions have a 10% + (5%*T:VULNERABLE) chance to become BROADCAST\nBROADCAST::(75% -2HP +1T:PUNCTURE, 30%C x2 +1T:PUNCTURE + (TARGET TEAM::-1HP +2T:VULNERABLE))\nremoved on vulnerable loss",
		beneficial: false,
		infinite: true,
		icon: "https://corru.observer/img/sprites/combat/statuses/critical_flaw.gif",
		
		events: {
			onBeforeAction: function(context) {
				if(!context.settings.action.type.includes("target")) return;
				let pow = hasStatus(this.status.affecting, "vulnerable");
				if(!hasStatus(this.status.affecting, "vulnerable")) {
                    removeStatus(this.status.affecting, "hands_malfunction")
                    return
                }
				
				// alter action maybe
				if(Math.random() < (0.10 + (pow * 0.05))) {

					context.settings.action = env.ACTIONS["amplifier_attack"]
					let subject = context.settings.user

					sendFloater({
						target: subject,
						type: "arbitrary",
						arbitraryString: "AMPLIFIER!",
						isGood: false,
						size: 2,
					})

					readoutAdd({
						message: `${subject.name} is siezed by the signal! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
						name: "sourceless", 
						type: "sourceless combat minordetail",
						show: false,
						sfx: false
					})
				}
			},
			onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "vulnerable") removeStatus(this.status.affecting, "hands_malfunction")
            },
		}
	}

    env.STATUS_EFFECTS.joy = { 
        slug: "joy",
        name: "Joy",
        beneficial: true,
        infinite: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/amber_joystatusgood2.png",
        events: {
            onTurn: function() { 
                reactDialogue(this.status.affecting, 'surge') 
                delete this.status.justGotSurge
            },
            
            onAction: function({user, action, target, beingUsedAsync}) {
                if(this.status.justGotSurge || beingUsedAsync || ["incoherent_", "steer", "floor", "windup", "intrusive"].some(slugpart => action.slug.includes(slugpart))) return;
                
                setTimeout(()=>{
            
                    sendFloater({
                        target: user,
                        type: "arbitrary",
                        arbitraryString: "JOY!",
                    })

                    readoutAdd({
                        message: `${user.name} acts again! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })

                    useAction(user, action, target, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "joy"})
                }, 500)
            },

            onCreated: function({statusObj}) {
                if(statusObj.slug == this.status.slug) this.status.justGotSurge = true
            },
			onBeforeAction: function(context) {
                if(!hasStatus(this.status.affecting, "focused")) {
                    removeStatus(this.status.affecting, "joy")
                    return
                }
			},
			
			onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "focused") removeStatus(this.status.affecting, "joy")
            },
        },
        help: "use next active action twice\nremoved on focused loss"
    },

	env.ACTIONS.stumble = {
		slug: "stumble",
		name: "Stumble",
		type: 'autohit',
		desc: "'suffer from despair'",
		anim: "skitter",
		help: "-2HP, +1T:STUN",
		usage: {
			act: "%USER CAN ONLY WEEP"
		},
		acc: 100,
		crit: -1,
		exec: function(user, target) {
			combatHit(user, {amt: 2, acc: this.accuracy, crit: this.crit, origin: user})
			addStatus({target: user, status: "stun", length: 1, noReact: true}); 
			advanceTurn(user)
			return 'nothing';
		}
	}

	env.STATUS_EFFECTS.despair_malfunction = { 
		slug: "despair_malfunction",
		name: "Despair",
		help: "all actions have a 50% chance to become STUMBLE\nSTUMBLE::(SELF:: -2HP, +1T:STUN)\nremoved on fear loss",
		beneficial: false,
		infinite: true,
		icon: "https://corru.observer/img/sprites/combat/statuses/madness.gif",
		
		events: {
			onBeforeAction: function(context) {
				
				if(!hasStatus(this.status.affecting, "fear")) {
                    removeStatus(this.status.affecting, "despair_malfunction")
                    return
                }
				
				// alter action maybe
				if(Math.random() < (0.50)) {

					context.settings.action = env.ACTIONS["stumble"]
					let subject = context.settings.user

					sendFloater({
						target: subject,
						type: "arbitrary",
						arbitraryString: "DESPAIR!",
						isGood: false,
						size: 2,
					})

					readoutAdd({
						message: `${subject.name} falls to the ground! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
						name: "sourceless", 
						type: "sourceless combat minordetail",
						show: false,
						sfx: false
					})
				}
			},
			
			onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "fear") removeStatus(this.status.affecting, "despair_malfunction")
            },
		}
	}
	
	env.STATUS_EFFECTS.winderup = {
        slug: "winderup",
        name: "Windup+",
        help: "+200% incoming crit, preparing very powerful action, interrupted by stun",
        beneficial: true,
        incomingCrit: 2,
        infinite: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_winderup.png",
        enableWindup: true,
		
		events: {
			onAddStatus: function({statusObj}) {
                if(statusObj.skipTurn) removeStatus(this.status.affecting, "winderup")
            },
		},
    }
	
	env.STATUS_EFFECTS.windestup = {
        slug: "windestup",
        name: "Windup++",
        help: "+300% incoming crit, preparing extremely powerful action, interrupted by stun",
        beneficial: true,
        incomingCrit: 3,
        infinite: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_windestup.png",
        enableWindup: true,
		
		events: {
			onAddStatus: function({statusObj}) {
                if(statusObj.skipTurn) removeStatus(this.status.affecting, "windestup")
            },
		},
    }
	
	env.STATUS_EFFECTS.final_windup = {
        slug: "final_windup",
        name: "Windup+++",
        help: "+400% incoming crit, preparing devastating action, interrupted by stun",
        beneficial: true,
        incomingCrit: 4,
        infinite: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_windupfinal.png",
        enableWindup: true,
		
		events: {
			onAddStatus: function({statusObj}) {
                if(statusObj.skipTurn) removeStatus(this.status.affecting, "final_windup")
            },
		},
    }

	env.STATUS_EFFECTS.chitinous = {
        slug: "chitinous",
        name: "Chitinous",
        help: "return 50% incoming damage to attacker (min: 1) and -1 base incoming damage/heal while bp > 0\nremoves open wound and siphon\nremoved on barrier loss",
        beneficial: true,
		infinite: true,
		incomingFlat: -1,
		opposite: "porous",
        removes: ["porous"],
		icon: "https://corru.observer/img/sprites/combat/statuses/spikes.gif",
        events: {
			onTurn: function() {
				let chitinous = env.rpg.turnOrder.filter(actor=>hasStatus(actor, "chitinous"))
                console.log('in chitinous')
                if(this.status.affecting.bp > 0) {
					chitinous.forEach(actor => {
						reactDialogue(this.status.affecting, 'regen');
						removeStatus(this.status.affecting, "open_wound")
						removeStatus(this.status.affecting, "siphon")
						play('mend', 0.5);
					} )
					updateStats({actors: chitinous})
                } else {
					chitinous.forEach(actor => {
						console.log('removing chitinous', this.status.affecting.bp)
						removeStatus(this.status.affecting, "chitinous")
					} )
					updateStats({actors: chitinous})
                }
            },

            onCombatHit: function() {
				let chitinous = env.rpg.turnOrder.filter(actor=>hasStatus(actor, "chitinous"))
                console.log('in chitinous damage', this.status.affecting.bp)
                if(this.status.affecting.bp <= 0) {
                    console.log('removing chitinous')
					chitinous.forEach(actor => {
						removeStatus(this.status.affecting, "chitinous")
						updateStats({actors: chitinous})
					} )
                }
            },
			
            onStruck: function({subject, attack, beneficial}) { 
                if(beneficial) return;
				let fated = this.status.affecting.statusEffects.find(status => status.slug == "fated_bone")
                let returnDmg = Math.max(Math.floor(attack * 0.5), fated ? fated.power + 1 : 1)

                setTimeout(()=>{
                    sendFloater({
                        target: subject,
                        type: "arbitrary",
                        arbitraryString: "CHITINOUS!",
                        isGood: false,
                        size: 1,
                    })

                    readoutAdd({
                        message: `${subject.name} receives ${Math.abs(returnDmg)} damage via <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })

                    forcePlay("stab", 0.7, 0.8)
                    combatHit(subject, {amt: returnDmg, autohit: true, crit: 0, origin: false, redirectable: false})
                }, env.ADVANCE_RATE * 0.2)
            },
        }
    }
	
	env.STATUS_EFFECTS.porous = { 
        slug: "porous",
        name: "Porous",
        help: "+2T:SIPHON, +2T:OPEN WOUND/turn while BP > 0\nremoved upon barrier loss",
        infinite: true,
		icon: "https://corru.observer/img/sprites/combat/statuses/million_teeth.gif",
        opposite: "chitinous",
        removes: ["chitinous"],
        
        events: {
            onTurn: function() {
                if(this.status.affecting.bp > 0) {
                    addStatus({target: this.status.affecting, origin: false, status: "siphon", length: 2}); 
					addStatus({target: this.status.affecting, origin: false, status: "open_wound", length: 2}); 
                    play('stab', 0.75);
                } else {
                    removeStatus(this.status.affecting, "porous")
                }
            },

            onCombatHit: function() {
                if(this.status.affecting.bp <= 0) {
                    removeStatus(this.status.affecting, "porous")
                }
            },
        }
    }
	
	env.STATUS_EFFECTS.denatured = { 
        slug: "denatured",
        name: "Denatured",
        incomingMult: 2,
        outgoingMult: 2,
        beneficial: true,
        tickType: "onTurnEnd",
		//opposite: "intangible",
		icon: "https://corru.observer/img/sprites/combat/statuses/destabilized.gif",
		removes: ["destabilized"],
        
        events: {
            onTurn: function() { reactDialogue(this.status.affecting, 'destabilized') },
			onCreated: function() { reactDialogue(this.status.affecting, 'receive_destabilized') },
        },

        help: "+200% incoming/outgoing damage/heal",
    }
	
	if(env.STATUS_EFFECTS.numb) {
		env.STATUS_EFFECTS.denatured.opposite = "intangible"
		env.STATUS_EFFECTS.denatured.removes.push("intangible")
	}
	
	env.STATUS_EFFECTS.intangible = { 
        slug: "intangible",
        name: "Intangible",
        incomingMult: -1,
        outgoingMult: -1,
        beneficial: false,
        tickType: "onTurnEnd",
		opposite: "denatured",
		icon: "https://adrfurret.neocities.org/corrumods/img/sprites/combat/statuses/numb.gif",
		removes: ["destabilized", "denatured"],
        
        events: {
            onTurn: function() { reactDialogue(this.status.affecting, 'stun') },
        },

        help: "-100% incoming/outgoing damage/heal",
    }

	env.STATUS_EFFECTS.serrations = {
        slug: "serrations",
        name: "Serrations",
        help: "return 100% incoming damage to attacker, min:1",
        beneficial: true,
		icon: "https://corru.observer/img/sprites/combat/statuses/spikes.gif",
		opposite: "siphon_mega",
        removes: ["siphon", "spikes", "siphon_mega"],
        events: {
            onStruck: function({subject, attack, beneficial}) { 
                if(beneficial) return;
                let fated = this.status.affecting.statusEffects.find(status => status.slug == "fated_bone")
                let returnDmg = Math.max(Math.floor(attack), fated ? fated.power + 1 : 1)

                setTimeout(()=>{
                    sendFloater({
                        target: subject,
                        type: "arbitrary",
                        arbitraryString: "SERRATED!",
                        isGood: false,
                        size: 1,
                    })

                    readoutAdd({
                        message: `${subject.name} receives ${Math.abs(returnDmg)} damage via <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })

                    forcePlay("stab", 0.6, 0.7)
                    combatHit(subject, {amt: returnDmg, autohit: true, crit: 0, origin: false, redirectable: false})
                }, env.ADVANCE_RATE * 0.2)
            },
        }
    }

    env.STATUS_EFFECTS.siphon_mega = {
        slug: "siphon_mega",
        name: "Veilkfruit",
        help: "attacker receives 2HP, +2T:REGEN",
		icon: "https://corru.observer/img/sprites/combat/statuses/siphon.gif",
        opposite: "serrations",
        removes: ["spikes", "serrations", "siphon"],
        events: {
            onStruck: function({subject, attack}) {
                if(subject.state == "dead") return;

                let amt = 2 * (-1 - (hasStatus(this.status.affecting, "global_escalation") ? env.crittaMap.getModQty("global_escalation") || 0 : 0))
            
                sendFloater({
                    target: subject,
                    type: "arbitrary",
                    arbitraryString: "VEILKFRUIT!",
                })
                
                readoutAdd({
                    message: `${subject.name} receives +${amt}HP +2T:REGEN via <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail",
                    show: false,
                    sfx: false
                })

                addStatus({target: subject, origin: false, status: "regen", length: 2, noReact: true}); 
                combatHit(subject, {amt, autohit: true, crit: 0, origin: false, beneficial: true})
            },
        }
    }
	
	env.STATUS_EFFECTS.puppet = {
		slug: "puppet",
		name: "Puppet",
		help: "[[ORIGIN]] puppeteering outgoing actions\nall targeted offensive actions redirected towards a random ally, all targeted beneficial actions redirected towards a random foe\non turn, receive +1T:FEAR\nremoved on fear loss",
		infinite: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/amber_puppetstatusborderless.png",
		
		events: {
            onBeforeAction: function(context) {
                if(!hasStatus(this.status.affecting, "fear")) {
                    removeStatus(this.status.affecting, "puppet")
                    return
                }

                if(!context.settings.action.type.includes("target")) return;
                
                // alter target maybe
                if(Math.random() < 1) {
                    //select from whole turnorder
                    let subject = context.user
                    let oldTarget = context.settings.target
                    let newTarget = this.status.affecting.team.members.filter(actor=>actor.state != "dead" && actor.state != "lastStand" && actor.slug != oldTarget.slug)
					if(context.settings.action.beneficial) {
						newTarget = this.status.affecting.enemyTeam.members.filter(actor=>actor.state != "dead" && actor.state != "lastStand" && actor.slug != oldTarget.slug)
					}
                    if(newTarget.length) {
                        newTarget = newTarget.sample()
                    } else return;

                    console.log("old target was", context.settings.target, "new target is", newTarget)

                    context.settings.target = newTarget

                    sendFloater({
                        target: subject,
                        type: "arbitrary",
                        arbitraryString: "PUPPET!",
                        isGood: false,
                        size: 1.5,
                    })

                    readoutAdd({
                        message: `${subject.name}'s action upon ${oldTarget.name} is turned to ${newTarget.name}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }
            },

            onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "fear") removeStatus(this.status.affecting, "puppet")
            },
			
			onTurn: function() {
				addStatus({target: this.status.affecting, origin: false, status: "fear", length: 1});
			},
        }
	},
	
	env.STATUS_EFFECTS.puppet_mega = {
		slug: "puppet_mega",
		name: "Host Body",
		help: "[[ORIGIN]] assuming direct control\non turn, receive +1T:STUN\nremoved on fear loss",
		infinite: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/amber_hostbodystatusborderless.png",
		
		events: {
            onBeforeAction: function(context) {
                if(!hasStatus(this.status.affecting, "fear")) {
                    removeStatus(this.status.affecting, "puppet_mega")
                    return
                }

                if(!context.settings.action.type.includes("target")) return;
                
                // alter target maybe
                if(Math.random() < 1) {
                    //select from whole turnorder
                    let subject = context.user
                    let oldTarget = context.settings.target
                    let newTarget = this.status.affecting.team.members.filter(actor=>actor.state != "dead" && actor.state != "lastStand" && actor.slug != oldTarget.slug)
					if(context.settings.action.beneficial) {
						newTarget = this.status.affecting.enemyTeam.members.filter(actor=>actor.state != "dead" && actor.state != "lastStand" && actor.slug != oldTarget.slug)
					}
                    if(newTarget.length) {
                        newTarget = newTarget.sample()
                    } else return;

                    console.log("old target was", context.settings.target, "new target is", newTarget)

                    context.settings.target = newTarget

                    sendFloater({
                        target: subject,
                        type: "arbitrary",
                        arbitraryString: "PUPPET!",
                        isGood: false,
                        size: 1.5,
                    })

                    readoutAdd({
                        message: `${subject.name}'s action upon ${oldTarget.name} is turned to ${newTarget.name}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }
            },

            onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "fear") removeStatus(this.status.affecting, "puppet_mega")
            },
			
			onTurn: function() {
				addStatus({target: this.status.affecting, origin: false, status: "stun", length: 1});
			},
        }
	},
	
	env.STATUS_EFFECTS.puppet_conjoined = {
        slug: "puppet_conjoined",
        name: "Husked",
        help: "share HP with all other husked entities",
        infinite: true,
        beneficial: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/amber_huskedstatusborderless.png",
        events: {
            onCombatHit: function() {
                console.log('in player_conjoindamage', this.status.affecting.hp)
                if(!this.status.affecting.hp || this.status.affecting.hp == NaN) this.status.affecting.hp = 0;

                let puppet_conjoined = env.rpg.turnOrder.filter(actor=>hasStatus(actor, "puppet_conjoined"))
                puppet_conjoined.forEach(actor => {
                    actor.hp = this.status.affecting.hp
                })

                updateStats({actors: puppet_conjoined})
            },
        }
    },
	
	env.ACTIONS.nothing_prone = {
        slug: "nothing_prone",
        name: "Get Up",
        type: 'autohit',
        desc: "'just nothing'",
        anim: "skitter",
        help: "NOTHING",
        usage: {
            act: "%USER TRIES TO GET UP"
        },
        exec: function(user, target) {
            advanceTurn(user)
        }
    },
	
	env.STATUS_EFFECTS.prone = { 
		slug: "prone",
		name: "Prone",
		help: "50% chance to skip turn",
		beneficial: false,
		tickType: "onTurnEnd",
		icon: "https://corru.observer/img/sprites/combat/statuses/weakened.gif",
		
		events: {
			onBeforeAction: function(context) {
				// alter action maybe
				if(Math.random() < (0.50)) {

					context.settings.action = env.ACTIONS["truly_nothing"]
					let subject = context.settings.user

					sendFloater({
						target: subject,
						type: "arbitrary",
						arbitraryString: "PRONE!",
						isGood: false,
						size: 1,
					})

					readoutAdd({
						message: `${subject.name} cannot fight in this state! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
						name: "sourceless", 
						type: "sourceless combat minordetail",
						show: false,
						sfx: false
					})
				}
			},
		}
	}
	
    env.STATUS_EFFECTS.blindness = {
        slug: "blindness",
        name: "Blindness",
        help: "outgoing targeted actions are redirected to a random actor\nremoved upon fear loss",
        infinite: true,
		icon: "https://corru.observer/img/sprites/combat/statuses/madness.gif",
        
        events: {
            onBeforeAction: function(context) {
                if(!hasStatus(this.status.affecting, "fear")) {
                    removeStatus(this.status.affecting, "blindness")
                    return
                }

                if(!context.settings.action.type.includes("target")) return;
                
                // alter target maybe
                if(Math.random() < 1) {
                    //select from whole turnorder
                    let subject = context.user
                    let oldTarget = context.settings.target
                    let newTarget = env.rpg.turnOrder.filter(actor=>actor.state != "dead" && actor.state != "lastStand" && actor.slug != oldTarget.slug)
                    if(newTarget.length) {
                        newTarget = newTarget.sample()
                    } else return;

                    console.log("old target was", context.settings.target, "new target is", newTarget)

                    context.settings.target = newTarget

                    sendFloater({
                        target: subject,
                        type: "arbitrary",
                        arbitraryString: "BLINDNESS!",
                        beneficial: false,
                        size: 2,
                    })

                    readoutAdd({
                        message: `${subject.name}'s action upon ${oldTarget.name} is turned to ${newTarget.name}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }
            },

            onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "fear") removeStatus(this.status.affecting, "blindness")
            },
        }
    }
	
    env.STATUS_EFFECTS.hyperfocus_flat = { 
        slug: "hyperfocus_flat",
        name: "Tunnel Vision",
        outgoingToHit: 2,
        outgoingCrit: 8,
		incomingToHit: 1,
		incomingCrit: 4,
        beneficial: true,
        tickType: "onTurnEnd",
		icon: "https://corru.observer/img/sprites/combat/statuses/hyperfocus.gif",
        events: {
            onTurn: function() { reactDialogue(this.status.affecting, 'focused') },
        },
        help: `+200% HIT%, +800% CRIT%, +100% IN:HIT%, +400% IN:CRIT%`,
        removes: ["weakened", "fear", "fear_evasion"],
        opposite: "fear_evasion"
    }
	
	env.STATUS_EFFECTS.fear_evasion = { 
        slug: "fear_evasion",
        name: "Terror",
        tickType: "onTurnEnd",
        help: `receive fear on turn\nremoved by ally CRIT\n-75% IN:HIT, -75% IN:CRIT`,
        removes: ["hyperfocus_flat"],
        opposite: "hyperfocus_flat",
		icon: "https://corru.observer/img/sprites/combat/statuses/madness.gif",
        moveMod: -1,
        events: {
            GLOBAL_onCrit: function({subject, attack, originalEventTarget}) {
                if(originalEventTarget.team.name != this.status.affecting.team.name) return;
                removeStatus(this.status.affecting, 'fear_evasion')
				removeStatus(this.status.affecting, 'fear')

                sendFloater({
                    target: this.status.affecting,
                    type: "arbitrary",
                    arbitraryString: "INSPIRED!",
                    size: 1,
                })

                env.rpg.effectMessage.action({
                    user: this.status.affecting,
                    target: originalEventTarget,
                    action: `%USER is emboldened by %TARGET's powerful strike`
                })
            },
			onTurn: function() {
				addStatus({target: this.status.affecting, origin: false, status: "fear", length: 1});
			}
        }
    }
	//fear not removing tunnel vision doesn't feel right so i'm stealing some stuff from moreglee
  if(!env.STATUS_EFFECTS.fear.removes.includes("hyperfocus_flat")) {
  env.STATUS_EFFECTS.fear.removes.push("hyperfocus_flat");
  }
  if(!env.STATUS_EFFECTS.vulnerable.removes.includes("evasion_mega")) {
  env.STATUS_EFFECTS.vulnerable.removes.push("evasion_mega");
  }
  if(!env.STATUS_EFFECTS.evasion.removes.includes("vulnerable_mega")) {
  env.STATUS_EFFECTS.evasion.removes.push("vulnerable_mega");
  }
  if(typeof env.STATUS_EFFECTS.destabilized.removes != "undefined") {
  if(!env.STATUS_EFFECTS.destabilized.removes.includes("denatured")) {
  env.STATUS_EFFECTS.destabilized.removes.push("denatured");
  }
} else { 
    env.STATUS_EFFECTS.destabilized.removes = ["denatured"];
}

    env.STATUS_EFFECTS.evasion_mega = { 
        slug: "evasion_mega",
        name: "Unnatural Speed",
        incomingToHit: -1.5,
        incomingCrit: -1.5,
		icon: "https://corru.observer/img/sprites/combat/statuses/unnatural_speed.gif",
        beneficial: true,
        help: "-150% IN:HIT% & IN:CRIT%",
        removes: ["vulnerable", "vulnerable_mega"],
        opposite: "vulnerable_mega",
        tickType: "onTurnEnd",
    }
	
    env.STATUS_EFFECTS.vulnerable_mega = { 
        slug: "vulnerable_mega",
        name: "Hypervulnerable",
        incomingToHit: 2,
        incomingCrit: 4,
		icon: "https://narrativohazard-expunged.neocities.org/img/statuses/hypervulnerable.gif",
        beneficial: false,
        help: "+200% IN:HIT%, +400% IN:CRIT%",
        removes: ["evasion", "evasion_mega"],
        opposite: "evasion_mega",
    }
	
	env.STATUS_EFFECTS.windup_telegraph_flat = {
        slug: "windup_telegraph_flat",
        name: "Interruptible",
        help: "preparing telegraphed action, interrupted by any hit or stun",
        beneficial: true,
        infinite: true,
        enableWindup: true,
		icon: "https://corru.observer/img/sprites/combat/statuses/telegraph.gif",
		events: {
			onStruck: function({subject, attack, beneficial}) { 
                console.log("struck!", subject, attack)
                if(attack <= 0 || beneficial) return;
                env.rpg.effectMessage.action({
                    user: this.status.affecting,
                    target: this.status.affecting,
                    action: `%USER loses focus!`,
                    reason: "INTERRUPTED",
                    isMinor: true
                })
                removeStatus(this.status.affecting, 'windup_telegraph_flat')
            }, 
              
            onAddStatus: function({target, statusObj}) {
                if(!statusObj.skipTurn) return;
                removeStatus(this.status.affecting, 'windup_telegraph_flat')
            },
		}
    }
	
	env.STATUS_EFFECTS.windup_aim = {
        slug: "windup_aim",
        name: "Aiming",
        help: "preparing targeted action, interrupted by any crit or stun",
        beneficial: true,
        infinite: true,
        enableWindup: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_windupfinal.png",
		events: {
			onCritStruck: function({subject, attack, beneficial}) { 
                console.log("crit!!", subject, attack)
                if(attack <= 0 || beneficial) return;
                env.rpg.effectMessage.action({
                    user: this.status.affecting,
                    target: this.status.affecting,
                    action: `%USER loses focus!`,
                    reason: "INTERRUPTED",
                    isMinor: true
                })
                removeStatus(this.status.affecting, 'windup_aim')
            }, 
              
            onAddStatus: function({target, statusObj}) {
                if(!statusObj.skipTurn) return;
                removeStatus(this.status.affecting, 'windup_aim')
            },
		}
    }
	
	env.STATUS_EFFECTS.channeling_flat = {
        slug: "channeling_flat",
        name: "Watching",
        help: 'channeling continuous negative effect upon distant target, severed by any hit or stun',
        beneficial: false,
        infinite: true,
		icon: "https://corru.observer/img/sprites/combat/statuses/channeling.gif",
        events: {
            onBeforeAddStatus: function(context) {
                if(context.status == "stun") removeStatus(this.status.affecting, "channeling_flat")
            },

            onStruck: function({subject, attack, beneficial}) { 
                if(attack <= 0 || beneficial) return;
                env.rpg.effectMessage.action({
                    user: this.status.affecting,
                    target: this.status.affecting,
                    action: `%USER loses focus!`,
                    reason: "INTERRUPTED",
                    isMinor: true
                })
                removeStatus(this.status.affecting, 'channeling_flat')
            }, 

            onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "channeling_flat") {
                    if(this.status.affecting.channelTarget) {
                        removeStatus(this.status.affecting.channelTarget, "channeledUpon_flat")
                    }
                }
            }
        }
    }
	
	env.STATUS_EFFECTS.channeledUpon_flat = {
        slug: "channeledUpon_flat",
        name: "Seen",
        help: '[[ORIGIN]] continuously attacking and inflicting negative status',
        beneficial: false,
        infinite: true,
		icon: "https://corru.observer/img/sprites/combat/statuses/channeledUpon.gif",
        events: {
			
            onTurnEnd: function() {
                if(!hasStatus(this.status.origin, "channeling_flat")) {
					console.log("removing da seen status on a guy")
                    removeStatus(this.status.affecting, "channeledUpon_flat")
                }
            },

			onTurn: function() {
				let target = this.status.affecting
				if(!hasStatus(this.status.origin, "channeling_flat")) {
					console.log("removing da seen status on a guy")
                    removeStatus(this.status.affecting, "channeledUpon_flat")
                }
				play('fear', 1)
				addStatus({target, origin: this.status.origin, status: "fear", length: 1});
				combatHit(target, {amt: 1, crit: 0, autohit: true, origin: this.status.origin});
			},

            onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "channeledUpon") {
                    this.status.origin.channelTarget = false
                    removeStatus(this.status.affecting, "fear")
                }
            }
        }
    }
	
	env.STATUS_EFFECTS.coiling_flat = {
        slug: "coiling_flat",
        name: "Coiling",
        help: 'providing continuous beneficial statuses\nsevered by stun or death',
        beneficial: true,
        infinite: true,
		icon: "https://corru.observer/img/sprites/combat/statuses/coiling.gif",
        events: {
            onBeforeAddStatus: function(context) {
                if(context.status == "stun") removeStatus(this.status.affecting, "coiling_flat")
            },

            onRemoveStatus: function({target, removingStatusName}) {
                console.log("REMOVING", removingStatusName)
                if(removingStatusName == "coiling_flat") {
                    if(this.status.affecting.supportTarget) {
                        removeStatus(this.status.affecting.supportTarget, "coiled_flat")
                    }
                }
            }
        }
    }
	
	env.STATUS_EFFECTS.coiled_flat = {
        slug: "coiled_flat",
        name: "Coiled",
        help: '[[ORIGIN]] providing continuous beneficial statuses',
        beneficial: true,
        infinite: true,
		icon: "https://corru.observer/img/sprites/combat/statuses/coiled.gif",
        events: {
			
            onTurnEnd: function() {
                if(!hasStatus(this.status.origin, "coiling_flat")) {
                    removeStatus(this.status.affecting, "coiled_flat")
                }
            },
			
			onTurn: function() {
				let target = this.status.affecting
				play('mend', 1)
				addStatus({target: target, origin: this.status.origin, status: "focused", length: 1});
				addStatus({target: target, origin: this.status.origin, status: "carapace", length: 2});
				combatHit(target, {amt: 1, crit: 0, autohit: true, origin: this.status.origin, type: 'barrier'});
			},

            onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "coiled") {
                    this.status.origin.channelTarget = false
                    removeStatus(this.status.affecting, "focused")
					removeStatus(this.status.affecting, "carapace")
                }
            }
        }
    }
	
	env.STATUS_EFFECTS.unnatural_carapace_flat = {
        slug: "unnatural_carapace_flat",
        name: "Unnatural Carapace",
        incomingFlat: -2,
        beneficial: true,
        help: "-2 base incoming damage, puncture immunity",
		icon: "https://corru.observer/img/sprites/combat/statuses/unnatural_carapace.gif",
        tickType: "onTurnEnd",
		removes: ["open_wound", "unnatural_wound", "puncture"],
		opposite: "unnatural_wound",
        events: { // ticked down via special_bomb_detonate_victim (not this time :P)
            
            onBeforeAddStatus: function(context) {
                if(context.status == "puncture") {
                    context.noAdd = true

                    env.setTimeout(()=>
                        env.rpg.effectMessage.action({
                            user: this.status.affecting,
                            target: this.status.affecting,
                            reason: "attention",
                            action: `'%TARGET';'${context.status.toUpperCase()} immunity';'from ${this.status.name.toUpperCase()}'`
                        }), 
                    100)
                }
            },
        },
    },
	
	env.STATUS_EFFECTS.unnatural_wound = {
        slug: "unnatural_wound",
        name: "Unnatural Wound",
        incomingFlat: 2,
        beneficial: false,
        help: "+2 base incoming damage, regen immunity",
        tickType: "onTurnEnd",
		removes: ["carapace", "unnatural_carapace_flat", "regen"],
		opposite: "unnatural_carapace_flat",
		icon: "https://corru.observer/img/sprites/combat/statuses/open_wound.gif",
        events: { // ticked down via special_bomb_detonate_victim (not this time :P)
            
            onBeforeAddStatus: function(context) {
                if(context.status == "regen") {
                    context.noAdd = true

                    env.setTimeout(()=>
                        env.rpg.effectMessage.action({
                            user: this.status.affecting,
                            target: this.status.affecting,
                            reason: "attention",
                            action: `'%TARGET';'${context.status.toUpperCase()} immunity';'from ${this.status.name.toUpperCase()}'`
                        }), 
                    100)
                }
            },
        },
    },
	
	env.STATUS_EFFECTS.rocket_bearer = {
        slug: "rocket_bearer",
        name: "Munitions",
        help: "holding missiles, grants use of LAUNCH MISSILES windup action\ndoes not tick down on turn",
        icon: "/img/sprites/combat/passives/armed.gif",
        beneficial: true,
        ticktype: "special", //whyyyyyy does this not WORK !!!! >:(
		events: {
			onTurn: function() {
				addStatus({target: this.status.affecting, status: "rocket_bearer", length: 1})
			}
		}
    },
		// combine statuses start here
	env.STATUS_EFFECTS.shield_bearer = {
        slug: "shield_bearer",
        name: "Shield Bearer",
        help: "-1 base incoming damage, grants GUARD and SHELL actions, removed by stun",
        icon: "/img/sprites/combat/statuses/carapace.gif",
        beneficial: true,
        passive: true,
        //grantsActions: ["scene_rifle"],
        events: {
            onCreated: function({statusObj}) {
				let user = this.status.affecting
				if(!this.status.initialized) {
					user.actions.push("guard")
					user.actions.push("enemy_shell")
					this.status.initialized = true
				}
            },
			onAddStatus: function({target, statusObj}) {
				let user = this.status.affecting
                if(!statusObj.skipTurn) return;
				user.actions = user.actions.filter(action => action !== "guard")
				user.actions = user.actions.filter(action => action !== "enemy_shell")
                removeStatus(this.status.affecting, 'shield_bearer', {forceRemoveStatus: true})
            },
        }
    },
	
	env.STATUS_EFFECTS.passive_carapace_sentry = {
        slug: "passive_carapace_sentry",
        name: "Synthetic Carapace",
		icon: "/img/sprites/combat/statuses/carapace.gif",
        incomingMult: -1,
        beneficial: true,
		passive: true,
        help: "-100% incoming damage/healing",
    },
	
	env.STATUS_EFFECTS.passive_carapace_hunter = {
        slug: "passive_carapace_hunter",
        name: "Thick Carapace",
		icon: "/img/sprites/combat/statuses/carapace.gif",
        incomingMult: -0.4,
        beneficial: true,
		passive: true,
        help: "-40% incoming damage/healing",
    },
	
	env.STATUS_EFFECTS.passive_carapace_synth = {
        slug: "passive_carapace_synth",
        name: "Metallic Carapace",
		icon: "/img/sprites/combat/statuses/carapace.gif",
        //incomingMult: -0.2,
		//incomingFlatCrit: -999,
		incomingCrit: -999,
        beneficial: true,
		passive: true,
        help: "cannot receive critical hits",
    },
	
	env.STATUS_EFFECTS.passive_carapace_synthelite = {
        slug: "passive_carapace_synthelite",
        name: "Metallic Carapace",
		icon: "/img/sprites/combat/statuses/carapace.gif",
        incomingMult: -0.4,
		//incomingFlatCrit: -999,
		incomingCrit: -999,
        beneficial: true,
		passive: true,
        help: "cannot receive critical hits, -40% incoming damage/healing",
    },
	
	env.STATUS_EFFECTS.passive_carapace_veteran = {
        slug: "passive_carapace_veteran",
        name: "Exocarapace",
		icon: "/img/sprites/combat/statuses/carapace.gif",
        incomingMult: -1,
		//incomingFlat: -1,
        beneficial: true,
		passive: true,
		events: {
			onCritStruck: function({subject, attack, beneficial}) {
				let currentIncomingMult = this.status.incomingMult
                if(beneficial) return;
                this.status.incomingMult = currentIncomingMult + 0.1
				
				if(currentIncomingMult > 0.1) {
					sendFloater({
						target: this.status.affecting,
						type: "arbitrary",
						arbitraryString: "EXOCARAPACE COMPROMISED!",
						beneficial: false,
						size: 2,
					})
					readoutAdd({
						message: `${this.status.affecting.name}'s armor falls apart! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
						name: "sourceless", 
						type: "sourceless combat minordetail",
						show: false,
						sfx: false
					})
				} else {
					sendFloater({
						target: this.status.affecting,
						type: "arbitrary",
						arbitraryString: "EXOCARAPACE DAMAGED!",
						beneficial: false,
						size: 1.5,
					})
					readoutAdd({
						message: `${this.status.affecting.name}'s armor crumples as it is struck! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
						name: "sourceless", 
						type: "sourceless combat minordetail",
						show: false,
						sfx: false
					})    
				}
            },
		},
        help: "-100% incoming damage/healing\n when receiving a critical hit, add +10% incoming damage/healing to this passive (stacks per crit)",
    },
	
	env.STATUS_EFFECTS.passive_carapace_juggernaut = {
        slug: "passive_carapace_juggernaut",
        name: "Heavy Armor",
		icon: "/img/sprites/combat/statuses/carapace.gif",
        incomingMult: -0.5,
        beneficial: true,
		passive: true,
        help: "-50% incoming damage/healing",
    },
	
	env.STATUS_EFFECTS.passive_carapace_antlion = {
        slug: "passive_carapace_antlion",
        name: "Natural Armor",
		icon: "/img/sprites/combat/statuses/carapace.gif",
        incomingMult: -0.75,
        beneficial: true,
		passive: true,
        help: "-75% incoming damage/healing",
    },
	
	env.STATUS_EFFECTS.landmine_cmb = {
		slug: "landmine_cmb",
		name: "Mined",
		infinite: true,
		beneficial: true,
		icon: "/img/sprites/combat/statuses/bomb_planted.gif",
		
		events: {
			onStruck: function({subject, attack, beneficial}) {
                let user = this.status.affecting
                if(
                    user.state == "dead" ||
					subject.state == "dead" ||
					subject == user
                ) return;

                setTimeout(()=>{
                    useAction(this.status.affecting, env.ACTIONS['landmine_attack'], subject, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "mined"})
            
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: `LANDMINE!`,
                        size: 2,
                    })

                    readoutAdd({
                        message: `a landmine hurls itself at ${subject.name} as they approach! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
					removeStatus(this.status.affecting, "landmine_cmb")
                }, env.ADVANCE_RATE * 0.3)
            }
		},
		
		help: 'when struck offensively, retaliate against attacker with landmine'
	},
	
	env.ACTIONS.landmine_attack = {
        slug: "landmine_attack",
        name: "Landmine",
        verb: "throw at",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER THROWS A WEIRD CYST AT %TARGET",
            crit: "%TARGET EXPLODES",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET DODGES"
        },
        details: {
            flavor: `'throw hastily made minor explosive';'chance for greater explosion'`,
            onHit: `'[STAT::amt]'`,
            onCrit: ()=> `'HIT all foes for [STAT::amt]';${page.name == "frame" ? `;'additional hits do not trigger on-hit effects'` : ``}`,
        },
        stats: {
            accuracy: 0.9,
            crit: 0.5,
            amt: 2,
        },
        exec: function(user, target) {
            let action = this;
            return env.GENERIC_ACTIONS.singleTarget({
                action, 
                user, 
                target,
                critSfx: {
                    name: 'shot',
                    rate: 1.25
                },
                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i) => {
                        env.GENERIC_ACTIONS.singleTarget({
                            action,
                            user, 
                            target: actor,
                            hitSfx: { name: 'shot6' },
                            canCrit: false,
                            runHitEvents: false
                        })
                    }
                })
            })
        }
    },
	
	env.STATUS_EFFECTS.cmb_attackdrone = { 
        slug: "cmb_attackdrone",
        name: "Battle Drone",
        passive: true,
        beneficial: true,
        //impulse: {type: "common", component: "cmb"}, // this should be fine i think
        icon: "/img/sprites/combat/augs/drone.gif",
        
        events: {
            onTurn: function() {
                let user = this.status.affecting
                let shownNotice = false
                env.recentSfx = false

                env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i) => {
                        if(hasStatus(actor, "vulnerable")) {
                            env.GENERIC_ACTIONS.singleTarget({
                                action: env.ACTIONS['drone_strike_cmb'], 
                                user, 
                                target: actor,
                                hitSfx: { name: 'dull', rate: 1, volume: 0.5 },
                                critSfx: { name: 'dull', rate: 1, volume: 0.5 },
                                genExec: ()=>{
                                    if(!shownNotice) {
                                        sendFloater({
                                            target: user,
                                            type: "arbitrary",
                                            arbitraryString: "DISCHARGE!",
                                        })

                                        readoutAdd({
                                            message: `${user.name}'s <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span> pierces all vulnerable foes`, 
                                            name: "sourceless", 
                                            type: "sourceless combat minordetail", 
                                            show: false,
                                            sfx: false
                                        })

                                        shownNotice = true
                                    }
                                }
                            })
                        }
                    }
                })
            },
        },

        help: `if alive, attack all vulnerable foes on turn for -2HP`
    },
	
	env.ACTIONS.drone_strike_cmb = {
        slug: "drone_strike_cmb",
        name: "Discharge",
        type: 'target',
        desc: "'strike against analyzed weakness'",
        anim: "basic-attack",
        help: "AUTOHIT -2HP",
        usage: {
            act: "%USER'S DRONE DISCHARGES INTO %TARGET",
        },
        autohit: true,
		canCrit: false,
        crit: 0,
        amt: 2,
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                specialAmt: env.rpg.is2D ? 2 : 2,
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'dull',
                    rate: 1
                }
            })
        }
    },
	
	env.STATUS_EFFECTS.poison = {
        slug: "poison",
        name: "Neurotoxin",
        help: "-20%hp/turn (min:2)",
		icon: "/img/sprites/combat/statuses/rot.gif",
        removes: ["antidote", "regen"],
        opposite: "antidote",
        events: {
            onTurn: function() {
                reactDialogue(this.status.affecting, 'puncture');

                let amt = 
                    (
                        (hasStatus(this.status.affecting, "malware_drill") ? 4 : 2) *
                        (Math.floor(this.status.affecting.hp * 0.2) || 2)
                    ) + (hasStatus(this.status.affecting, "global_escalation") ? env.crittaMap.getModQty("global_escalation") || 0 : 0)

                combatHit(this.status.affecting, {amt: amt, autohit: true, redirectable: false, runEvents: false});
                play('megastatus', 0.75, 0.5);
            },
        }
    },
	
	env.STATUS_EFFECTS.antidote = { 
        slug: "antidote",
        name: "Antidote",
        help: "+2 HP/turn",
		icon: "https://adrfurret.neocities.org/corrumods/img/sprites/combat/statuses/mutation.gif", // i fuckign love STEALING !!!!!!!!!!!!
        removes: ["poison", "rot", "puncture"],
        opposite: "poison",
        beneficial: true,
        events: {
            onTurn: function() {
                combatHit(this.status.affecting, {amt: -2, beneficial: true, type: "hp"});
                reactDialogue(this.status.affecting, 'regen');
                play('mend', 0.75, 0.75);
            },
        }
    },
	
	env.STATUS_EFFECTS.burning = {
        slug: "burning",
        name: "Chemical Fire",
		removes: ["rejuvenation"],
		opposite: "rejuvenation",
        help: "-(T:CHEMICAL FIRE)HP/turn \nI.E. 4T:CHEMICAL FIRE = -4HP",
		icon: "/img/sprites/combat/statuses/puncture.gif",
        events: {
            onTurn: function() {
                let amt = Math.floor(this.status.duration)
                //let amt = Math.max(Math.floor(percentage * this.status.affecting.hp), 1 + (hasStatus(this.status.affecting, "global_escalation") ? env.crittaMap.getModQty("global_escalation") || 0 : 0))
                console.log("burning for", amt)
                reactDialogue(this.status.affecting, 'puncture');
                combatHit(this.status.affecting, {amt, autohit: true, redirectable: false, runEvents: false});
                play('dull', 1, 0.5);
            },
        }
    },
	
	env.STATUS_EFFECTS.rejuvenation = { // this is a surprise tool that will help us later
        slug: "rejuvenation",
        name: "Rejuvenation",
        help: "+10%hp/turn (min:1)",
		icon: "/img/sprites/combat/statuses/regen.gif",
        removes: ["burning", "poison", "rot", "puncture"],
        opposite: "burning",
		beneficial: true,
        events: {
            onTurn: function() {
                reactDialogue(this.status.affecting, 'regen');

                let amt = 
                    (
                        -(Math.floor(this.status.affecting.hp * 0.1) || 1)
                    )

                combatHit(this.status.affecting, {amt: amt, autohit: true, redirectable: false, runEvents: false, beneficial: true, type: "hp"});
                play('heal', 0.75);
            },
        }
    }
	
	if(env.STATUS_EFFECTS.mutation) {
		env.STATUS_EFFECTS.poison.removes.push("mutation")
	}
	
	env.STATUS_EFFECTS.limited_actor = {
		slug: "limited_actor",
		name: "Timed Actor",
		help: "on status expiry, remove this actor from combat",
		icon: "/img/sprites/combat/statuses/ethereal.gif",
		events: {
			onRemoveStatus: function({removingStatusName}) {
				if(removingStatusName == "limited_actor") {
					advanceTurn(this.status.affecting)
					setTimeout(()=> midCombatActorRemove(this.status.affecting), 300)
				}
			}
		}
	}
	
	env.STATUS_EFFECTS.fatal_flaw = {
        slug: "fatal_flaw",
        name: "Fatal Flaw",
        help: "when struck with a crit, also lose 20% of current HP (min:1), removed upon hypervulnerable loss",
        infinite: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/statuses/fatal_flaw.gif",
        events: {
            onBeforeCombatHit: function() {
                if(!hasStatus(this.status.affecting, "vulnerable_mega")) {
                    removeStatus(this.status.affecting, "fatal_flaw")
                }
            },

            onCritStruck: function({subject, attack, beneficial}) {
                if(beneficial) return;
                let dmg = (Math.floor(this.status.affecting.hp * 0.2) || 1)
                reactDialogue(this.status.affecting, 'puncture');
                combatHit(this.status.affecting, {amt: dmg, autohit: true, redirectable: false, runEvents: false})

                sendFloater({
                    target: this.status.affecting,
                    type: "arbitrary",
                    arbitraryString: "FATAL FLAW!",
                    beneficial: false,
                    size: 2,
                })

                readoutAdd({
                    message: `${this.status.affecting.name} takes ${dmg} extra critical damage! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail",
                    show: false,
                    sfx: false
                })    
            },

            onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "vulnerable_mega") removeStatus(this.status.affecting, "fatal_flaw")
            },
        }
    },

	env.ACTIONS.nothing_pass = {
        slug: "nothing_pass",
        name: "Pass",
        type: 'autohit+hidden',
        desc: "'voluntarily skip turn'",
        anim: "",
        usage: {
            act: "%USER IS IDLE"
        },
        exec: function(user, target) {
            return 'nothing';
        }
    },
	
	env.STATUS_EFFECTS.agony = {
		slug: "agony",
		name: "Agony",
		help: "when taking an action, inflict one of the following::-2HP/+1T:PUNCTURE/+2T:OPEN WOUND/+2T:FEAR/+1T:STUN\nremoved by regen",
        infinite: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/statuses/agony.gif",
		events: {
			onAction: function() {
				let loopCount = 1
				if(hasStatus(this.status.origin, "fated_hook")) {
					let fated = this.status.origin.statusEffects.find(status => status.slug == "fated_hook")
					loopCount = 1 + fated.power
				}
				for (let i = 0; i < loopCount; i++) {
					let rand = Math.random()
					if(rand < 0.2) {
						addStatus({target: this.status.affecting, origin: this.status.affecting, status: "puncture", length: 1})
					} else if(rand < 0.4) {
						addStatus({target: this.status.affecting, origin: this.status.affecting, status: "open_wound", length: 2})
					} else if(rand < 0.6) {
						addStatus({target: this.status.affecting, origin: this.status.affecting, status: "fear", length: 2})
					} else if(rand < 0.8) {
						addStatus({target: this.status.affecting, origin: this.status.affecting, status: "stun", length: 1})
					} else {
						combatHit(this.status.affecting, {amt: 2, crit: 0, autohit: true, origin: this.status.affecting})
					}
				}
			},
			onAddStatus: function({statusObj}) {
				let statusName = statusObj.slug
				if(statusName == "regen") { removeStatus(this.status.affecting, "agony") }
			}
		}
	}
	
	env.STATUS_EFFECTS.unnatural_repairs = {
        slug: "unnatural_repairs",
        name: "Unnatural Repairs",
        help: "+100% outgoing damage/healing, +5%HP/turn while BP > 0, prevents puncture and rot, removed upon barrier loss",
        infinite: true,
        beneficial: true,
        removes: ["million_teeth", "puncture", "rot"],
		icon: "/img/sprites/combat/statuses/repairs.gif",
        events: {
            onCreated: function({statusObj}) {
                if(statusObj.slug == this.status.slug) {
                    removeStatus(this.status.affecting, "puncture")
					removeStatus(this.status.affecting, "puncture")
                    combatHit(this.status.affecting, {amt: -1, beneficial: true})
                }
            },
            onBeforeAddStatus: function(context) {
                if(context.status == "puncture") context.noAdd = true
				if(context.status == "rot") context.noAdd = true
            },
            onTurn: function() {
                if(this.status.affecting.bp > 0) {
                    combatHit(this.status.affecting, {amt: -(0.05 * this.status.affecting.hp), beneficial: true});
                    reactDialogue(this.status.affecting, 'regen');
                    play('mend');
                } else {
                    console.log('removing repairs', this.status.affecting.bp)
                    removeStatus(this.status.affecting, "unnatural_repairs")
                }
            },
            onCombatHit: function() {
                //console.log('in repair damage', this.status.affecting.bp)
                if(this.status.affecting.bp <= 0) {
                    console.log('removing repairs')
                    removeStatus(this.status.affecting, "unnatural_repairs")
                }
            },
        }
    },
	
	env.STATUS_EFFECTS.rage = {
        slug: "rage",
        name: "Rage",
        outgoingToHit: 4,
        outgoingCrit: 4,
        outgoingFlat: 4,
		incomingToHit: 2,
        incomingCrit: 2,
        incomingFlat: 2,
        beneficial: true,
        infinite: true,
		icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_windupfinal.png",
        events: {
            onTurn: function() { reactDialogue(this.status.affecting, 'rage') },

            onAction: function({user, actionSettings, action, target}) {
				if(!actionSettings.reason && !action.slug.includes("windup")) {
					removeStatus(this.status.affecting, "rage")
				}
            },
        },
        help: "+4 base outgoing damage, +400% HIT% & CRIT%, +2 base incoming damage, +200% IN:HIT% & IN:CRIT%, consumed by next action (not consumed by PREPARATION or similar actions)"
    },
	
	env.STATUS_EFFECTS.cloaked = {
        slug: "cloaked",
        name: "Cloaked",
        help: "-75% IN:HIT%, IN:CRIT%, prevent vulnerable and hypervulnerable while barrier is up",
        infinite: true,
        beneficial: true,
        removes: ["marked", "vulnerable_mega", "vulnerable"],
		opposite: "marked",
		incomingToHit: -0.75,
		incomingCrit: -0.75,
		icon: "/img/sprites/combat/statuses/untargetable.gif",
        events: {
            onBeforeAddStatus: function(context) {
                if(context.status == "vulnerable") context.noAdd = true
				if(context.status == "vulnerable_mega") context.noAdd = true
            },
            onCombatHit: function() {
                //console.log('in repair damage', this.status.affecting.bp)
                if(this.status.affecting.bp <= 0) {
                    console.log('removing repairs')
                    removeStatus(this.status.affecting, "cloaked")
                }
            },
        }
    },
	
	env.STATUS_EFFECTS.marked = {
        slug: "marked",
        name: "Marked",
        help: "+2T:VULNERABLE/turn while BP > 0, removed upon barrier loss",
        infinite: true,
        opposite: "cloaked",
        removes: ["cloaked"], 
        icon: "/img/sprites/combat/statuses/million_teeth.gif",
        events: {
            onTurn: function() {
                if(this.status.affecting.bp > 0) {
                    addStatus({target: this.status.affecting, origin: false, status: "vulnerable", length: 2}); 
                    play('status', 0.75);
                } else {
                    removeStatus(this.status.affecting, "marked")
                }
            },

            onCombatHit: function() {
                if(this.status.affecting.bp <= 0) {
                    removeStatus(this.status.affecting, "marked")
                }
            },
        }
    },

    //summon specific statuses
env.STATUS_EFFECTS.player_ethereal = {
    slug: "player_ethereal",
    name: "Ethereal",
    help: "disappear on death",
    infinite: true,
	passive: true,
	icon: "https://corru.observer/img/sprites/combat/statuses/ethereal.gif",
    events: {
        onDeath: function() {
            setTimeout(()=>midCombatActorRemove(this.status.affecting), 100)
        },
		onCreated: function() { // safeguard for softlocks in DCT fights
			if(this.status.affecting.enemyTeam.members.includes("critta_jester")) {
				this.status.affecting.actions.push("nothing_pass")
			}
		}
    }
}

env.STATUS_EFFECTS.ethereal.events.onCreated = function() { // oh god we need that for normal ethereal too WOOPS
			if(this.status.affecting.enemyTeam.members.includes("critta_jester")) {
				this.status.affecting.actions.push("nothing_pass")
			}
		}

env.STATUS_EFFECTS.perma_vulnerable = { 
    slug: "perma_vulnerable",
    name: "Thin Membrane",
    infinite: true,
    incomingToHit: 1,
    incomingCrit: 2,
	passive: true,
	icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_thin%20membrane.gif",
    events: {
        onTurn: function() { reactDialogue(this.status.affecting, 'vulnerable') },
    },
    help: "+100% incoming hit%, +200% incoming crit%",
}

env.STATUS_EFFECTS.perma_destabilized = { 
    slug: "perma_destabilized",
    name: "Irradiated",
    incomingMult: 1,
	icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_irradiated.gif",
    beneficial: true,
    infinite: true,
    passive: true,
    events: {
        onTurn: function() { reactDialogue(this.status.affecting, 'destabilized') },
    },

    help: "+100% incoming damage/heal",
}

env.STATUS_EFFECTS.floor_it = { 
    slug: "floor_it",
    name: "Floor It",
    beneficial: true,
    infinite: true,
	icon: "https://corru.observer/img/sprites/combat/statuses/surge.gif",
    events: {
        onTurn: function() { 
            reactDialogue(this.status.affecting, 'surge') 
            delete this.status.justGotSurge
        },
        
        onAction: function({user, action, target, beingUsedAsync}) {
            if(this.status.justGotSurge || beingUsedAsync || ["incoherent_", "steer", "floor", "windup", "intrusive"].some(slugpart => action.slug.includes(slugpart))) return;
            
            setTimeout(()=>{
        
                sendFloater({
                    target: user,
                    type: "arbitrary",
                    arbitraryString: "FLOOR IT!",
                })

                readoutAdd({
                    message: `${user.name} acts again! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail", 
                    show: false,
                    sfx: false
                })

                for(let count = 0; count < 2; count += 1)
                    useAction(user, action, target, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "floor it"})
            }, 500)
            setTimeout(()=>{
        
                sendFloater({
                    target: user,
                    type: "arbitrary",
                    arbitraryString: "FLOOR IT!",
                })

                readoutAdd({
                    message: `${user.name} acts again! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail", 
                    show: false,
                    sfx: false
                })

                for(let count = 0; count < 2; count += 1)
                    useAction(user, action, target, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "floor it"})
            }, 500)
            removeStatus(this.status.affecting, "floor_it")
        },

        onCreated: function({statusObj}) {
            if(statusObj.slug == this.status.slug) this.status.justGotSurge = true
        },
    },
    help: "use next active action thrice"
}

env.STATUS_EFFECTS.daemon_malfunction = { 
    slug: "daemon_malfunction",
    name: "Conflicted",
    help: "all targeted actions have a 10% chance to become RECALL\nRECALL::(SELF:: -1HP, +1T:STUN)",
    beneficial: false,
    infinite: true,
	passive: true,
	icon: "https://corru.observer/img/sprites/combat/statuses/weakened.gif",
    
    events: {
        onBeforeAction: function(context) {
            if(!context.settings.action.type.includes("target")) return;
            
            // alter action maybe
            if(Math.random() < (0.10)) {

                context.settings.action = env.ACTIONS["recall"]
                let subject = context.settings.user

                sendFloater({
                    target: subject,
                    type: "arbitrary",
                    arbitraryString: "CONFLICTED!",
                    isGood: false,
                    size: 2,
                })

                readoutAdd({
                    message: `${subject.name}'s doesn't know what it's fighting for! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail",
                    show: false,
                    sfx: false
                })
            }
        },
    }
}

env.STATUS_EFFECTS.dull_malfunction = { 
    slug: "dull_malfunction",
    name: "Faulty",
    help: "all actions have a 10% + (2%*T:DESTABILIZED) chance to become MALFUNCTION\nMALFUNCTION::(SELF:: -1HP, +1T:VULNERABLE)",
    beneficial: false,
    infinite: true,
	passive: true,
	icon: "https://corru.observer/img/sprites/combat/statuses/vulnerable.gif",
    
    events: {
        onBeforeAction: function(context) {
            let pow = hasStatus(this.status.affecting, "destabilized");
            
            // alter action maybe
            if(Math.random() < (0.10 + (pow * 0.02))) {

                context.settings.action = env.ACTIONS["malfunction_good"]
                let subject = context.settings.user

                sendFloater({
                    target: subject,
                    type: "arbitrary",
                    arbitraryString: "FAULTY!",
                    isGood: false,
                    size: 2,
                })

                readoutAdd({
                    message: `${subject.name}'s breaks down! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail",
                    show: false,
                    sfx: false
                })
            }
        },
    }
}

env.STATUS_EFFECTS.high_priority = { //deceiving bulb reskin because that's surprisingly balanced
    slug: "high_priority",
    name: "High Priority",
    help: "prioritized as target over other allies",
    beneficial: false,
    infinite: true,
	passive: true,
	icon: "https://narrativohazard-expunged.neocities.org/img/passives/flop_high%20priority.gif",
            
    events: {
        onCreated: function({statusObj}) {
            if(statusObj.slug == "high_priority" && !this.status.initialized) {
                this.status.initialized = true
                this.status.affecting.priorityTarget = true
            }
        }
    },
}

    env.STATUS_EFFECTS.player_conjoined = {
        slug: "player_conjoined",
        name: "Conjoined",
        help: "share HP with all other conjoined entities",
        infinite: true,
        beneficial: true,
		passive: true,
		icon: "https://corru.observer/img/sprites/combat/statuses/conjoined.gif",
        events: {
            onCombatHit: function() {
                console.log('in player_conjoindamage', this.status.affecting.hp)
                if(!this.status.affecting.hp || this.status.affecting.hp == NaN) this.status.affecting.hp = 0;

                let player_conjoined = env.rpg.turnOrder.filter(actor=>hasStatus(actor, "player_conjoined"))
                player_conjoined.forEach(actor => {
                    actor.hp = this.status.affecting.hp
                })

                updateStats({actors: player_conjoined})
            },
        }
    },
	
	env.STATUS_EFFECTS.ominous_timer_short = { 
        slug: "ominous_timer_short",
        name: "Ominous Timer",
        skipTurn: true,
        infinite: true,
		icon: "https://corru.observer/img/sprites/combat/statuses/ominous_timer.gif",

        events: {
            onDeath: function() {
                clearInterval(this.status.countdown)
            },

            onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "ominous_timer_short") clearInterval(this.status.countdown)
            },

            onCreated: function({statusObj}) {
                console.log('created bomb with', statusObj)
                if(statusObj.slug != "ominous_timer_short" || this.status.timeRemaining) return;

                this.status.timeRemaining = 45
                let thisSprite = this.status.affecting.sprite
                let thisGuy = this.status.affecting
                let thisStatus = this.status

                function updateTimer() {  
                    if(thisSprite) thisSprite.querySelector(".timer").innerHTML = `<span>${thisStatus.timeRemaining}</span>`

                    if (thisStatus.timeRemaining === 0 && !thisStatus.exploded && env.rpg.active) {
                        clearInterval(thisStatus.countdown) 
                        thisStatus.exploded = true

                        thisGuy.actions = ["detonate_weak"]
                        thisGuy.sprite.classList.add("detonate-ready")

                        sendFloater({
                            target: thisGuy,
                            type: "arbitrary",
                            arbitraryString: "DETONATION IMMINENT",
                            size: 1.5,
                            isGood: false
                        })

                        readoutAdd({
                            message: `${thisGuy.name} is about to detonate!`, 
                            name: "sourceless", 
                            type: "sourceless combat minordetail",
                            show: false,
                            sfx: false
                        })

                        removeStatus(thisGuy, "ominous_timer_short")

                    } else {
                        if(!hasStatus(thisGuy, "stun") && !hasStatus(thisGuy, "hyperstun")) {
                            thisStatus.timeRemaining--
                        }

                    }
                }
            
                updateTimer() // Initial call to display the timer immediately
            
                this.status.countdown = setInterval(updateTimer, 1000)
            },
        },

        help: "unknown, asynchronous effect",
    },
	
	env.STATUS_EFFECTS.ominous_timer_long = { 
        slug: "ominous_timer_long",
        name: "Ominous Timer",
        skipTurn: true,
        infinite: true,
		icon: "https://corru.observer/img/sprites/combat/statuses/ominous_timer.gif",

        events: {
            onDeath: function() {
                clearInterval(this.status.countdown)
            },

            onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "ominous_timer_long") clearInterval(this.status.countdown)
            },

            onCreated: function({statusObj}) {
                console.log('created bomb with', statusObj)
                if(statusObj.slug != "ominous_timer_long" || this.status.timeRemaining) return;

                this.status.timeRemaining = 180
                let thisSprite = this.status.affecting.sprite
                let thisGuy = this.status.affecting
                let thisStatus = this.status

                function updateTimer() {  
                    if(thisSprite) thisSprite.querySelector(".timer").innerHTML = `<span>${thisStatus.timeRemaining}</span>`

                    if (thisStatus.timeRemaining === 0 && !thisStatus.exploded && env.rpg.active) {
                        clearInterval(thisStatus.countdown) 
                        thisStatus.exploded = true

                        thisGuy.actions = ["detonate_mega"]
                        thisGuy.sprite.classList.add("detonate-ready")

                        sendFloater({
                            target: thisGuy,
                            type: "arbitrary",
                            arbitraryString: "DETONATION IMMINENT",
                            size: 1.5,
                            isGood: false
                        })

                        readoutAdd({
                            message: `${thisGuy.name} is about to detonate!`, 
                            name: "sourceless", 
                            type: "sourceless combat minordetail",
                            show: false,
                            sfx: false
                        })

                        removeStatus(thisGuy, "ominous_timer_long")

                    } else {
                        if(!hasStatus(thisGuy, "stun") && !hasStatus(thisGuy, "hyperstun")) {
                            thisStatus.timeRemaining--
                        }

                    }
                }
            
                updateTimer() // Initial call to display the timer immediately
            
                this.status.countdown = setInterval(updateTimer, 1000)
            },
        },

        help: "unknown, asynchronous effect",
    },
	
	env.STATUS_EFFECTS.debug_incomingCrit = { 
        slug: "debug_incomingCrit",
        name: "Crittable",
        incomingToHit: 999,
        incomingCrit: 999,
		incomingFlatCrit: 999,
		passive: true,
        help: "+100000% IN:HIT%, +100000% IN:CRIT%",
    },
	
	env.STATUS_EFFECTS.autoplay_incoherent = { // NOTE TO OTHER MODDERS::MAKE SURE NOTHING CAN GIVE THIS STATUS EFFECT, IT'S ONLY DESIGNED FOR THE BOSSFIGHT
        slug: "autoplay_incoherent",
        name: "Disconnected",
        beneficial: true,
        help: "acting of its own volition",
        icon: "/img/sprites/combat/statuses/disconnected.gif",
        infinite: true,
        passive: true,
        skipTurn: true,
		skipTurnException: true,
		inversionCooldown: false, // these are surprise tools that will help us later
		isStunned: false,
		isAfraid: false,
		hasSurge: false,
		//hasStatusRestrictions: false,
		combatReady: false, 
		canFight: true,
		hasRevived: false, // oops, disconnected breaks if it can get revived !!
		
        events: {
			onCreated: function({statusObj}) {
				console.log('created incoherent combatant, starting initial cooldown')
				let self = this
				let status = this.status
				function onTurnAsync() { // this is the thing that makes it fight asynchronously!!!!!!
					let rand = Math.random()
					let nextTarget = env.rpg.allyTeam.members.filter(member => member.state == "living").sample()
					let availableActions = ["mad_claw_mega", "mad_claw_mega", "husk_attack_light", "husk_attack_light", "special_invite_storm_noadvance", "special_inversion_noadvance", "surge"]
					if(status.hasSurge || this.status.isAfraid) { // if you already have surge, don't give yourself surge again, and if you have fear, don't give yourself focused via surge
						availableActions = ["mad_claw_mega", "mad_claw_mega", "husk_attack_light", "husk_attack_light", "special_invite_storm_noadvance", "special_inversion_noadvance"]
					}
					if(status.inversionCooldown) { // if you used inversion recently, don't do it again until the cooldown rolls over
						availableActions = ["mad_claw_mega", "mad_claw_mega", "husk_attack_light", "husk_attack_light", "special_invite_storm_noadvance", "surge"]
					}
					if(status.inversionCooldown && status.hasSurge || status.isAfraid) { // this probably wouldn't be necessary if we used .filter() but eh
						availableActions = ["mad_claw_mega", "mad_claw_mega", "husk_attack_light", "husk_attack_light", "special_invite_storm_noadvance"]
					}
					let nextAction = availableActions.sample()
					console.log(`next action is::${env.ACTIONS[nextAction].name}, if this appears twice in a row in rapid succession something is wrong!!`)
					useAction(status.affecting, env.ACTIONS[nextAction], nextTarget, {beingUsedAsync: true, reason: "SVMgVEhJUyBSRUFMPw=="}) // this better work so help me god
				
					let defaultInterval = 5000 * 2 // make attack speed semi-random
					let slowInterval = 7000 * 2
					let fastInterval = 3000 * 2
					if(status.isStunned && !status.hasSurge) {
						defaultInterval = 10000 * 2
						slowInterval = 14000 * 2
						fastInterval = 6000 * 2
					} else if(status.hasSurge && !status.isStunned) {
						defaultInterval = 2500 * 2
						slowInterval = 3500 * 2
						fastInterval = 1500 * 2
					}
					let nextInterval = 5000 * 2
					if(rand < 0.3) { // change the attack speed maybe
						nextInterval = slowInterval
					}
					else if(rand < 0.6) {
						nextInterval = fastInterval
					}
					else {
						nextInterval = defaultInterval
					}
					setTimeout(()=>{
						if(status.canFight) {
							onTurnAsync(); // loops the onTurnAsync function, emulating an asynchronous "turn order" of sorts
						}
					}, nextInterval)
				}
				
				setTimeout(()=>{ // this is part of da onCreated function by the way
					if(!this.status.combatReady) {
						this.status.combatReady = true
						addStatus({target: this.status.affecting, status: "incoherent", length: 1, noReact: true}) // telegraph that the Shenanigans are beginning
						console.log('this creature is combat ready!! en garde!!!!')
						onTurnAsync();
					} else { console.log("we're already combat ready, blease don't call onTurnAsync again") } // this one's a funny story
                }, 5000 * 2, this.status.affecting, this.status) // turns out onCreated isn't called when the status is created for this actor, its when ANY status is created for this actor
			}, // it was so confusing to debug...
			
			onAddStatus: function({statusObj}) {
				if(statusObj.slug == "surge") {
					this.status.hasSurge = true // doubles attack speed
					setTimeout(()=>{
						removeStatus(this.status.affecting, "surge")
						this.status.hasSurge = false // why does onRemoveStatus not do this on its own? great question, i would also like to know
					}, 10000, this.status)
				}
				if(statusObj.skipTurn && !statusObj.skipTurnException) { // adding skipTurnException just to be safe
					this.status.isStunned = true // halves attack speed
					removeStatus(this.status.affecting, "surge")
					this.status.hasSurge = false
				}
				if(statusObj.slug == "fear") {
					this.status.isAfraid = true
				}
			},
			onRemoveStatus: function({removingStatusName}) {
				let stunEffects = ["stun", "hyperstun"] // for reasons unclear to me, onRemoveStatus doesn't have the same statusObj context that onAddStatus does, so we have to do this shit instead
				if(check("modList").includes("e3a2_morevelziesgleestatuses")) {
					stunEffects = ["stun", "hyperstun", "dazed"]
				}
				if(removingStatusName == "surge") {
					this.status.hasSurge = false
				}
				if(stunEffects.includes(removingStatusName)) {
					this.status.isStunned = false
				}
				if(removingStatusName == "fear") {
					this.status.isAfraid = false
				}
			},
			onAction: function({user, action, target}) {
                if(action.slug == "special_inversion_noadvance") {
					this.status.inversionCooldown = true // prevents inverting everything twice in a row
					setTimeout(()=>{
						this.status.inversionCooldown = false
					}, 15000 * 2, this.status) // the reason all the intervals are multiplied like this is because they were all a lot shorter originally
				} // turns out 3-7 seconds between attacks is terrifyingly fast when its asynchronous, so i just slapped * 2 onto everything :P
            },
			onDeath: function() {
				if(hasStatus(this.status.affecting, "zuka_grail")) {
					setTimeout(()=>{
						this.status.hasRevived = true
						console.log("incoherent combatant just self revived!!")
					}, 1000, this.status)
					if(this.status.hasRevived == true) { this.status.canFight = false }
				}
				else this.status.canFight = false // it might try to keep attacking if we don't do this, which would be Very Bad
			}
		}
    }, 
	
	env.STATUS_EFFECTS.ominous_timer_cmb = { 
        slug: "ominous_timer_cmb",
        name: "Singularity",
        infinite: true,
		icon: "/img/sprites/combat/statuses/overlap_collapse.gif",

        events: {
            onDeath: function() {
                clearInterval(this.status.countdown)
            },

            onRemoveStatus: function({target, removingStatusName}) {
                if(removingStatusName == "ominous_timer_cmb") clearInterval(this.status.countdown)
            },

            onCreated: function({statusObj}) {
                console.log('created bomb with', statusObj)
                if(statusObj.slug != "ominous_timer_cmb" || this.status.timeRemaining) return;

                this.status.timeRemaining = 600
                let thisSprite = this.status.affecting.sprite
                let thisGuy = this.status.affecting
                let thisStatus = this.status

                function updateTimer() {  
                    if(thisSprite) thisSprite.querySelector(".timer").innerHTML = `<span>${thisStatus.timeRemaining}</span>`

                    if (thisStatus.timeRemaining === 0 && !thisStatus.exploded && env.rpg.active) {
                        clearInterval(thisStatus.countdown) 
                        thisStatus.exploded = true

                        thisGuy.actions = ["detonate_mega_cmb"]
                        thisGuy.sprite.classList.add("detonate-ready")

                        sendFloater({
                            target: thisGuy,
                            type: "arbitrary",
                            arbitraryString: "SINGULARITY IMMINENT",
                            size: 2,
                            isGood: false
                        })

                        readoutAdd({
                            message: `${thisGuy.name} is about to detonate!`, 
                            name: "sourceless", 
                            type: "sourceless combat minordetail",
                            show: false,
                            sfx: false
                        })

                        removeStatus(thisGuy, "ominous_timer_cmb")

                    } else {
                        if(!hasStatus(thisGuy, "stun") && !hasStatus(thisGuy, "hyperstun")) {
                            thisStatus.timeRemaining--
                        }
                    }
                }
            
                updateTimer() // Initial call to display the timer immediately
            
                this.status.countdown = setInterval(updateTimer, 1000)
            },
        },

        help: "asynchronous effect\ncombat will be lost in ten minutes",
    },
	
	env.STATUS_EFFECTS.appeasement_mega = { 
        slug: "appeasement_mega",
        name: "Appeasement++",
        help: `when an ally dies, take their max HP * 4 in damage\nwhen defeated, also defeat all other allies`,
        beneficial: false,
        infinite: true,
		icon: "/img/sprites/combat/statuses/appeasement.gif",
        
        events: {
            GLOBAL_onDeath: function({originalEventTarget}) {
                let subject = originalEventTarget
                let user = this.status.affecting

                if(
                    user.team.name != subject.team.name || 
                    subject.state != "dead"
                ) return;

                let incomingDamage = Math.floor(subject.maxhp * 4)

                setTimeout(()=>{
                    playCombatCrit("dull", 0.8)
                    combatHit(this.status.affecting, {amt: incomingDamage, autohit: true, redirectable: false, runEvents: false})

                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "APPEASED!",
                        beneficial: false
                    })
                
                    readoutAdd({
                        message: `${user.name} is damaged for ${incomingDamage}HP as ${subject.name} falls! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                    updateStats({actor: user})
                }, env.ADVANCE_RATE * 0.2)
            },

            onDeath: function() {
                let user = this.status.affecting
                play("talkfairy")
                user.team.members.forEach(member=>member.hp = 0)
                updateStats()
            }
        }
    },
	
	env.STATUS_EFFECTS.eyes_humorist = {
        slug: "eyes_humorist",
        name: "Data Packet",
        passive: true,
        beneficial: true,
        icon: "/img/sprites/combat/passives/yeyetiny.gif",
        impulse: {type: "common", component: "eyes"},
		help: `no effect in combat\nin peace, unlock new iteration revision`,
		events: {
			onTurn: function() {
				console.log("it doesn't seem to show up without an events property, so here's some console logs")
			}
		}
    },
	
	env.STATUS_EFFECTS.claws_humorist = {
        slug: "claws_humorist",
        name: "Call To Arms",
        passive: true,
        beneficial: true,
        icon: "/img/sprites/combat/passives/meyetiny.gif",
        impulse: {type: "common", component: "claws"},
		help: `no effect in combat\nin peace, unlock new iteration revision`,
		events: {
			onTurn: function() {
				console.log("it doesn't seem to show up without an events property, so here's some console logs")
			}
		}
    },
	
	env.STATUS_EFFECTS.retaliation_soldier = {
        slug: "retaliation_soldier",
        name: "ACTION::Retaliate",
        passive: true,
        beneficial: true,
        icon: "/img/sprites/combat/passives/retaliation.gif",
        
        events: {
            //in evades, the 'subject' is the origin of the attack
            GLOBAL_onEvade: function({subject, target, attack, originalEventTarget}) {
                let user = this.status.affecting
                if(
                    !user.enemyTeam.members.includes(subject) || 
                    subject.state == "dead" ||
                    user.state == "dead" ||
                    target == user ||
                    hasStatus(user, "fear")
                ) return;

                let primary = env.ACTIONS.soldier_kick

                setTimeout(()=>{
                    useAction(this.status.affecting, primary, subject, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "retaliation"})
            
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "action",
                        arbitraryString: `RETALIATE::${primary.name.toUpperCase()}`,
                        size: 1.5,
                    })

                    readoutAdd({
                        message: `${user.name} retaliates against ${subject.name} as they miss! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
        },

        help: `if alive, on ally evade, retaliate against attacker with primary (1st) action`
    },
	
	env.STATUS_EFFECTS.rewardsHandler = {
        slug: "rewardsHandler",
        name: "Item Carrier",
		passive: true,
        beneficial: true,
		silent: true,
        icon: "/img/sprites/combat/passives/light_glee.gif",
        help: "this actor will give rewards on death\nyou should never see this",
		events: {
            onDeath: function() {
                let user = this.status.affecting
				if(user.slug.includes("bstrdboss_bfg") && !check("reward_bfg")) change("reward_bfg", "bfg_collected") // this should work
				if(user.slug.includes("bstrdboss_grenade") && !check("reward_grenade")) change("reward_grenade", "grenade_collected")
				if(user.slug.includes("bstrdboss_rifle") && !check("reward_rifle")) change("reward_rifle", "rifle_collected")
				if(user.slug.includes("bstrdboss_shotgun") && !check("reward_shotgun")) change("reward_shotgun", "shotgun_collected")
				if(user.slug.includes("bstrdboss_sniper") && !check("reward_sniper")) change("reward_sniper", "sniper_collected")
            },
        }
    },
	
	env.STATUS_EFFECTS.visionary_amr = {
        slug: "visionary_amr",
        name: "Visionary (Sniper)",
        passive: true,
        beneficial: true,
        icon: "/img/sprites/combat/passives/visionary_geli.gif",
        
        events: {
            onCrit: function({subject, origin, attack, beneficial}) {
                let user = this.status.affecting
                console.log('visionary', subject, origin, attack, beneficial, '\n', beneficial, user.team.members.includes(subject), user.state == "dead")
                if(beneficial || user.team.members.includes(subject) || user.state == "dead") return;
                
                setTimeout(()=>{
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "action",
                        arbitraryString: "VISIONARY::RAISE WEAPON",
                        size: 1.5,
                    })

                    readoutAdd({
                        message: `${user.name} stays focused! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                    
                    useAction(user, env.ACTIONS[user.actions[1]], subject, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "visionary"})
                }, 500)
            }
        },

        help: `when critting a foe, use utility action (windup)`
    },
	
	env.STATUS_EFFECTS.frenzyHandler = {
        slug: "frenzyHandler",
        name: "frenzyHandler",
		passive: true,
        beneficial: true,
		silent: true,
        icon: "/img/sprites/combat/passives/fated_light.gif",
        help: "-9999% CRIT% if a frenzy chain reaches 250 total actions\nyou should never see this",
		events: {
            onAction: function({user, action, target}) {
				if(!this.status.actionCount) this.status.actionCount = 1
				else this.status.actionCount = this.status.actionCount + 1 // surely this won't cause any problems for us <---- this was the only fucking thing that worked for us the first time. velzie delights in my torment
				
				if(this.status.actionCount >= 250) {
					console.log("frenzy chain threshold reached!!!!")
					//this.status.outgoingCrit = -999
					this.status.affecting.frenzyChainKilled = true // this is some bullshit and i hate it
					//this.status.outgoingToHit = -999 // the fucking crit rate thing doesn't even WORK !!!!!!!!!!!! FUCK !!!!!!!!!!!!!!!!!!!!!
					//playCombatCrit("criticalError", 1, 0.25)
				}
            },

			GLOBAL_onTurn: function() {
				if(this.status.outgoingCrit == -999) this.status.outgoingCrit = 0
				if(this.status.actionCount) delete this.status.actionCount
				//else console.log("actionCount does not exist, so we won't delete it. also comment this out once everything's working probably")
				if(this.status.affecting.frenzyChainKilled == true) this.status.affecting.frenzyChainKilled = false
			}
        }
    }
	
	env.COMBAT_ACTORS.generic.initialStatusEffects = [["frenzyHandler", 1]]
	
	// this is such fucking bullshit oh my god
	env.ACTIONS.frenzy.exec.critExec = ({target})=> { // -999 outgoingCrit wasn't enough???? what the fuck????????
		if(target.hp > 0 && target.state != "lastStand" && !user.frenzyChainKilled) { // -999 outgoingToHit and nothing misses. what do you mean by that. Die
			env.setTimeout(()=>{
				useAction(user, this, target, {beingUsedAsync: true, reason: "frenzy", actionMessageIndex})
			}, 400)
		}
	}


// COMBAT ACTORS
env.COMBAT_ACTORS.player_hallucination = {
    name: "Â»ÃµGQÃ Âº3Â¾Ãµâ€cR%",
    maxhp: 3,
    hp: 3,
    actions: ["speak", "husk_attack_weak"],
    graphic: `
        <div class="sprite-wrapper hallucination" id="%SLUG-sprite-wrapper">
            <div class="sprite-overflow spritestack">
                <img class="sprite basis" src="/img/sprites/combat/foes/hallucinations/akizet.png" id="%SLUG-sprite">
                <img class="sprite base" src="/img/sprites/combat/foes/hallucinations/akizet.png" id="%SLUG-sprite">
                <img class="sprite eyes" src="/img/sprites/combat/foes/hallucinations/akizet_eyes.png" id="%SLUG-sprite">
            </div>
            <div class="target" entity="Â»ÃµGQÃ Âº3Â¾Ãµâ€cR%"></div>
        </div>
        `,
    reactions: {},
    initialStatusEffects: [["player_ethereal", 1]],
    turnCheck: "player_hallucinations",
    events: {
        onSpriteCreation: (sprite) => {
            if(!sprite) return

            let basis = sprite.querySelector('img.basis')
            let base = sprite.querySelector('img.base')
            let eyes = sprite.querySelector('img.eyes')

            if(env.hallucinator == "generic") {
                basis.src = `/img/sprites/combat/foes/hallucinations/gakvu.png`
                base.src = `/img/sprites/combat/foes/hallucinations/gakvu.png`
                eyes.src = `/img/sprites/combat/foes/hallucinations/gakvu_eyes.png`
            } else {
                basis.src = `/img/sprites/combat/foes/hallucinations/${env.hallucinator}.png`
                base.src = `/img/sprites/combat/foes/hallucinations/${env.hallucinator}.png`
                eyes.src = `/img/sprites/combat/foes/hallucinations/${env.hallucinator}_eyes.png`                    
            }
        },
    }
}

    // warped daemons/special actors
env.COMBAT_ACTORS.player_dull_bstrdlight = {
    name: "Warped BSTRDlight",
    maxhp: 14,
    hp: 10,
    actions: ["spy_weak", "mend_weak", "special_mass_destabilize", "swipe_weak", "rez_player"],
    graphic: `
        <div class="sprite-wrapper" id="%SLUG-sprite-wrapper">
            <div class="veilksprite bstrdlight">
                <img class="sprite" src="/img/sprites/combat/foes/bstrdlampbase.gif" id="%SLUG-sprite">
            </div>
            <div class="target" entity="bstrdlight"></div>
        </div>
        `,
    reactions: {
        catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
        dead: ["Â¿", "???"]
    },
    initialStatusEffects: [["player_ethereal", 1],["perma_vulnerable", 1]],
}

env.COMBAT_ACTORS.player_dull_critta_pawn = {
    name: "WRPD WRK",
    specialClass: "daemonactor",
    maxhp: 7,
    actions: ["revise_weak", "mad_claw_weak", "evade_weak"],
    graphic: `
        <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
            <div class="target" entity="wrk"></div>
            <figure class="daemon pawn accurate-position"> 
                <img src="/img/sprites/daemons/pawn/base.gif">
                <div class="eye"></div>
                <div class="scraps noimg">
                    <div class="scrap"></div>
                    <div class="scrap"></div>
                    <div class="scrap"></div>
                    <div class="scrap"></div>
                    <div class="scrap"></div>
                </div>
            </figure>
        </div>
        `,
    reactions: {}, //SILENT CREATURE
    events: {
        onSpawn: () => change("daemon", "saw")
    },
    initialStatusEffects: [["player_ethereal", 1],["daemon_malfunction", 1]],
}

env.COMBAT_ACTORS.player_dull_critta_knight = {
    name: "WRPD CLW",
    specialClass: "daemonactor",
    maxhp: 10,
    actions: ["cripple_weak", "exploit_weak", "surge_weak"],
    graphic: `
        <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
            <div class="target" entity="clw"></div>
            <figure class="daemon rook accurate-position">
                <img src="/img/sprites/daemons/rook/body.gif">
                <div class="eye"></div>
                <div class="eye"></div>
                <div class="eye"></div>
                <div class="eye"></div>
                <div class="eye"></div>
                <div class="leftarm">
                    <div class="downarm">
                        <div class="upclaw"></div>
                        <div class="downclaw"></div>
                    </div>
                </div>
                <div class="rightarm">
                    <div class="downarm">
                        <div class="upclaw"></div>
                        <div class="downclaw"></div>
                    </div>
                </div>
            </figure>
            
        </div>
        `,
    reactions: {}, //SILENT CREATURE
    events: {
        onSpawn: () => change("daemon", "saw")
    },
    initialStatusEffects: [["player_ethereal", 1],["daemon_malfunction", 1]],
}

env.COMBAT_ACTORS.player_dull_critta_bishop = {
    name: "WRPD NET",
    specialClass: "daemonactor",
    maxhp: 8,
    actions: ["speak_weak", "parasite_weak", "empower", "rez_player"],
    graphic: `
        <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
            <div class="target" entity="net"></div>
            <figure class="daemon bishop accurate-position">
                <img src="/img/sprites/daemons/bishop/base.gif">
                <div class="eye"></div>
                <div class="tendril"></div>
                <div class="tendril"></div>
                <div class="tendril"></div>
                <div class="tendril"></div>
                <div class="tendril"></div>
            </figure>
        </div>
        `,
    reactions: {}, //SILENT CREATURE
    events: {
        onSpawn: () => change("daemon", "saw")
    },
    initialStatusEffects: [["player_ethereal", 1],["daemon_malfunction"]],
}

env.COMBAT_ACTORS.player_dull_critta_rook = {
    name: "WRPD ENFC",
    specialClass: "daemonactor",
    maxhp: 14,
    actions: ["enforce", "focused_guard"],
    graphic: `
        <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
            <div class="target" entity="enfc"></div>
            <figure class="daemon knight accurate-position">
                <img src="/img/sprites/daemons/knight/body.gif">
                <div class="eye"></div>
                <div class="eye"></div>
                <div class="eye"></div>
                <div class="eye"></div>
                <div class="eye"></div>
                <div class="uparm">
                    <div class="downarm">
                        <div class="upclaw"></div>
                        <div class="downclaw"></div>
                    </div>
                </div>
            </figure>
        </div>
        `,
    reactions: {}, //SILENT CREATURE
    events: {
        onSpawn: () => change("daemon", "saw")
    },
    initialStatusEffects: [["player_ethereal", 1],["daemon_malfunction", 1]],
}

env.COMBAT_ACTORS.player_dull_critta_queen = {
    name: "WRPD SEER",
    specialClass: "daemonactor",
    maxhp: 15,
    actions: ["windup"],
    windupActions: ["special_rule_weak", "daemon_wound"],
    graphic: `
        <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
            <div class="target" entity="seer"></div>
            <figure class="daemon queen accurate-position">
                <img src="/img/sprites/daemons/queen/core.gif">
                <div class="eye"></div>
                <div class="ring"></div>
                <div class="ring"></div>
                <div class="ring"></div>
            </figure>
        </div>
        `,
    reactions: {}, //SILENT CREATURE
    events: {
        onSpawn: () => change("daemon", "saw")
    },
    initialStatusEffects: [["player_ethereal", 1],["daemon_malfunction", 1]],
}

env.COMBAT_ACTORS.player_dull_critta_king = {
    name: "WRPD ARCHN",
    specialClass: "daemonactor",
    maxhp: 17,
    actions: ["windup"],
    windupActions: ["special_judgement_weak"],
    graphic: `
        <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
            <div class="target" entity="archn"></div>
            <figure class="daemon king accurate-position">
                <img src="/img/sprites/daemons/king/angles.gif">
                <img src="/img/sprites/daemons/king/angles.gif">
                <div class="box center"></div>
                <div class="box outer"></div>
                <div class="ring"></div>
                <div class="eye"></div>
            </figure>
        </div>
        `,
    reactions: {}, //SILENT CREATURE
    events: {
        onSpawn: () => change("daemon", "saw")
    },
    initialStatusEffects: [["player_ethereal", 1],["daemon_malfunction", 1]],
}

env.COMBAT_ACTORS.player_dull_critta_dragon = {
    name: "WRPD IDL",
    specialClass: "daemonactor",
    maxhp: 20,
    actions: ["special_player_daemon_guard"],
    graphic: `
        <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
            <div class="target" entity="seer"></div>
            <figure class="daemon queen accurate-position">
                <img src="/img/sprites/daemons/queen/core.gif">
                <div class="eye"></div>
                <div class="ring"></div>
                <div class="ring"></div>
                <div class="ring"></div>
            </figure>
        </div>
        `,
    reactions: {}, //SILENT CREATURE
    events: {
        onSpawn: () => change("daemon", "saw")
    },
    initialStatusEffects: [["player_ethereal", 1],["daemon_malfunction", 1]],
}

env.COMBAT_ACTORS.player_dull_critta_unicorn = {
    name: "WRPD MOD",
    specialClass: "daemonactor",
    maxhp: 10,
    actions: ["special_daemon_fullauto","daemon_floor_it","daemon_windup"],
    windupActions: ["special_daemon_fullerauto"],
    graphic: `
        <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
            <div class="target" entity="clw"></div>
            <figure class="daemon rook accurate-position">
                <img src="/img/sprites/daemons/rook/body.gif">
                <div class="eye"></div>
                <div class="eye"></div>
                <div class="eye"></div>
                <div class="eye"></div>
                <div class="eye"></div>
                <div class="leftarm">
                    <div class="downarm">
                        <div class="upclaw"></div>
                        <div class="downclaw"></div>
                    </div>
                </div>
                <div class="rightarm">
                    <div class="downarm">
                        <div class="upclaw"></div>
                        <div class="downclaw"></div>
                    </div>
                </div>
            </figure>
            
        </div>
        `,
    reactions: {}, //SILENT CREATURE
    events: {
        onSpawn: () => change("daemon", "saw")
    },
    initialStatusEffects: [["player_ethereal", 1],["daemon_malfunction", 1]],
}

env.COMBAT_ACTORS.player_dull_critta_princess_defensive = {
    name: "WRPD GPU",
    specialClass: "daemonactor",
    maxhp: 8,
    actions: ["daemon_tesselate", "daemon_plot", "special_daemon_enact_gpu"],
    graphic: `
        <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
            <div class="target" entity="net"></div>
            <figure class="daemon bishop accurate-position">
                <img src="/img/sprites/daemons/bishop/base.gif">
                <div class="eye"></div>
                <div class="tendril"></div>
                <div class="tendril"></div>
                <div class="tendril"></div>
                <div class="tendril"></div>
                <div class="tendril"></div>
            </figure>
        </div>
        `,
    reactions: {}, //SILENT CREATURE
    events: {
        onSpawn: () => change("daemon", "saw")
    },
    initialStatusEffects: [["player_ethereal", 1],["daemon_malfunction", 1]],
}

env.COMBAT_ACTORS.player_dull_critta_princess_offensive = {
    name: "WRPD CPU",
    specialClass: "daemonactor",
    maxhp: 8,
    actions: ["daemon_cull", "daemon_plot", "special_daemon_enact_cpu"],
    graphic: `
        <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
            <div class="target" entity="net"></div>
            <figure class="daemon bishop accurate-position">
                <img src="/img/sprites/daemons/bishop/base.gif">
                <div class="eye"></div>
                <div class="tendril"></div>
                <div class="tendril"></div>
                <div class="tendril"></div>
                <div class="tendril"></div>
                <div class="tendril"></div>
            </figure>
        </div>
        `,
    reactions: {}, //SILENT CREATURE
    events: {
        onSpawn: () => change("daemon", "saw")
    },
    initialStatusEffects: [["player_ethereal", 1],["daemon_malfunction", 1]],
}

env.COMBAT_ACTORS.player_dull_critta_princess_hybrid = {
    name: "WRPD MTHRBRD",
    specialClass: "daemonactor",
    maxhp: 15,
    actions: ["special_greater_cull", "special_greater_tesselate", "surge"],
    graphic: `
        <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
            <div class="target" entity="net"></div>
            <figure class="daemon bishop accurate-position">
                <img src="/img/sprites/daemons/bishop/base.gif">
                <div class="eye"></div>
                <div class="tendril"></div>
                <div class="tendril"></div>
                <div class="tendril"></div>
                <div class="tendril"></div>
                <div class="tendril"></div>
            </figure>
        </div>
        `,
    reactions: {}, //SILENT CREATURE
    events: {
        onSpawn: () => change("daemon", "saw")
    },
    initialStatusEffects: [["player_ethereal", 1],["daemon_malfunction", 1]],
}

env.COMBAT_ACTORS.player_dull_critta_superknight = {
    name: "WRPD DEL",
	specialClass: "daemonactor",
    maxhp: 15,
    hp: 15,
    actions: ["windup"],
    windupActions: ["daemon_smash"],
    graphic: `
        <div class="sprite-wrapper archival-golem golemsprite" id="%SLUG-sprite-wrapper">
            <div class="sprite-overflow spritestack">
                <img src="/img/sprites/combat/foes/archivalgolem.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                
                <div class="sprite golemsprite-head">
                    <img src="/img/sprites/combat/foes/archivalgolem-head.gif" id="%SLUG-golemsprite-head">
                </div>
                <img src="/img/sprites/combat/foes/archivalgolem-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                <img src="/img/sprites/combat/foes/archivalgolem-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
            </div>

            <div class="target" entity="archival golem"></div>
        </div>
        `,
    reactions: { //SILENT CREATURE
    },
    initialStatusEffects: [["player_ethereal", 1],["daemon_malfunction", 1]],
}

env.COMBAT_ACTORS.critta_superknight = {
    name: "DEL",
	specialClass: "daemonactor",
    maxhp: 45,
    hp: 45,
    actions: ["windup"],
    windupActions: ["daemon_smash"],
    graphic: `
        <div class="sprite-wrapper daemon_del superknightsprite" id="%SLUG-sprite-wrapper">
            <div class="sprite-overflow spritestack">
                <img src="https://narrativohazard-expunged.neocities.org/img/bstrdsing_wholesprite-DEL-gifver_mimic.gif" style="max-height: 405px; max-width: 945px;" id="%SLUG-superknightsprite-whole" class="sprite superknightsprite-whole">

            <div class="target" entity="archival golem"></div>
        </div>
        `,
    reactions: { //SILENT CREATURE
    },
}

    env.COMBAT_ACTORS.player_dull_critta_spawner = {
        name: "WRPD SPWN",
        maxhp: 166,
        specialClass: "mainfoe daemonactor",
        actions: ["special_chant_mega_weak"],
        statusImmunities: ["stun"],
        graphic: `
            <div class="sprite-wrapper daemonsprite jester" id="%SLUG-sprite-wrapper">
                <div class="target" entity="spwn"></div>
                <figure class="daemon spawner" style="animation-delay: -4s">
                    <img src="/img/sprites/daemons/spawner/body.gif">
                    <img src="/img/sprites/daemons/spawner/body.gif">
                </figure>
            </div>
            `,
        events: {
            onSpawn: () => change("daemon", "saw")
        },
		initialStatusEffects: [["player_ethereal", 1],["daemon_malfunction", 1],["high_priority", 1]],
    }

    env.COMBAT_ACTORS.player_critta_spawner_bee = {
        name: "IDEA",
        specialClass: "daemonactor",
        maxhp: 10,
        actions: ["husk_attack_rot", "surge"],
        initialStatusEffects: [["ethereal", 1]],
        turnCheck: "genericEthereal",
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="idea"></div>
                <figure class="daemon bee"><div class="sides"><span></span><span></span><span></span><span></span><span></span><span></span></div></figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
		initialStatusEffects: [["player_ethereal", 1]],
    }

    //warped boss actors
env.COMBAT_ACTORS.player_dull_movefriend = {
    slug: "player_dull_movefriend",
    name: "Warped Movefoe",
    maxhp: 20,
    hp: 20,
    statusImmunities: ["stun"],
    actions: ["movefriend_attack_weak", "special_mass_destabilize", "special_playershelf_annihilate_movefriend","special_player_movefriendsummon"],
    graphic: `
        <div class="sprite-wrapper" id="%SLUG-sprite-wrapper">
            <div class="lifter sprite"><figure></figure></div>
            <div class="target" entity="movefoe"></div>
        </div>
        `,
    reactions: {}, //SILENT CREATURE
    initialStatusEffects: [["player_ethereal", 1],["perma_vulnerable", 1],["high_priority", 1]],
}

env.COMBAT_ACTORS.player_dull_tendrils = {
    name: "Warped Tendril",
    turnCheck: "tendrils",
    maxhp: 3,
    hp: 3,
    actions: ["swipe_weak"],
    graphic: `
        <div class="sprite-wrapper" id="%SLUG-sprite-wrapper">
            <img class="sprite" src="/img/sprites/combat/foes/tendrils.gif" id="%SLUG-sprite">
            <div class="target" entity="tendrils"></div>
        </div>
        `,
    reactions: {},
    initialStatusEffects: [["player_ethereal", 1],["perma_vulnerable", 1]],
}

env.COMBAT_ACTORS.player_dull_bstrdshelf = {
    name: "Warped Pain Shelf",
    maxhp: 24,
    hp: 20,
    actions: ["special_playershelf_annihilate_painshelf"],
    graphic: `
        <div class="sprite-wrapper bstrdshelf" id="%SLUG-sprite-wrapper">
            <img class="sprite" src="/img/sprites/combat/foes/archivalfoea.gif">
            <div class="target" entity="pain shelf"></div>
        </div>
        `,
    reactions: {
        catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
        dead: ["Â¿", "???"]
    },
    initialStatusEffects: [["player_ethereal", 1],["perma_vulnerable", 1],["high_priority", 1]],
}

env.COMBAT_ACTORS.player_dull_gungolem = {
    slug: "player_dull_gungolem",
    name: "Gun Golem",
    maxhp: 16,
    hp: 16,
    statusImmunities: ["stun"],
    actions: ["player_special_dullauto"],
    graphic: `
        <div class="sprite-wrapper archival-golem bstrd-golem golemsprite" id="%SLUG-sprite-wrapper">
            <div class="sprite-overflow spritestack">
                <img src="/img/sprites/combat/foes/bstbody.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                
                <div class="sprite golemsprite-head">
                    <img src="/img/sprites/combat/foes/bsthead.gif" id="%SLUG-golemsprite-head">
                    <img src="/img/sprites/combat/foes/bstface.gif" id="%SLUG-golemsprite-face">
                </div>
                <img src="/img/sprites/combat/foes/bstbody.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                <img src="/img/sprites/combat/foes/bstgun.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms gunlower">
                <img src="/img/sprites/combat/foes/bstgunraise.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms gunraise">
                <img src="/img/sprites/combat/foes/bstgunblam.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms gunblam">
            </div>

            <div class="target" entity="bstrd golem"></div>
        </div>
        `,
    reactions: {}, //SILENT CREATURE
    initialStatusEffects: [["player_ethereal", 1],["dull_malfunction", 1],["high_priority", 1]],
}

env.COMBAT_ACTORS.player_dull_translation_core = {
    name: "Warped Translation Core",
    maxhp: 27,
    hp: 27,
    actions: ["special_player_chant_weak"],
    statusImmunities: ["stun"],
    graphic: `
        <div class="sprite-wrapper wordfriend" id="%SLUG-sprite-wrapper">
            <div class="spinny">
                <img src="/img/sprites/combat/foes/translator_core.gif" class="sprite diamond">
                <img src="/img/sprites/combat/foes/translator_core.gif" class="sprite diamond">
            </div>

            <div class="orbs">
                <div class="orb"></div>
                <div class="orb"></div>
                <div class="orb"></div>
            </div>

            <div class="orbs">
                <div class="orb"></div>
                <div class="orb"></div>
            </div>

            <div class="target" entity="translation core"></div>
        </div>
        `,
    reactions: {
        catchall: ["â–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ", "â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ", "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ", "â–ˆâ–ˆâ–ˆ", "â–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ", "â–ˆâ–ˆâ–ˆ â–ˆ â–ˆâ–ˆâ–ˆâ–ˆ", "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ", "â–ˆ â–ˆâ–ˆâ–ˆâ–ˆ", "â–ˆâ–ˆâ–ˆâ–ˆ â–ˆ â–ˆ â–ˆ"],
        dead: ["â–ˆâ–ˆâ–ˆ â–ˆ â–ˆ â–ˆ â–ˆâ–ˆâ–ˆ"]
    },
    initialStatusEffects: [["player_ethereal", 1],["dull_malfunction", 1],["high_priority", 1]],
}

    env.COMBAT_ACTORS.player_dull_dullzika = {
        name: "Glowing Dullzika",
        maxhp: 27,
        hp: 27,
        actions: ["special_dullsummon_weak"],
        statusImmunities: ["stun"],
        graphic: `
            <div class="sprite-wrapper golemsprite dullzika" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/combat/foes/turboglazika.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                
                <div class="sprite golemsprite-head">
                    <img src="/img/sprites/combat/foes/turboglazika-hat.gif" id="%SLUG-golemsprite-head">
                </div>
                <img src="/img/sprites/combat/foes/turboglazika-eyes.gif" id="%SLUG-golemsprite-neck" class="sprite golemsprite-neck">
                <img src="/img/sprites/combat/foes/turboglazika-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">

                <div class="target" entity="dullzika"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["player_ethereal", 1],["dull_malfunction", 1],["high_priority", 1]],
    }

env.COMBAT_ACTORS.player_dull_kivii = {
    name: "Greater Dusk",
    maxhp: 60,
    hp: 60,
    actions: ["speak_weak", "spy_target", "enemy_shell","special_player_kiviisummon"],
    statusImmunities: ["stun"],
    graphic: `
        <div class="sprite-wrapper kivii" id="%SLUG-sprite-wrapper">
            <div class="sprite-overflow spritestack">
                <img class="sprite" src="/img/sprites/combat/foes/kivii/combat.gif" id="%SLUG-sprite">
                <div class="target" entity="dozkallvi"></div>
            </div>
        </div>
        `,
    reactions: {
        evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er", "", "", "", "", "", ""],
        crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN", "", "", "", "", "", ""],
        receive_crit: ["hu r ts", "", "", "", "", "", ""],
        receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™", "", "", "", "", "", ""],
        puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™", "", "", "", "", "", ""],
        receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘", "", "", "", "", "", ""],
        receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct", "", "", "", "", "", ""],
        receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e", "", "", "", "", "", ""],
        receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘", "", "", "", "", "", ""],
        receive_redirection: ["f ina l ly aw  ake", "", "", "", "", "", ""],
        stun: ["o u  t ou t o ut", "ou to u t o  ut", "", "", "", "", "", ""],
        regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e", "", "", "", "", "", ""],
        give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ", "", "", "", "", "", ""],
    },
    initialStatusEffects: [["player_conjoined", 1],["player_ethereal", 1],["perma_vulnerable", 1],["high_priority", 1]],
}

env.COMBAT_ACTORS.player_dull_kivii_gauntlet = {
    name: "Warped Gauntlet",
    maxhp: 60,
    hp: 60,
    actions: ["windup", "kivii_grasp_weak"],
    windupActions: ["archival_smash_weak"],
    graphic: `
        <div class="sprite-wrapper kiviigauntlet" id="%SLUG-sprite-wrapper">
            <img class="sprite" src="/img/sprites/combat/foes/kivii/gauntlet.gif" id="%SLUG-sprite">
            <div class="target" entity="gauntlet"></div>
        </div>
        `,
    reactions: {},
    initialStatusEffects: [["player_conjoined", 1],["player_ethereal", 1],["perma_vulnerable", 1],["high_priority", 1]],
}

env.COMBAT_ACTORS.player_dull_golemboss = {
    name: "Warped Foundation Golem",
    maxhp: 60,
    hp: 60,
    actions: ["golemboss_strike","golemboss_advance","golemboss_guard","golemboss_windup"],
    windupActions: ["golemboss_strike_strong","golemboss_advance_strong","golemboss_guard_strong","golemboss_focused_strong"],
    statusImmunities: ["stun"],
    graphic: `
        <div class="sprite-wrapper golemsprite bossgolem" id="%SLUG-sprite-wrapper">
            <div class="sprite-overflow spritestack">
                <img src="/img/sprites/combat/foes/golemboss.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                
                <div class="sprite golemsprite-head">
                    <img src="/img/sprites/combat/foes/golemboss-head.gif" id="%SLUG-golemsprite-head">
                </div>
                <img src="/img/sprites/combat/foes/golemboss-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                <img src="/img/sprites/combat/foes/golemboss-arms.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-arms">
            </div>

            <div class="target" entity="foundation golem"></div>
        </div>
        `,
    reactions: {
        catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
        dead: ["Â¿", "???"]
    },
    initialStatusEffects: [["player_ethereal", 1],["dull_malfunction", 1],["high_priority", 1]],
}

    //warped collapse actors
env.COMBAT_ACTORS.player_dull_container = {
    name: "Warped Container",
    maxhp: 2,
    hp: 2,
    actions: ["brawl_weak"],
    graphic: `
        <div class="sprite-wrapper dulltainer" id="%SLUG-sprite-wrapper">
            <img class="sprite" src="/img/sprites/combat/foes/inc_dull.gif" id="%SLUG-sprite">
            <div class="target" entity="warped container"></div>
        </div>
        `,
    reactions: {
        catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
        dead: ["Â¿", "???"]
    },
    initialStatusEffects: [["player_ethereal", 1],["perma_destabilized"]],
}

env.COMBAT_ACTORS.player_dull_attendant = {
    name: "Warped Attendant",
    maxhp: 2,
    hp: 2,
    actions: ["brawl_weak", "foe_stab_weak"],
    graphic: `
        <div class="sprite-wrapper" id="%SLUG-sprite-wrapper">
            <div class="attendant-sprite">
                <img class="sprite" src="/img/local/embassy/spiredronebody.gif" id="%SLUG-sprite">
            </div>
            <div class="target" entity="attendant"></div>
        </div>
        `,
    reactions: {
        catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
        dead: ["Â¿", "???"]
    },
    initialStatusEffects: [["player_ethereal", 1],["perma_vulnerable", 1]],
}

env.COMBAT_ACTORS.player_dull_veilklight = {
    name: "Warped Veilklight",
    maxhp: 3,
    hp: 3,
    actions: ["spy_weak", "mend_weak", "daze_lastresort_weak"],
    graphic: `
        <div class="sprite-wrapper" id="%SLUG-sprite-wrapper">
            <div class="veilksprite">
                <img class="sprite" src="/img/sprites/combat/foes/foelampbase.gif" id="%SLUG-sprite">
            </div>
            <div class="target" entity="hostile veilklight"></div>
        </div>
        `,
    reactions: {
        catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
        dead: ["Â¿", "???"]
    },
    initialStatusEffects: [["player_ethereal", 1],["perma_vulnerable", 1]],
}

env.COMBAT_ACTORS.player_dull_maintcloak = {
    name: "Warped Jutskin",
    maxhp: 10,
    hp: 7,
    actions: ["special_barrier_allies_weak", "stab_weak"],
    graphic: `
        <div class="sprite-wrapper maintcloak" id="%SLUG-sprite-wrapper">
            <div class="spritestack" style="transform-style: preserve-3d;">
                <img class="sprite" src="/img/sprites/combat/foes/maintcloak.gif">
                <img class="sprite" src="/img/sprites/combat/foes/mainthead.gif">
                <img class="sprite" src="/img/sprites/combat/foes/mainthead.gif">

                <div class="target" entity="jutskin"></div>
            </div>
        </div>
    `,
    reactions: {
        catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
        dead: ["Â¿", "???"]
    },
    initialStatusEffects: [["player_ethereal", 1],["perma_vulnerable", 1]],
}

env.COMBAT_ACTORS.player_dull_archival_golem = {
    name: "Warped Archival Golem",
    maxhp: 14,
    hp: 10,
    actions: ["windup"],
    windupActions: ["archival_smash_weak"],
    graphic: `
        <div class="sprite-wrapper archival-golem golemsprite" id="%SLUG-sprite-wrapper">
            <div class="sprite-overflow spritestack">
                <img src="/img/sprites/combat/foes/archivalgolem.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                
                <div class="sprite golemsprite-head">
                    <img src="/img/sprites/combat/foes/archivalgolem-head.gif" id="%SLUG-golemsprite-head">
                </div>
                <img src="/img/sprites/combat/foes/archivalgolem-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                <img src="/img/sprites/combat/foes/archivalgolem-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
            </div>

            <div class="target" entity="archival golem"></div>
        </div>
        `,
    reactions: { //SILENT CREATURE
    },
    initialStatusEffects: [["player_ethereal", 1],["dull_malfunction", 1]],
}

    //warped golem maintanence actors
env.COMBAT_ACTORS.player_dull_basic_golem = {
    name: "Warped Golem",
    maxhp: 5,
    hp: 5,
    actions: ["special_self_destruct_dull", "berserk", "foe_stab_weak"],
    graphic: `
        <div class="sprite-wrapper golemsprite basic-golem" id="%SLUG-sprite-wrapper">
            <div class="sprite-overflow spritestack">
                <img src="/img/sprites/combat/foes/golem.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                
                <div class="sprite golemsprite-head">
                    <img src="/img/sprites/combat/foes/golem-head.gif" id="%SLUG-golemsprite-head">
                </div>
                <img src="/img/sprites/combat/foes/golem-neck.gif" id="%SLUG-golemsprite-neck" class="sprite golemsprite-neck">
                <img src="/img/sprites/combat/foes/golem-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                <img src="/img/sprites/combat/foes/golem-leftarm.gif" id="%SLUG-golemsprite-leftarm" class="sprite golemsprite-leftarm">
                <img src="/img/sprites/combat/foes/golem-rightarm.gif" id="%SLUG-golemsprite-rightarm" class="sprite golemsprite-rightarm">
            </div>

            <div class="target" entity="golem"></div>
        </div>
        `,
    reactions: {
        catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
        dead: ["Â¿", "???"]
    },
    initialStatusEffects: [["player_ethereal", 1],["dull_malfunction", 1]],
}

env.COMBAT_ACTORS.player_dull_husk = {
    name: "Dusk",
    maxhp: 7,
    hp: 7,
    actions: ["husk_attack_weak", "speak_weak", "stab_weak", "evade_weak"],

    //graphic is controlled mainly by the sprite creation event below, check it out!
    graphic: `
        <div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
            <div class="spritestack" id="%SLUG-sprite">
                <img src="" class="sprite basis">
                <div class="sprite toplayer"></div>
                <div class="sprite bottomlayer"></div>
            </div>
            <div class="target" entity="husk"></div>
        </div>
    `,
   reactions: {
		evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
		crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
		receive_crit: ["hu r ts"],
		receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
		puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
		receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
		receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
		receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
		receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
		receive_redirection: ["f ina l ly aw  ake"],
		stun: ["o u  t ou t o ut", "ou to u t o  ut"],
		regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
		give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
    },
    initialStatusEffects: [["player_ethereal", 1],["perma_vulnerable", 1]],
}

env.COMBAT_ACTORS.player_dull_surgeon_golem = {
    name: "Warped Repairfriend",
    maxhp: 5,
    hp: 5,
    actions: ["mend_weak", "tozik_attack_weak", "foe_stab_weak"],
    graphic: `
        <div class="sprite-wrapper surgeon-golem golemsprite" id="%SLUG-sprite-wrapper">
            <div class="sprite-overflow spritestack">
                <img src="/img/sprites/combat/foes/surgeon.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                
                <div class="sprite golemsprite-head">
                    <img src="/img/sprites/combat/foes/surgeon-head.gif" id="%SLUG-golemsprite-head">
                </div>
                <img src="/img/sprites/combat/foes/surgeon-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                <img src="/img/sprites/combat/foes/surgeon-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
            </div>

            <div class="target" entity="repairfriend"></div>
        </div>
    `,
    reactions: {
        catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
        dead: ["Â¿", "???"]
    },
    initialStatusEffects: [["player_ethereal", 1],["dull_malfunction", 1]],
}

env.COMBAT_ACTORS.player_dull_pressure_golem = {
    name: "Warped Kivskin",
    maxhp: 8,
    hp: 8,
    actions: ["bozko_attack_weak", "guard"],
    graphic: `
        <div class="sprite-wrapper pressure-golem golemsprite" id="%SLUG-sprite-wrapper">
            <div class="sprite-overflow spritestack">
                <img src="/img/sprites/combat/foes/pressure.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                
                <div class="sprite golemsprite-head">
                    <img src="/img/sprites/combat/foes/pressure-head.gif" id="%SLUG-golemsprite-head">
                </div>
                <img src="/img/sprites/combat/foes/pressure-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                <img src="/img/sprites/combat/foes/pressure-leftarm.gif" id="%SLUG-golemsprite-leftarm" class="sprite golemsprite-leftarm">
                <img src="/img/sprites/combat/foes/pressure-rightarm.gif" id="%SLUG-golemsprite-rightarm" class="sprite golemsprite-rightarm">
            </div>

            <div class="target" entity="kivskin"></div>
        </div>
        `,
    reactions: {
        catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
        dead: ["Â¿", "???"]
    },
    initialStatusEffects: [["player_ethereal", 1],["dull_malfunction", 1]],
}

env.COMBAT_ACTORS.player_dull_constructor_golem = {
    name: "Warped Constructor",
    maxhp: 5,
    hp: 5,
    actions: ["brawl_weak", "barrier", "spy_analyze_weak", "special_limited_carapace"],
    graphic: `
        <div class="sprite-wrapper constructor-golem golemsprite" id="%SLUG-sprite-wrapper">
            <div class="sprite-overflow spritestack">
                <img src="/img/sprites/combat/foes/constructor.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                
                <div class="sprite golemsprite-head">
                    <img src="/img/sprites/combat/foes/constructor-head.gif" id="%SLUG-golemsprite-head">
                </div>
                <img src="/img/sprites/combat/foes/constructor-neck.gif" id="%SLUG-golemsprite-neck" class="sprite golemsprite-neck">
                <img src="/img/sprites/combat/foes/constructor-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                <img src="/img/sprites/combat/foes/constructor-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
            </div>

            <div class="target" entity="constructor"></div>
        </div>
        `,
    reactions: {
        catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
        dead: ["Â¿", "???"]
    },
    initialStatusEffects: [["player_ethereal", 1],["dull_malfunction", 1]],
}

env.COMBAT_ACTORS.player_dull_dullfriend = {
    name: "Glowing Dullfriend",
    maxhp: 12,
    hp: 12,
    actions: ["brawl", "ik_attack_vanity", "dullflare_vanity", "evade_weak"],
    graphic: `
        <div class="sprite-wrapper golemsprite bossgolem" id="%SLUG-sprite-wrapper">
            <div class="sprite-overflow spritestack">
                <img src="/img/sprites/combat/foes/golemboss.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                
                <div class="sprite golemsprite-head">
                    <img src="/img/sprites/combat/foes/golemboss-head.gif" id="%SLUG-golemsprite-head">
                </div>
                <img src="/img/sprites/combat/foes/golemboss-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                <img src="/img/sprites/combat/foes/golemboss-arms.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-arms">
            </div>

            <div class="target" entity="foundation golem"></div>
        </div>
        `,
    reactions: {
        catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
        dead: ["Â¿", "???"]
    },
    initialStatusEffects: [["player_ethereal", 1],["perma_vulnerable", 1],["dull_malfunction", 1]],
}

    env.COMBAT_ACTORS.player_hands_critta_pawn = {
        name: "WRK",
        specialClass: "daemonactor",
        maxhp: 10,
		hp: 5,
        actions: ["revise", "mad_claw", "evade"],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="wrk"></div>
                <figure class="daemon pawn accurate-position"> 
                    <img src="/img/sprites/daemons/pawn/base.gif">
                    <div class="eye"></div>
                    <div class="scraps noimg">
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                    </div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
		initialStatusEffects: [["player_ethereal", 1]],
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    }

    env.COMBAT_ACTORS.player_hands_critta_knight = {
        name: "CLW",
        specialClass: "daemonactor",
        maxhp: 15,
		hp: 8,
        actions: ["cripple", "exploit", "surge"],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="clw"></div>
                <figure class="daemon rook accurate-position">
                    <img src="/img/sprites/daemons/rook/body.gif">
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="leftarm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                    <div class="rightarm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                </figure>
                
            </div>
            `,
        reactions: {}, //SILENT CREATURE
		initialStatusEffects: [["player_ethereal", 1]],
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    }

	env.COMBAT_ACTORS.player_hands_critta_bishop = {
        name: "NET",
        specialClass: "daemonactor",
        maxhp: 12,
		hp: 6,
        actions: ["speak", "parasite", "empower", "rez_player"],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="net"></div>
                <figure class="daemon bishop accurate-position">
                    <img src="/img/sprites/daemons/bishop/base.gif">
                    <div class="eye"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
		initialStatusEffects: [["player_ethereal", 1]],
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    }

    env.COMBAT_ACTORS.player_hands_critta_rook = {
        name: "ENFC",
        specialClass: "daemonactor",
        maxhp: 20,
		hp: 10,
        actions: ["enforce", "focused_guard"],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="enfc"></div>
                <figure class="daemon knight accurate-position">
                    <img src="/img/sprites/daemons/knight/body.gif">
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="uparm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
		initialStatusEffects: [["player_ethereal", 1]],
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    }

    env.COMBAT_ACTORS.player_hands_critta_queen = {
        name: "SEER",
        specialClass: "daemonactor",
        maxhp: 22,
		hp: 11,
        actions: ["windup"],
        windupActions: ["special_rule", "wound_lastresort"],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="seer"></div>
                <figure class="daemon queen accurate-position">
                    <img src="/img/sprites/daemons/queen/core.gif">
                    <div class="eye"></div>
                    <div class="ring"></div>
                    <div class="ring"></div>
                    <div class="ring"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
		initialStatusEffects: [["player_ethereal", 1]],
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    }

    env.COMBAT_ACTORS.player_hands_critta_king = {
        name: "ARCHN",
        specialClass: "daemonactor",
        maxhp: 25,
		hp: 12,
        actions: ["windup"],
        windupActions: ["special_judgement"],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="archn"></div>
                <figure class="daemon king accurate-position">
                    <img src="/img/sprites/daemons/king/angles.gif">
                    <img src="/img/sprites/daemons/king/angles.gif">
                    <div class="box center"></div>
                    <div class="box outer"></div>
                    <div class="ring"></div>
                    <div class="eye"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
		initialStatusEffects: [["player_ethereal", 1]],
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    }

	env.COMBAT_ACTORS.player_hands_critta_dragon = {
		name: "IDL",
		specialClass: "daemonactor",
		maxhp: 30,
		hp: 15,
		actions: ["special_player_daemon_guard"],
		graphic: `
			<div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
				<div class="target" entity="seer"></div>
				<figure class="daemon queen accurate-position">
					<img src="/img/sprites/daemons/queen/core.gif">
					<div class="eye"></div>
					<div class="ring"></div>
					<div class="ring"></div>
					<div class="ring"></div>
				</figure>
			</div>
			`,
		reactions: {}, //SILENT CREATURE
		events: {
			onSpawn: () => change("daemon", "saw")
		},
		initialStatusEffects: [["player_ethereal", 1]],
	}

	env.COMBAT_ACTORS.player_hands_critta_unicorn = {
		name: "MOD",
		specialClass: "daemonactor",
		maxhp: 15,
		hp: 8,
		actions: ["special_daemon_fullauto","daemon_floor_it","daemon_windup"],
		windupActions: ["special_daemon_fullerauto"],
		graphic: `
			<div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
				<div class="target" entity="clw"></div>
				<figure class="daemon rook accurate-position">
					<img src="/img/sprites/daemons/rook/body.gif">
					<div class="eye"></div>
					<div class="eye"></div>
					<div class="eye"></div>
					<div class="eye"></div>
					<div class="eye"></div>
					<div class="leftarm">
						<div class="downarm">
							<div class="upclaw"></div>
							<div class="downclaw"></div>
						</div>
					</div>
					<div class="rightarm">
						<div class="downarm">
							<div class="upclaw"></div>
							<div class="downclaw"></div>
						</div>
					</div>
				</figure>
				
			</div>
			`,
		reactions: {}, //SILENT CREATURE
		events: {
			onSpawn: () => change("daemon", "saw")
		},
		initialStatusEffects: [["player_ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.player_dull_critta_princess_offensive = {
		name: "CPU",
		specialClass: "daemonactor",
		maxhp: 12,
		hp: 6,
		actions: ["daemon_cull", "daemon_plot", "special_daemon_enact_cpu"],
		graphic: `
			<div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
				<div class="target" entity="net"></div>
				<figure class="daemon bishop accurate-position">
					<img src="/img/sprites/daemons/bishop/base.gif">
					<div class="eye"></div>
					<div class="tendril"></div>
					<div class="tendril"></div>
					<div class="tendril"></div>
					<div class="tendril"></div>
					<div class="tendril"></div>
				</figure>
			</div>
			`,
		reactions: {}, //SILENT CREATURE
		events: {
			onSpawn: () => change("daemon", "saw")
		},
		initialStatusEffects: [["player_ethereal", 1],["daemon_malfunction", 1]],
	}

	env.COMBAT_ACTORS.player_hands_critta_princess_defensive = {
		name: "GPU",
		specialClass: "daemonactor",
		maxhp: 12,
		hp: 6,
		actions: ["daemon_tesselate", "daemon_plot", "special_daemon_enact_gpu"],
		graphic: `
			<div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
				<div class="target" entity="net"></div>
				<figure class="daemon bishop accurate-position">
					<img src="/img/sprites/daemons/bishop/base.gif">
					<div class="eye"></div>
					<div class="tendril"></div>
					<div class="tendril"></div>
					<div class="tendril"></div>
					<div class="tendril"></div>
					<div class="tendril"></div>
				</figure>
			</div>
			`,
		reactions: {}, //SILENT CREATURE
		events: {
			onSpawn: () => change("daemon", "saw")
		},
		initialStatusEffects: [["player_ethereal", 1]],
	}

	env.COMBAT_ACTORS.player_hands_critta_princess_hybrid = {
		name: "MTHRBRD",
		specialClass: "daemonactor",
		maxhp: 22,
		hp: 11,
		actions: ["special_greater_cull", "special_greater_tesselate", "surge"],
		graphic: `
			<div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
				<div class="target" entity="net"></div>
				<figure class="daemon bishop accurate-position">
					<img src="/img/sprites/daemons/bishop/base.gif">
					<div class="eye"></div>
					<div class="tendril"></div>
					<div class="tendril"></div>
					<div class="tendril"></div>
					<div class="tendril"></div>
					<div class="tendril"></div>
				</figure>
			</div>
			`,
		reactions: {}, //SILENT CREATURE
		events: {
			onSpawn: () => change("daemon", "saw")
		},
		initialStatusEffects: [["player_ethereal", 1]],
	}

	env.COMBAT_ACTORS.player_hands_critta_superknight = {
		name: "DEL",
		specialClass: "daemonactor",
		maxhp: 22,
		hp: 11,
		actions: ["windup"],
		windupActions: ["daemon_smash"],
		graphic: `
			<div class="sprite-wrapper daemon_del superknightsprite" id="%SLUG-sprite-wrapper">
				<div class="sprite-overflow spritestack">
					<img src="https://narrativohazard-expunged.neocities.org/img/bstrdsing_wholesprite-DEL-gifver_mimic.gif" style="max-height: 405px; max-width: 945px;" id="%SLUG-superknightsprite-whole" class="sprite superknightsprite-whole">

				<div class="target" entity="archival golem"></div>
			</div>
			`,
		reactions: { //SILENT CREATURE
		},
		initialStatusEffects: [["player_ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.player_metal_archival_golem = {
        name: "Archival Golem",
        maxhp: 20,
        hp: 8,
        actions: ["windup"],
        windupActions: ["archival_smash"],
        graphic: `
            <div class="sprite-wrapper archival-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/archivalgolem.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/archivalgolem-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/archivalgolem-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/archivalgolem-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="archival golem"></div>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
		initialStatusEffects: [["player_ethereal", 1]],
    }

	env.COMBAT_ACTORS.player_metal_maintcloak = {
        name: "Jutskin",
        maxhp: 15,
        hp: 5,
        actions: ["special_barrier_allies_player", "stab"],
        graphic: `
            <div class="sprite-wrapper maintcloak" id="%SLUG-sprite-wrapper">
                <div class="spritestack" style="transform-style: preserve-3d;">
                    <img class="sprite" src="/img/sprites/combat/foes/maintcloak.gif">
                    <img class="sprite" src="/img/sprites/combat/foes/mainthead.gif">
                    <img class="sprite" src="/img/sprites/combat/foes/mainthead.gif">

                    <div class="target" entity="jutskin"></div>
                </div>
            </div>
        `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["player_ethereal", 1]],
        turnCheck: "maintcloak"
    }
	
	env.COMBAT_ACTORS.player_metal_constructor_golem = {
        name: "Constructor",
        maxhp: 8,
        hp: 4,
        actions: ["attack", "barrier", "spy_analyze", "special_limited_carapace"],
        graphic: `
            <div class="sprite-wrapper constructor-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/constructor.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/constructor-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/constructor-neck.gif" id="%SLUG-golemsprite-neck" class="sprite golemsprite-neck">
                    <img src="/img/sprites/combat/foes/constructor-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/constructor-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="constructor"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["player_ethereal", 1]],
    }
	
	env.COMBAT_ACTORS.player_metal_pressure_golem = {
        name: "Kivskin",
        maxhp: 12,
        hp: 6,
        actions: ["bozko_attack", "guard"],
        graphic: `
            <div class="sprite-wrapper pressure-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/pressure.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/pressure-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/pressure-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/pressure-leftarm.gif" id="%SLUG-golemsprite-leftarm" class="sprite golemsprite-leftarm">
                    <img src="/img/sprites/combat/foes/pressure-rightarm.gif" id="%SLUG-golemsprite-rightarm" class="sprite golemsprite-rightarm">
                </div>

                <div class="target" entity="kivskin"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["player_ethereal", 1]],
    }
	
	env.COMBAT_ACTORS.player_metal_dull_golem = {
        name: "Dullfriend",
        maxhp: 18,
        hp: 10,
        actions: ["brawl", "windup"],
        windupActions: ["ik_attack", "dullflare", "focused_windup"],
        graphic: `
            <div class="sprite-wrapper golemsprite bossgolem" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/golemboss.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/golemboss-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/golemboss-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/golemboss-arms.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="foundation golem"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["player_ethereal", 1]],
    }

	env.COMBAT_ACTORS.player_metal_surgeon_golem = {
        name: "Repairfriend",
        maxhp: 8,
        hp: 4,
        actions: ["mend", "tozik_attack", "foe_stab"],
        graphic: `
            <div class="sprite-wrapper surgeon-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/surgeon.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/surgeon-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/surgeon-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/surgeon-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="repairfriend"></div>
            </div>
        `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["player_ethereal", 1]],
    }

    env.COMBAT_ACTORS.player_metal_basic_golem = {
        name: "Golem",
        maxhp: 8,
        hp: 4,
        actions: ["special_self_destruct", "berserk", "foe_stab"],
        graphic: `
            <div class="sprite-wrapper golemsprite basic-golem" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/golem.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/golem-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/golem-neck.gif" id="%SLUG-golemsprite-neck" class="sprite golemsprite-neck">
                    <img src="/img/sprites/combat/foes/golem-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/golem-leftarm.gif" id="%SLUG-golemsprite-leftarm" class="sprite golemsprite-leftarm">
                    <img src="/img/sprites/combat/foes/golem-rightarm.gif" id="%SLUG-golemsprite-rightarm" class="sprite golemsprite-rightarm">
                </div>

                <div class="target" entity="golem"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["player_ethereal", 1]],
    }
	
	env.COMBAT_ACTORS.metal_archival_golem = {
        name: "Archival Golem",
        maxhp: 20,
        hp: 8,
        actions: ["windup"],
        windupActions: ["archival_smash"],
        graphic: `
            <div class="sprite-wrapper archival-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/archivalgolem.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/archivalgolem-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/archivalgolem-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/archivalgolem-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="archival golem"></div>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
		initialStatusEffects: [["ethereal", 1]],
    }

	env.COMBAT_ACTORS.metal_maintcloak = {
        name: "Jutskin",
        maxhp: 15,
        hp: 5,
        actions: ["special_barrier_allies", "stab"],
        graphic: `
            <div class="sprite-wrapper maintcloak" id="%SLUG-sprite-wrapper">
                <div class="spritestack" style="transform-style: preserve-3d;">
                    <img class="sprite" src="/img/sprites/combat/foes/maintcloak.gif">
                    <img class="sprite" src="/img/sprites/combat/foes/mainthead.gif">
                    <img class="sprite" src="/img/sprites/combat/foes/mainthead.gif">

                    <div class="target" entity="jutskin"></div>
                </div>
            </div>
        `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["ethereal", 1]],
        turnCheck: "maintcloak"
    }
	
	env.COMBAT_ACTORS.metal_constructor_golem = {
        name: "Constructor",
        maxhp: 8,
        hp: 4,
        actions: ["attack", "barrier", "spy_analyze", "special_limited_carapace"],
        graphic: `
            <div class="sprite-wrapper constructor-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/constructor.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/constructor-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/constructor-neck.gif" id="%SLUG-golemsprite-neck" class="sprite golemsprite-neck">
                    <img src="/img/sprites/combat/foes/constructor-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/constructor-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="constructor"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["ethereal", 1]],
    }
	
	env.COMBAT_ACTORS.metal_pressure_golem = {
        name: "Kivskin",
        maxhp: 12,
        hp: 6,
        actions: ["bozko_attack", "guard"],
        graphic: `
            <div class="sprite-wrapper pressure-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/pressure.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/pressure-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/pressure-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/pressure-leftarm.gif" id="%SLUG-golemsprite-leftarm" class="sprite golemsprite-leftarm">
                    <img src="/img/sprites/combat/foes/pressure-rightarm.gif" id="%SLUG-golemsprite-rightarm" class="sprite golemsprite-rightarm">
                </div>

                <div class="target" entity="kivskin"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["ethereal", 1]],
    }
	
	env.COMBAT_ACTORS.metal_dull_golem = {
        name: "Dullfriend",
        maxhp: 18,
        hp: 10,
        actions: ["brawl", "windup"],
        windupActions: ["ik_attack", "dullflare", "focused_windup"],
        graphic: `
            <div class="sprite-wrapper golemsprite bossgolem" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/golemboss.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/golemboss-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/golemboss-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/golemboss-arms.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="foundation golem"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["ethereal", 1]],
    }

	env.COMBAT_ACTORS.metal_surgeon_golem = {
        name: "Repairfriend",
        maxhp: 8,
        hp: 4,
        actions: ["mend", "tozik_attack", "foe_stab"],
        graphic: `
            <div class="sprite-wrapper surgeon-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/surgeon.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/surgeon-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/surgeon-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/surgeon-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="repairfriend"></div>
            </div>
        `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["ethereal", 1]],
    }

    env.COMBAT_ACTORS.metal_basic_golem = {
        name: "Golem",
        maxhp: 8,
        hp: 4,
        actions: ["special_self_destruct", "berserk", "foe_stab"],
        graphic: `
            <div class="sprite-wrapper golemsprite basic-golem" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/golem.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/golem-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/golem-neck.gif" id="%SLUG-golemsprite-neck" class="sprite golemsprite-neck">
                    <img src="/img/sprites/combat/foes/golem-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/golem-leftarm.gif" id="%SLUG-golemsprite-leftarm" class="sprite golemsprite-leftarm">
                    <img src="/img/sprites/combat/foes/golem-rightarm.gif" id="%SLUG-golemsprite-rightarm" class="sprite golemsprite-rightarm">
                </div>

                <div class="target" entity="golem"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["ethereal", 1]],
    }

	env.COMBAT_ACTORS.player_metal_basic_golem_mega = {
        name: "Greater Golem",
        maxhp: 15,
        hp: 8,
        actions: ["windup"],
		windupActions: ["special_self_destruct_mega", "berserk_mega_golem", "foe_stab_metal"],
        graphic: `
            <div class="sprite-wrapper golemsprite basic-golem" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/golem.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/golem-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/golem-neck.gif" id="%SLUG-golemsprite-neck" class="sprite golemsprite-neck">
                    <img src="/img/sprites/combat/foes/golem-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/golem-leftarm.gif" id="%SLUG-golemsprite-leftarm" class="sprite golemsprite-leftarm">
                    <img src="/img/sprites/combat/foes/golem-rightarm.gif" id="%SLUG-golemsprite-rightarm" class="sprite golemsprite-rightarm">
                </div>

                <div class="target" entity="golem"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["ethereal", 1]],
    }

	env.COMBAT_ACTORS.player_metal_constructor_golem_mega = {
        name: "Greater Constructor",
        maxhp: 15,
        hp: 8,
        actions: ["windup"],
		windupActions: ["attack_smash", "barrier_mega", "ultra_spy_analyze", "special_limited_carapace_bonus"],
        graphic: `
            <div class="sprite-wrapper constructor-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/constructor.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/constructor-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/constructor-neck.gif" id="%SLUG-golemsprite-neck" class="sprite golemsprite-neck">
                    <img src="/img/sprites/combat/foes/constructor-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/constructor-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="constructor"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["ethereal", 1]],
    }
	
    env.COMBAT_ACTORS.player_metal_maintcloak_mega = {
        name: "Greater Jutskin",
        maxhp: 30,
        hp: 10,
        actions: ["windup"],
		windupActions: ["special_restorative_barrier_metal", "stab_metal"],
        graphic: `
            <div class="sprite-wrapper maintcloak" id="%SLUG-sprite-wrapper">
                <div class="spritestack" style="transform-style: preserve-3d;">
                    <img class="sprite" src="/img/sprites/combat/foes/maintcloak.gif">
                    <img class="sprite" src="/img/sprites/combat/foes/mainthead.gif">
                    <img class="sprite" src="/img/sprites/combat/foes/mainthead.gif">

                    <div class="target" entity="jutskin"></div>
                </div>
            </div>
        `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["ethereal", 1]],
        turnCheck: "maintcloak"
    }

    env.COMBAT_ACTORS.player_metal_pressure_golem_mega = {
        name: "Greater Kivskin",
        maxhp: 25,
        hp: 12,
        actions: ["windup"],
		windupActions: ["cripple_metal", "special_guard_all_metal"],
        graphic: `
            <div class="sprite-wrapper pressure-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/pressure.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/pressure-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/pressure-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/pressure-leftarm.gif" id="%SLUG-golemsprite-leftarm" class="sprite golemsprite-leftarm">
                    <img src="/img/sprites/combat/foes/pressure-rightarm.gif" id="%SLUG-golemsprite-rightarm" class="sprite golemsprite-rightarm">
                </div>

                <div class="target" entity="kivskin"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["ethereal", 1]],
    }

    env.COMBAT_ACTORS.player_metal_surgeon_golem_mega = {
        name: "Greater Repairfriend",
        maxhp: 15,
        hp: 8,
        actions: ["windup"],
		windupActions: ["mend_metal", "tozik_attack_metal", "foe_stab_metal", "windup_winderup"],
		winderupActions: ["restore_metal"],
        graphic: `
            <div class="sprite-wrapper surgeon-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/surgeon.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/surgeon-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/surgeon-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/surgeon-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="repairfriend"></div>
            </div>
        `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["ethereal", 1]],
    }
	
	env.COMBAT_ACTORS.player_metal_archival_golem_mega = {
        name: "Greater Archival Golem",
        maxhp: 40,
        hp: 15,
        actions: ["windup"],
        windupActions: ["archival_smash", "windup_winderup"],
		winderupActions: ["archival_smash_mega"],
        graphic: `
            <div class="sprite-wrapper archival-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/archivalgolem.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/archivalgolem-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/archivalgolem-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/archivalgolem-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="archival golem"></div>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
		initialStatusEffects: [["ethereal", 1]],
    }
	
    env.COMBAT_ACTORS.player_metal_dull_golem_mega = {
        name: "Greater Dullfriend",
        maxhp: 35,
        hp: 18,
        actions: ["brawl_metal", "windup"],
        windupActions: ["ik_attack", "dullflare", "focused_windup", "windup_winderup"],
		winderupActions: ["cavernhammer", "quick_forge", "focused_winderup", "windup_windestup"], 
		windestupActions: ["veilkruka", "incinerate", "focused_windestup", "windup_final_windup"], 
		finalWindupActions: ["cavernsplitter", "immolate", "focused_final_windup"],
        graphic: `
            <div class="sprite-wrapper golemsprite bossgolem" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/golemboss.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/golemboss-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/golemboss-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/golemboss-arms.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="foundation golem"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["ethereal", 1]],
    }
	//pain husks start here
	//note to self:: the plan is to make husks corresponding to each humor, with most of an individual humor's abilities being inverted (husk distract gives foes vulnerable on crit, husk corruskivi gives foes puncture on crit, etc.)
	//also make one that's just kazki for the funny
	env.COMBAT_ACTORS.player_pain_husk = {
		name: "Husk",
		maxhp: 10,
		hp: 5,
		actions: ["husk_attack", "speak", "stab", "evade"],

		//graphic is controlled mainly by the sprite creation event below, check it out! <--- not ANYMORE!!!!! >:)
		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["player_ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.player_pain_husk_ichor = {
		name: "Husk",
		maxhp: 10,
		hp: 5,
		actions: ["husk_attack_ichor", "speak_ichor", "mend", "sacrifice", "sacrifice_restore"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["player_ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.player_pain_husk_eyes = {
		name: "Husk",
		maxhp: 12,
		hp: 6,
		actions: ["husk_attack_eyes", "spy_target", "plot", "special_enact"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["player_ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.player_pain_husk_claws = {
		name: "Husk",
		maxhp: 12,
		hp: 6,
		actions: ["husk_attack_claws", "bite_weak", "frenzy", "surge"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["player_ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.player_pain_husk_bone = {
		name: "Husk",
		maxhp: 20,
		hp: 10,
		actions: ["husk_attack_bone", "speak_bone", "guard", "shell"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["player_ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.player_pain_husk_light = {
		name: "Husk",
		maxhp: 16,
		hp: 8,
		actions: ["husk_attack_light", "speak_light", "destabilize", "special_invite_storm"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["player_ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.pain_husk = {
		name: "Husk",
		maxhp: 10,
		hp: 5,
		actions: ["husk_attack", "speak", "stab", "evade"],

		//graphic is controlled mainly by the sprite creation event below, check it out! <--- not ANYMORE!!!!! >:)
		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		regenAllSprites: (ungeneratedOnly = false) => { //used in combat and stage stuff
            let query = '.husk.sprite-wrapper'
            if(ungeneratedOnly) query = '.husk.sprite-wrapper:not(.generated)'
            document.querySelectorAll('.husk.sprite-wrapper').forEach(sprite=>{
                env.COMBAT_ACTORS.husk.events.onSpriteCreation(sprite)
            })
        },
        
        events: {
            onSpriteCreation: (sprite) => {
                if(content.querySelector("critta-map")) { return }

                let types = [
                    {
                        name: "type1",
                        bottomCount: 2,
                        topCount: 3
                    },
                    {
                        name: "type2",
                        bottomCount: 2,
                        topCount: 2
                    },
                    {
                        name: "type3",
                        bottomCount: 2,
                        topCount: 2
                    },
                    {
                        name: "type4",
                        bottomCount: 2,
                        topCount: 3
                    },
                ]

                let type = types.sample()
                type.decidedT = rand(1, type.topCount + 1)
                type.decidedB = rand(1, type.bottomCount + 1)
                sprite.setAttribute("type", type.name.replace('type', ''))
                sprite.setAttribute("b", type.decidedB)
                sprite.setAttribute("t", type.decidedT)
                sprite.querySelector("img.basis").src = `/img/sprites/combat/foes/husks/${type.name}_bottom${type.decidedB}.gif`
                sprite.classList.add('generated')
            }
        },
		initialStatusEffects: [["ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.pain_husk_ichor = {
		name: "Husk",
		maxhp: 10,
		hp: 5,
		actions: ["husk_attack_ichor", "speak_ichor", "mend", "sacrifice", "sacrifice_restore"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		regenAllSprites: (ungeneratedOnly = false) => { //used in combat and stage stuff
            let query = '.husk.sprite-wrapper'
            if(ungeneratedOnly) query = '.husk.sprite-wrapper:not(.generated)'
            document.querySelectorAll('.husk.sprite-wrapper').forEach(sprite=>{
                env.COMBAT_ACTORS.husk.events.onSpriteCreation(sprite)
            })
        },
        
        events: {
            onSpriteCreation: (sprite) => {
                if(content.querySelector("critta-map")) { return }

                let types = [
                    {
                        name: "type1",
                        bottomCount: 2,
                        topCount: 3
                    },
                    {
                        name: "type2",
                        bottomCount: 2,
                        topCount: 2
                    },
                    {
                        name: "type3",
                        bottomCount: 2,
                        topCount: 2
                    },
                    {
                        name: "type4",
                        bottomCount: 2,
                        topCount: 3
                    },
                ]

                let type = types.sample()
                type.decidedT = rand(1, type.topCount + 1)
                type.decidedB = rand(1, type.bottomCount + 1)
                sprite.setAttribute("type", type.name.replace('type', ''))
                sprite.setAttribute("b", type.decidedB)
                sprite.setAttribute("t", type.decidedT)
                sprite.querySelector("img.basis").src = `/img/sprites/combat/foes/husks/${type.name}_bottom${type.decidedB}.gif`
                sprite.classList.add('generated')
            }
        },
		initialStatusEffects: [["ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.pain_husk_eyes = {
		name: "Husk",
		maxhp: 12,
		hp: 6,
		actions: ["husk_attack_eyes", "spy_target", "plot", "special_enact"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		regenAllSprites: (ungeneratedOnly = false) => { //used in combat and stage stuff
            let query = '.husk.sprite-wrapper'
            if(ungeneratedOnly) query = '.husk.sprite-wrapper:not(.generated)'
            document.querySelectorAll('.husk.sprite-wrapper').forEach(sprite=>{
                env.COMBAT_ACTORS.husk.events.onSpriteCreation(sprite)
            })
        },
        
        events: {
            onSpriteCreation: (sprite) => {
                if(content.querySelector("critta-map")) { return }

                let types = [
                    {
                        name: "type1",
                        bottomCount: 2,
                        topCount: 3
                    },
                    {
                        name: "type2",
                        bottomCount: 2,
                        topCount: 2
                    },
                    {
                        name: "type3",
                        bottomCount: 2,
                        topCount: 2
                    },
                    {
                        name: "type4",
                        bottomCount: 2,
                        topCount: 3
                    },
                ]

                let type = types.sample()
                type.decidedT = rand(1, type.topCount + 1)
                type.decidedB = rand(1, type.bottomCount + 1)
                sprite.setAttribute("type", type.name.replace('type', ''))
                sprite.setAttribute("b", type.decidedB)
                sprite.setAttribute("t", type.decidedT)
                sprite.querySelector("img.basis").src = `/img/sprites/combat/foes/husks/${type.name}_bottom${type.decidedB}.gif`
                sprite.classList.add('generated')
            }
        },
		initialStatusEffects: [["ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.pain_husk_claws = {
		name: "Husk",
		maxhp: 12,
		hp: 6,
		actions: ["husk_attack_claws", "bite_weak", "frenzy", "surge"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		regenAllSprites: (ungeneratedOnly = false) => { //used in combat and stage stuff
            let query = '.husk.sprite-wrapper'
            if(ungeneratedOnly) query = '.husk.sprite-wrapper:not(.generated)'
            document.querySelectorAll('.husk.sprite-wrapper').forEach(sprite=>{
                env.COMBAT_ACTORS.husk.events.onSpriteCreation(sprite)
            })
        },
        
        events: {
            onSpriteCreation: (sprite) => {
                if(content.querySelector("critta-map")) { return }

                let types = [
                    {
                        name: "type1",
                        bottomCount: 2,
                        topCount: 3
                    },
                    {
                        name: "type2",
                        bottomCount: 2,
                        topCount: 2
                    },
                    {
                        name: "type3",
                        bottomCount: 2,
                        topCount: 2
                    },
                    {
                        name: "type4",
                        bottomCount: 2,
                        topCount: 3
                    },
                ]

                let type = types.sample()
                type.decidedT = rand(1, type.topCount + 1)
                type.decidedB = rand(1, type.bottomCount + 1)
                sprite.setAttribute("type", type.name.replace('type', ''))
                sprite.setAttribute("b", type.decidedB)
                sprite.setAttribute("t", type.decidedT)
                sprite.querySelector("img.basis").src = `/img/sprites/combat/foes/husks/${type.name}_bottom${type.decidedB}.gif`
                sprite.classList.add('generated')
            }
        },
		initialStatusEffects: [["ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.pain_husk_bone = {
		name: "Husk",
		maxhp: 20,
		hp: 10,
		actions: ["husk_attack_bone", "speak_bone", "guard", "shell"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		regenAllSprites: (ungeneratedOnly = false) => { //used in combat and stage stuff
            let query = '.husk.sprite-wrapper'
            if(ungeneratedOnly) query = '.husk.sprite-wrapper:not(.generated)'
            document.querySelectorAll('.husk.sprite-wrapper').forEach(sprite=>{
                env.COMBAT_ACTORS.husk.events.onSpriteCreation(sprite)
            })
        },
        
        events: {
            onSpriteCreation: (sprite) => {
                if(content.querySelector("critta-map")) { return }

                let types = [
                    {
                        name: "type1",
                        bottomCount: 2,
                        topCount: 3
                    },
                    {
                        name: "type2",
                        bottomCount: 2,
                        topCount: 2
                    },
                    {
                        name: "type3",
                        bottomCount: 2,
                        topCount: 2
                    },
                    {
                        name: "type4",
                        bottomCount: 2,
                        topCount: 3
                    },
                ]

                let type = types.sample()
                type.decidedT = rand(1, type.topCount + 1)
                type.decidedB = rand(1, type.bottomCount + 1)
                sprite.setAttribute("type", type.name.replace('type', ''))
                sprite.setAttribute("b", type.decidedB)
                sprite.setAttribute("t", type.decidedT)
                sprite.querySelector("img.basis").src = `/img/sprites/combat/foes/husks/${type.name}_bottom${type.decidedB}.gif`
                sprite.classList.add('generated')
            }
        },
		initialStatusEffects: [["ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.pain_husk_light = {
		name: "Husk",
		maxhp: 16,
		hp: 8,
		actions: ["husk_attack_light", "speak_light", "destabilize", "special_invite_storm"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		regenAllSprites: (ungeneratedOnly = false) => { //used in combat and stage stuff
            let query = '.husk.sprite-wrapper'
            if(ungeneratedOnly) query = '.husk.sprite-wrapper:not(.generated)'
            document.querySelectorAll('.husk.sprite-wrapper').forEach(sprite=>{
                env.COMBAT_ACTORS.husk.events.onSpriteCreation(sprite)
            })
        },
        
        events: {
            onSpriteCreation: (sprite) => {
                if(content.querySelector("critta-map")) { return }

                let types = [
                    {
                        name: "type1",
                        bottomCount: 2,
                        topCount: 3
                    },
                    {
                        name: "type2",
                        bottomCount: 2,
                        topCount: 2
                    },
                    {
                        name: "type3",
                        bottomCount: 2,
                        topCount: 2
                    },
                    {
                        name: "type4",
                        bottomCount: 2,
                        topCount: 3
                    },
                ]

                let type = types.sample()
                type.decidedT = rand(1, type.topCount + 1)
                type.decidedB = rand(1, type.bottomCount + 1)
                sprite.setAttribute("type", type.name.replace('type', ''))
                sprite.setAttribute("b", type.decidedB)
                sprite.setAttribute("t", type.decidedT)
                sprite.querySelector("img.basis").src = `/img/sprites/combat/foes/husks/${type.name}_bottom${type.decidedB}.gif`
                sprite.classList.add('generated')
            }
        },
		initialStatusEffects: [["ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.player_pain_husk_flesh = {
		name: "Husk",
		maxhp: 15,
		hp: 8,
		actions: ["necrotic_strike", "special_mass_bite", "bite_weak", "special_demoralize", "evade_weak"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.player_pain_husk_dull = {
		name: "Husk",
		readoutActor: "husk",
		maxhp: 16,
		hp: 8,
		actions: ["husk_attack_dull", "special_mass_destabilize", "special_player_dullsummon", "special_player_dullbuff"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.player_pain_husk_spirestone = {
		name: "Husk",
		maxhp: 20,
		hp: 10,
		actions: ["windup", "special_barrier_allies", "team_huddle"],
		windupActions: ["husk_smash", "stab_metal", "speak_mega"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.player_pain_husk_hands = {
		name: "Husk",
		maxhp: 14,
		hp: 7,
		actions: ["husk_attack_hands", "prayer", "falseprayer", "special_prophesize"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.player_pain_husk_akizet = {
		name: "Akizet?",
		maxhp: 18,
		hp: 9,
		actions: ["eviscerate_better", "frenzy", "speak_light", "wild_surge"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["player_ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.player_pain_husk_gakvu = {
		name: "Gakvu?",
		maxhp: 15,
		hp: 8,
		actions: ["countercall", "special_mass_destabilize", "dullflare_weak", "special_invoke_madness"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["player_ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.player_pain_husk_tozik = {
		name: "Tozik?",
		maxhp: 15,
		hp: 8,
		actions: ["parasite", "optimize", "special_final_sacrifice", "sacrifice_restore"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["player_ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.player_pain_husk_miltza = {
		name: "Miltza?",
		maxhp: 15,
		hp: 8,
		actions: ["miltza_attack", "ultra_spy", "plot", "special_enact"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["player_ethereal", 1], ["attack_drone", 1]],
	}
	
	env.COMBAT_ACTORS.player_pain_husk_bozko = {
		name: "Bozko?",
		maxhp: 22,
		hp: 11,
		actions: ["cripple", "special_guard_all", "speak_bone", "special_carapace_allies"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["player_ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.player_pain_husk_cavik = {
		name: "Cavik?",
		maxhp: 15,
		hp: 8,
		actions: ["bazruka", "special_restorative_barrier", "bite_weak", "surge"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["player_ethereal", 1], ["focused", 1]],
	}
	
	env.COMBAT_ACTORS.player_pain_husk_ikgolem = {
		name: "IK?",
		maxhp: 20,
		hp: 10,
		actions: ["windup", "husk_attack", "speak"],
		windupActions: ["cavernhammer_vanity", "quick_forge_vanity", "focused_windup"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["player_ethereal", 1]],
	}
	
	env.COMBAT_ACTORS.player_pain_husk_kazki = {
		name: "Kazki?",
		maxhp: 15,
		hp: 8,
		actions: ["special_fullauto_player", "sidearm", "daemon_floor_it", "coordination"],

		graphic: `
			<div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
				<div class="spritestack" id="%SLUG-sprite">
					<img src="" class="sprite basis">
					<div class="sprite toplayer"></div>
					<div class="sprite bottomlayer"></div>
				</div>
				<div class="target" entity="husk"></div>
			</div>
		`,
	   reactions: {
			evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
			crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
			receive_crit: ["hu r ts"],
			receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
			receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
			receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct"],
			receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e"],
			receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
			receive_redirection: ["f ina l ly aw  ake"],
			stun: ["o u  t ou t o ut", "ou to u t o  ut"],
			regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
			give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
		},
		initialStatusEffects: [["player_ethereal", 1]],
	}
	
	//oh god here we go again
	//husked combat actors start here
	env.COMBAT_ACTORS.container_husked = {
        name: "Container",
        maxhp: 6,
        hp: 6,
        actions: ["attack", "attack", "attack", "skitter"],
        graphic: `
            <div class="sprite-wrapper" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="/img/sprites/combat/foes/inc.gif" id="%SLUG-sprite">
                <div class="target" entity="hostile container"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        turnCheck: "container"
    }
	
	env.COMBAT_ACTORS.attendant_husked = {
        name: "Spire Attendant",
        maxhp: 8,
        hp: 8,
        actions: ["attack", "foe_stab"],
        graphic: `
            <div class="sprite-wrapper" id="%SLUG-sprite-wrapper">
                <div class="attendant-sprite">
                    <img class="sprite" src="/img/local/embassy/spiredronebody.gif" id="%SLUG-sprite">
                </div>
                <div class="target" entity="attendant"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]]
    }
	
	env.COMBAT_ACTORS.tendrils_proxy_husked = {
        name: "Tendril",
        turnCheck: "tendrils",
        maxhp: 10,
        hp: 10,
        actions: ["swipe"],
        graphic: `
            <div class="sprite-wrapper" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="/img/sprites/combat/foes/tendrils.gif" id="%SLUG-sprite">
                <div class="target" entity="tendrils"></div>
            </div>
            `,
        reactions: {},
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]]
    }
	
	env.COMBAT_ACTORS.veilklight_husked = {
        name: "Veilklight",
        maxhp: 10,
        hp: 10,
        actions: ["spy", "mend", "daze_lastresort"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper" id="%SLUG-sprite-wrapper">
                <div class="veilksprite">
                    <img class="sprite" src="/img/sprites/combat/foes/foelampbase.gif" id="%SLUG-sprite">
                </div>
                <div class="target" entity="hostile veilklight"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        }
    }
	
	env.COMBAT_ACTORS.archival_golem_husked = {
        name: "Archival Golem",
        maxhp: 40,
        hp: 30,
        actions: ["windup"],
        windupActions: ["archival_smash"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper archival-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/archivalgolem.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/archivalgolem-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/archivalgolem-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/archivalgolem-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="archival golem"></div>
            </div>
            `,
        reactions: {} //SILENT CREATURE
    }
	
	env.COMBAT_ACTORS.bstrdlight_proxy_husked = {
        name: "BSTRDlight",
        maxhp: 40,
        hp: 30,
        actions: ["spy", "mend", "special_mass_destabilize", "swipe", "rez_player"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper" id="%SLUG-sprite-wrapper">
                <div class="veilksprite bstrdlight">
                    <img class="sprite" src="/img/sprites/combat/foes/bstrdlampbase.gif" id="%SLUG-sprite">
                </div>
                <div class="target" entity="bstrdlight"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
        turnCheck: "lastRezzer"
    }
	
	env.COMBAT_ACTORS.maintcloak_husked = {
        name: "Jutskin",
        maxhp: 30,
        hp: 20,
        actions: ["special_barrier_allies_player", "stab"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper maintcloak" id="%SLUG-sprite-wrapper">
                <div class="spritestack" style="transform-style: preserve-3d;">
                    <img class="sprite" src="/img/sprites/combat/foes/maintcloak.gif">
                    <img class="sprite" src="/img/sprites/combat/foes/mainthead.gif">
                    <img class="sprite" src="/img/sprites/combat/foes/mainthead.gif">

                    <div class="target" entity="jutskin"></div>
                </div>
            </div>
        `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
        turnCheck: "maintcloak"
    }
	
	env.COMBAT_ACTORS.husk_husked = {
        name: "Husk",
        readoutActor: "husk",
        maxhp: 20,
        hp: 20,
        actions: ["husk_attack", "speak", "stab", "evade"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],

        //graphic is controlled mainly by the sprite creation event below, check it out!
        graphic: `
            <div class="sprite-wrapper husk" id="%SLUG-sprite-wrapper" type="">
                <div class="spritestack" id="%SLUG-sprite">
                    <img src="" class="sprite basis">
                    <div class="sprite toplayer"></div>
                    <div class="sprite bottomlayer"></div>
                </div>
                <div class="target" entity="husk"></div>
            </div>
        `,

        reactions: {
            evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er", "", "", "", "", "", ""],
            crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN", "", "", "", "", "", ""],
            receive_crit: ["hu r ts", "", "", "", "", "", ""],
            receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™", "", "", "", "", "", ""],
            puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™", "", "", "", "", "", ""],
            receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘", "", "", "", "", "", ""],
            receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct", "", "", "", "", "", ""],
            receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e", "", "", "", "", "", ""],
            receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘", "", "", "", "", "", ""],
            receive_redirection: ["f ina l ly aw  ake", "", "", "", "", "", ""],
            stun: ["o u  t ou t o ut", "ou to u t o  ut", "", "", "", "", "", ""],
            regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e", "", "", "", "", "", ""],
            give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ", "", "", "", "", "", ""],
        },

        regenAllSprites: (ungeneratedOnly = false) => { //used in combat and stage stuff
            let query = '.husk.sprite-wrapper'
            if(ungeneratedOnly) query = '.husk.sprite-wrapper:not(.generated)'
            document.querySelectorAll('.husk.sprite-wrapper').forEach(sprite=>{
                env.COMBAT_ACTORS.husk.events.onSpriteCreation(sprite)
            })
        },
        
        events: {
            onSpriteCreation: (sprite) => {
                if(content.querySelector("critta-map")) { return }

                let types = [
                    {
                        name: "type1",
                        bottomCount: 2,
                        topCount: 3
                    },
                    {
                        name: "type2",
                        bottomCount: 2,
                        topCount: 2
                    },
                    {
                        name: "type3",
                        bottomCount: 2,
                        topCount: 2
                    },
                    {
                        name: "type4",
                        bottomCount: 2,
                        topCount: 3
                    },
                ]

                let type = types.sample()
                type.decidedT = rand(1, type.topCount + 1)
                type.decidedB = rand(1, type.bottomCount + 1)
                sprite.setAttribute("type", type.name.replace('type', ''))
                sprite.setAttribute("b", type.decidedB)
                sprite.setAttribute("t", type.decidedT)
                sprite.querySelector("img.basis").src = `/img/sprites/combat/foes/husks/${type.name}_bottom${type.decidedB}.gif`
                sprite.classList.add('generated')
            }
        }
    }
	
	env.COMBAT_ACTORS.constructor_golem_husked = {
        name: "Constructor",
        maxhp: 15,
        hp: 15,
        actions: ["attack", "barrier", "spy_analyze", "special_limited_carapace"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper constructor-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/constructor.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/constructor-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/constructor-neck.gif" id="%SLUG-golemsprite-neck" class="sprite golemsprite-neck">
                    <img src="/img/sprites/combat/foes/constructor-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/constructor-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="constructor"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        }
    }
	
	env.COMBAT_ACTORS.pressure_golem_husked = {
        name: "Kivskin",
        maxhp: 25,
        hp: 25,
        actions: ["bozko_attack", "guard"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper pressure-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/pressure.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/pressure-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/pressure-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/pressure-leftarm.gif" id="%SLUG-golemsprite-leftarm" class="sprite golemsprite-leftarm">
                    <img src="/img/sprites/combat/foes/pressure-rightarm.gif" id="%SLUG-golemsprite-rightarm" class="sprite golemsprite-rightarm">
                </div>

                <div class="target" entity="kivskin"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        }
    }
	
	env.COMBAT_ACTORS.dull_golem_husked = {
        name: "Dullfriend",
        maxhp: 35,
        hp: 35,
        actions: ["brawl", "windup"],
        windupActions: ["ik_attack", "dullflare", "focused_windup"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper golemsprite bossgolem" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/golemboss.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/golemboss-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/golemboss-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/golemboss-arms.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="foundation golem"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        }
    }
	
	env.COMBAT_ACTORS.surgeon_golem_husked = {
        name: "Repairfriend",
        maxhp: 15,
        hp: 15,
        actions: ["mend", "tozik_attack", "foe_stab"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper surgeon-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/surgeon.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/surgeon-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/surgeon-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/surgeon-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="repairfriend"></div>
            </div>
        `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        }
    }
	
	env.COMBAT_ACTORS.basic_golem_husked = {
        name: "Golem",
        maxhp: 15,
        hp: 15,
        actions: ["special_self_destruct", "berserk", "foe_stab"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper golemsprite basic-golem" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/golem.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/golem-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/golem-neck.gif" id="%SLUG-golemsprite-neck" class="sprite golemsprite-neck">
                    <img src="/img/sprites/combat/foes/golem-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/golem-leftarm.gif" id="%SLUG-golemsprite-leftarm" class="sprite golemsprite-leftarm">
                    <img src="/img/sprites/combat/foes/golem-rightarm.gif" id="%SLUG-golemsprite-rightarm" class="sprite golemsprite-rightarm">
                </div>

                <div class="target" entity="golem"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        }
    }
	
	env.COMBAT_ACTORS.kivii_gauntlet_husked = {
        name: "Gauntlet",
        maxhp: 175,
        hp: 175,
        actions: ["windup", "kivii_grasp"],
        windupActions: ["archival_smash"],
        graphic: `
            <div class="sprite-wrapper kiviigauntlet" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="/img/sprites/combat/foes/kivii/gauntlet.gif" id="%SLUG-sprite">
                <div class="target" entity="gauntlet"></div>
            </div>
            `,
        reactions: {},
        initialStatusEffects: [["player_ethereal", 1], ["conjoined", 1]]
    }
	
	env.COMBAT_ACTORS.dull_container_husked = {
        name: "Warped Container",
        maxhp: 2,
        hp: 2,
        actions: ["brawl_weak"],
        graphic: `
            <div class="sprite-wrapper dulltainer" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="/img/sprites/combat/foes/inc_dull.gif" id="%SLUG-sprite">
                <div class="target" entity="warped container"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
        initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]]
    }
	
	env.COMBAT_ACTORS.hallucination_proxy_husked = {
        name: "Â»ÃµGQÃ Âº3Â¾Ãµâ€cR%",
        maxhp: 3,
        hp: 3,
        actions: ["speak", "husk_attack_weak"],
        graphic: `
            <div class="sprite-wrapper hallucination" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img class="sprite basis" src="/img/sprites/combat/foes/hallucinations/akizet.png" id="%SLUG-sprite">
                    <img class="sprite base" src="/img/sprites/combat/foes/hallucinations/akizet.png" id="%SLUG-sprite">
                    <img class="sprite eyes" src="/img/sprites/combat/foes/hallucinations/akizet_eyes.png" id="%SLUG-sprite">
                </div>
                <div class="target" entity="Â»ÃµGQÃ Âº3Â¾Ãµâ€cR%"></div>
            </div>
            `,
        reactions: {},
        initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        turnCheck: "hallucinations",
        events: {
            onSpriteCreation: (sprite) => {
                if(!sprite) return
        
                let basis = sprite.querySelector('img.basis')
                let base = sprite.querySelector('img.base')
                let eyes = sprite.querySelector('img.eyes')
                let hallucinatorbase = false
                fetch(`https://adrfurret.neocities.org/corrumods/img/sprites/combat/foes/hallucinations/${env.hallucinator}.gif`).then(resp=>{if(resp.status != 404){hallucinatorbase = true}})

                if(env.hallucinator.slice(0, 7) == "generic") {
                    basis.src = `https://adrfurret.neocities.org/corrumods/img/sprites/combat/foes/hallucinations/generic.gif`
                    base.src = `https://adrfurret.neocities.org/corrumods/img/sprites/combat/foes/hallucinations/generic.gif`
                    eyes.src = `https://adrfurret.neocities.org/corrumods/img/sprites/combat/foes/hallucinations/generic_eyes.gif`
                } else if (hallucinatorbase == true){
                    basis.src = `https://adrfurret.neocities.org/corrumods/img/sprites/combat/foes/hallucinations/${env.hallucinator}.gif`
                    base.src = `https://adrfurret.neocities.org/corrumods/img/sprites/combat/foes/hallucinations/${env.hallucinator}.gif`
                    eyes.src = `https://adrfurret.neocities.org/corrumods/img/sprites/combat/foes/hallucinations/${env.hallucinator}_eyes.gif`                    
                } else {
                    basis.src = `https://adrfurret.neocities.org/corrumods/img/sprites/combat/foes/hallucinations/generic.gif`
                    base.src = `https://adrfurret.neocities.org/corrumods/img/sprites/combat/foes/hallucinations/generic.gif`
                    eyes.src = `https://adrfurret.neocities.org/corrumods/img/sprites/combat/foes/hallucinations/generic_eyes.gif`
                }
            }
        }
    }
	
	env.COMBAT_ACTORS.critta_pawn_husked = {
        name: "WRK",
        specialClass: "daemonactor",
        maxhp: 20,
        actions: ["revise", "mad_claw", "evade"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="wrk"></div>
                <figure class="daemon pawn accurate-position"> 
                    <img src="/img/sprites/daemons/pawn/base.gif">
                    <div class="eye"></div>
                    <div class="scraps noimg">
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                    </div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        }
    }
	
	env.COMBAT_ACTORS.critta_knight_husked = {
        name: "CLW",
        specialClass: "daemonactor",
        maxhp: 30,
        actions: ["cripple", "exploit", "surge"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="clw"></div>
                <figure class="daemon rook accurate-position">
                    <img src="/img/sprites/daemons/rook/body.gif">
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="leftarm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                    <div class="rightarm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                </figure>
                
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    }
	
	env.COMBAT_ACTORS.critta_bishop_husked = {
        name: "NET",
        specialClass: "daemonactor",
        maxhp: 25,
        actions: ["speak", "parasite", "empower", "rez_player"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="net"></div>
                <figure class="daemon bishop accurate-position">
                    <img src="/img/sprites/daemons/bishop/base.gif">
                    <div class="eye"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    }
	
	env.COMBAT_ACTORS.critta_rook_husked = {
        name: "ENFC",
        specialClass: "daemonactor",
        maxhp: 40,
        actions: ["enforce", "focused_guard"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="enfc"></div>
                <figure class="daemon knight accurate-position">
                    <img src="/img/sprites/daemons/knight/body.gif">
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="uparm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    }
	
	env.COMBAT_ACTORS.critta_queen_husked = {
        name: "SEER",
        specialClass: "daemonactor",
        maxhp: 45,
        actions: ["windup"],
        windupActions: ["special_rule", "wound_lastresort"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="seer"></div>
                <figure class="daemon queen accurate-position">
                    <img src="/img/sprites/daemons/queen/core.gif">
                    <div class="eye"></div>
                    <div class="ring"></div>
                    <div class="ring"></div>
                    <div class="ring"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    }
	
	env.COMBAT_ACTORS.critta_king_husked = {
        name: "ARCHN",
        specialClass: "daemonactor",
        maxhp: 50,
        actions: ["windup"],
        windupActions: ["special_judgement"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="archn"></div>
                <figure class="daemon king accurate-position">
                    <img src="/img/sprites/daemons/king/angles.gif">
                    <img src="/img/sprites/daemons/king/angles.gif">
                    <div class="box center"></div>
                    <div class="box outer"></div>
                    <div class="ring"></div>
                    <div class="eye"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    }
	
	env.COMBAT_ACTORS.critta_spawner_bee_husked = {
        name: "IDEA",
        specialClass: "daemonactor",
        maxhp: 10,
        actions: ["husk_attack_rot", "surge"],
        initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        turnCheck: "genericEthereal",
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="idea"></div>
                <figure class="daemon bee"><div class="sides"><span></span><span></span><span></span><span></span><span></span><span></span></div></figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
    }
	
	env.COMBAT_ACTORS.akizet_boss_husked = {
        name: "Leaderfriend",
        maxhp: 25,
        hp: 25,
        actions: [
            "akizet_attack",
            "stab", 
            "evade"
        ],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper akizet" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/akizet/dith.gif">
                    <div class="target" entity="akizetesche"></div>
                </div>
            </div>
        `,
        reactions: {
            evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er", "", "", "", "", "", ""],
            crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN", "", "", "", "", "", ""],
            receive_crit: ["hu r ts", "", "", "", "", "", ""],
            receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™", "", "", "", "", "", ""],
            puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™", "", "", "", "", "", ""],
            receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘", "", "", "", "", "", ""],
            receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct", "", "", "", "", "", ""],
            receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e", "", "", "", "", "", ""],
            receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘", "", "", "", "", "", ""],
            receive_redirection: ["f ina l ly aw  ake", "", "", "", "", "", ""],
            stun: ["o u  t ou t o ut", "ou to u t o  ut", "", "", "", "", "", ""],
            regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e", "", "", "", "", "", ""],
            give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ", "", "", "", "", "", ""],
        }
    }
	
	env.COMBAT_ACTORS.gakvu_boss_husked = {
        name: "Groundsfriend",
        maxhp: 20,
        hp: 20,
        actions: ["gakvu_attack", "destabilize", "evade"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper gakvu" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/gakvu/full/gakvu_legs.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/gakvu/full/gakvu_poncho.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/gakvu/full/gakvu_head.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/gakvu/full/gakvu_face.gif">
                    <div class="target" entity="gakvu"></div>
                </div>
            </div>
        `,
        reactions: {
            evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er", "", "", "", "", "", ""],
            crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN", "", "", "", "", "", ""],
            receive_crit: ["hu r ts", "", "", "", "", "", ""],
            receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™", "", "", "", "", "", ""],
            puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™", "", "", "", "", "", ""],
            receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘", "", "", "", "", "", ""],
            receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct", "", "", "", "", "", ""],
            receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e", "", "", "", "", "", ""],
            receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘", "", "", "", "", "", ""],
            receive_redirection: ["f ina l ly aw  ake", "", "", "", "", "", ""],
            stun: ["o u  t ou t o ut", "ou to u t o  ut", "", "", "", "", "", ""],
            regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e", "", "", "", "", "", ""],
            give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ", "", "", "", "", "", ""],
        },
    }
	
	env.COMBAT_ACTORS.tozik_boss_husked = {
        name: "Mendfriend",
        maxhp: 20,
        hp: 20,
        actions: ["tozik_attack", "mend", "evade"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper tozik" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/tozik/full/tozik_body.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/tozik/full/tozik_arms.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/tozik/full/tozik_headcore.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/tozik/full/tozik_head.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/tozik/full/tozik_eyes.gif">
                    <div class="target" entity="tozik"></div>
                </div>
            </div>
        `,
        reactions: {
            evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er", "", "", "", "", "", ""],
            crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN", "", "", "", "", "", ""],
            receive_crit: ["hu r ts", "", "", "", "", "", ""],
            receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™", "", "", "", "", "", ""],
            puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™", "", "", "", "", "", ""],
            receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘", "", "", "", "", "", ""],
            receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct", "", "", "", "", "", ""],
            receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e", "", "", "", "", "", ""],
            receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘", "", "", "", "", "", ""],
            receive_redirection: ["f ina l ly aw  ake", "", "", "", "", "", ""],
            stun: ["o u  t ou t o ut", "ou to u t o  ut", "", "", "", "", "", ""],
            regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e", "", "", "", "", "", ""],
            give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ", "", "", "", "", "", ""],
        }
    }
	
	env.COMBAT_ACTORS.miltza_boss_husked = {
        name: "Planfriend",
        maxhp: 20,
        hp: 20,
        actions: ["miltza_attack", "spy", "evade"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper miltza" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/miltza/full/legs.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/miltza/full/torso.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/miltza/full/arms.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/miltza/full/okizika_arm.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/miltza/full/head.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/miltza/full/face.gif">
                    <div class="target" entity="miltza"></div>
                </div>
            </div>
        `,
        reactions: {
            evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er", "", "", "", "", "", ""],
            crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN", "", "", "", "", "", ""],
            receive_crit: ["hu r ts", "", "", "", "", "", ""],
            receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™", "", "", "", "", "", ""],
            puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™", "", "", "", "", "", ""],
            receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘", "", "", "", "", "", ""],
            receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct", "", "", "", "", "", ""],
            receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e", "", "", "", "", "", ""],
            receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘", "", "", "", "", "", ""],
            receive_redirection: ["f ina l ly aw  ake", "", "", "", "", "", ""],
            stun: ["o u  t ou t o ut", "ou to u t o  ut", "", "", "", "", "", ""],
            regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e", "", "", "", "", "", ""],
            give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ", "", "", "", "", "", ""],
        }
    }
	
	env.COMBAT_ACTORS.cavik_boss_husked = {
        name: "Kavrukafriend",
        initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1], ["fear", 1]],
        maxhp: 20,
        hp: 20,
        actions: ["cavik_attack", "special_barrier_allies", "evade"],
        graphic: `
            <div class="sprite-wrapper cavik" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/cavik/full/cavikabdomen.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/cavik/full/cavikboots.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/cavik/full/cavikhands.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/cavik/full/cavikponcho.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/cavik/full/cavikhair.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/cavik/full/cavikmask.gif">
                    <div class="target" entity="cavik"></div>
                </div>
            </div>
        `,
        reactions: {
            evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er", "", "", "", "", "", ""],
            crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN", "", "", "", "", "", ""],
            receive_crit: ["hu r ts", "", "", "", "", "", ""],
            receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™", "", "", "", "", "", ""],
            puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™", "", "", "", "", "", ""],
            receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘", "", "", "", "", "", ""],
            receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct", "", "", "", "", "", ""],
            receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e", "", "", "", "", "", ""],
            receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘", "", "", "", "", "", ""],
            receive_redirection: ["f ina l ly aw  ake", "", "", "", "", "", ""],
            stun: ["o u  t ou t o ut", "ou to u t o  ut", "", "", "", "", "", ""],
            regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e", "", "", "", "", "", ""],
            give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ", "", "", "", "", "", ""],
        }
    }
	
	env.COMBAT_ACTORS.bozko_boss_husked = {
        name: "Guardfriend",
        maxhp: 35,
        hp: 35,
        actions: ["bozko_attack", "guard", "shell"],
		initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1]],
        graphic: `
            <div class="sprite-wrapper bozko" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/bozko/full/bozkofingers.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/bozko/full/bozkoarms.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/bozko/full/bozkobody.gif">
                    <img class="sprite" src="https://adrfurret.neocities.org/corrumods/img/sprites/obesk/bozko/full/bozkohead.gif">
                    <div class="target" entity="bozko"></div>
                </div>
            </div>
        `,
        reactions: {
            evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er", "", "", "", "", "", ""],
            crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN", "", "", "", "", "", ""],
            receive_crit: ["hu r ts", "", "", "", "", "", ""],
            receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™", "", "", "", "", "", ""],
            puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™", "", "", "", "", "", ""],
            receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘", "", "", "", "", "", ""],
            receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã", "dÃ†is co ne ct", "", "", "", "", "", ""],
            receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶", "s e e", "", "", "", "", "", ""],
            receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘", "", "", "", "", "", ""],
            receive_redirection: ["f ina l ly aw  ake", "", "", "", "", "", ""],
            stun: ["o u  t ou t o ut", "ou to u t o  ut", "", "", "", "", "", ""],
            regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e", "", "", "", "", "", ""],
            give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ", "", "", "", "", "", ""],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_blocker_husked = {
        name: "???",
        maxhp: 300,
        specialClass: "intrusiveactor",
        actions: ["guard"],
        initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1],["weak_point", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/2.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_archival_husked = {
        name: "???",
        maxhp: 400,
        hp: 300,
        specialClass: "intrusiveactor",
        actions: ["windup"],
        windupActions: ["trusive_smash"],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/3.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_bishopfreak_husked = {
        name: "???",
        maxhp: 200,
        specialClass: "intrusiveactor",
        actions: ["frenzy", "special_restorative_barrier", "coordination"],
        initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1], ["impatient", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/4.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_statusoid_husked = {
        name: "???",
        maxhp: 400,
        specialClass: "intrusiveactor",
        actions: ["revise", "special_mass_destabilize"],
        initialStatusEffects: [["player_ethereal", 1], ["puppet_conjoined", 1], ["impatient", 1], ["active_support", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/5.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.pain_secri_enemy = {
        name: "Secri",
        maxhp: 20,
        hp: 10,
        actions: ["secri_crush", "special_fullauto_secri", "special_raise"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper bstrdshelf" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="/img/sprites/combat/foes/archivalfoea.gif" style="height: 60vh; width: 60vw;">
                <div class="target" entity="pain shelf"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        }
    }
	
	env.COMBAT_ACTORS.pain_secri_ally = {
        name: "Secri",
        maxhp: 20,
        hp: 10,
        actions: ["secri_crush", "special_fullauto_secri", "special_raise"],
		initialStatusEffects: [["player_ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper bstrdshelf" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="/img/sprites/combat/foes/archivalfoea.gif" style="height: 60vh; width: 60vw;">
                <div class="target" entity="pain shelf"></div>
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        }
    }
	
	env.COMBAT_ACTORS.intrusive_blocker_weak = {
        name: "???",
        maxhp: 30,
        specialClass: "intrusiveactor",
        actions: ["guard"],
        initialStatusEffects: [["weak_point", 1], ["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/2.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_blocker_micro = {
        name: "???",
        maxhp: 15,
        specialClass: "intrusiveactor",
        actions: ["guard"],
        initialStatusEffects: [["weak_point", 1], ["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/2.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_blocker_mega = {
        name: "???",
        maxhp: 60,
        specialClass: "intrusiveactor",
        actions: ["special_guard_all"],
        initialStatusEffects: [["weak_point", 1], ["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/2.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_archival_weak = {
        name: "???",
        maxhp: 40,
        hp: 30,
        specialClass: "intrusiveactor",
        actions: ["windup"],
        windupActions: ["intrusive_smash"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/3.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_archival_micro = {
        name: "???",
        maxhp: 20,
        hp: 15,
        specialClass: "intrusiveactor",
        actions: ["intrusive_smash_weak"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/3.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_archival_mega = {
        name: "???",
        maxhp: 80,
        hp: 60,
        specialClass: "intrusiveactor",
        actions: ["windup_surge"],
        windupActions: ["trusive_smash"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/3.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_bishopfreak_weak = {
        name: "???",
        maxhp: 20,
        specialClass: "intrusiveactor",
        actions: ["frenzy", "special_restorative_barrier", "coordination"],
        initialStatusEffects: [["impatient", 1], ["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/4.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_bishopfreak_micro = {
        name: "???",
        maxhp: 10,
        specialClass: "intrusiveactor",
        actions: ["stab", "special_restorative_barrier_weak", "evade"],
        initialStatusEffects: [["impatient", 1], ["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/4.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_bishopfreak_mega = {
        name: "???",
        maxhp: 40,
        specialClass: "intrusiveactor",
        actions: ["bazruka", "special_restorative_barrier", "special_hardening_barrier", "special_chitinous_barrier", "special_surge_allies_mega"],
        initialStatusEffects: [["impatient", 1], ["dull_multitool", 1], ["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/4.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_statusoid_weak = {
        name: "???",
        maxhp: 40,
        specialClass: "intrusiveactor",
        actions: ["revise", "special_mass_destabilize"],
        initialStatusEffects: [["impatient", 1], ["active_support", 1], ["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/5.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_statusoid_micro = {
        name: "???",
        maxhp: 20,
        specialClass: "intrusiveactor",
        actions: ["mad_claw", "special_irradiate"],
        initialStatusEffects: [["impatient", 1], ["active_support", 1], ["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/5.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_statusoid_mega = {
        name: "???",
        maxhp: 80,
        specialClass: "intrusiveactor",
        actions: ["revise_all", "special_mass_denature", "special_invoke_madness"],
        initialStatusEffects: [["impatient", 1], ["active_support", 1], ["visionary", 1], ["retaliation", 1], ["dull_pragmatist", 1], ["flesh_menace", 1], ["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/5.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
    env.COMBAT_ACTORS.intrusive_bomblet_weak = {
        name: "???",
        maxhp: 30,
        specialClass: "intrusiveactor",
        actions: ["nothing"],
        initialStatusEffects: [["ominous_timer", 1], ["ethereal", 1]],
        statusImmunities: ["stun"],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <div class="timer"></div>
                <img src="/img/sprites/flantrusive/6.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
    env.COMBAT_ACTORS.intrusive_bomblet_micro = {
        name: "???",
        maxhp: 15,
        specialClass: "intrusiveactor",
        actions: ["nothing"],
        initialStatusEffects: [["ominous_timer_short", 1], ["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <div class="timer"></div>
                <img src="/img/sprites/flantrusive/6.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
    env.COMBAT_ACTORS.intrusive_bomblet_mega = {
        name: "???",
        maxhp: 60,
        specialClass: "intrusiveactor",
        actions: ["nothing"],
        initialStatusEffects: [["ominous_timer_long", 1], ["ethereal", 1]],
        statusImmunities: ["stun", "hyperstun"],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <div class="timer"></div>
                <img src="/img/sprites/flantrusive/6.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_blocker_weak_ally = {
        name: "???",
        maxhp: 30,
        specialClass: "intrusiveactor",
        actions: ["guard"],
        initialStatusEffects: [["weak_point", 1], ["player_ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/2.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_blocker_micro_ally = {
        name: "???",
        maxhp: 15,
        specialClass: "intrusiveactor",
        actions: ["guard"], // TODO::replace this with a weaker version; gives only +1T:REDIRECTION maybe?
        initialStatusEffects: [["weak_point", 1], ["player_ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/2.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_blocker_mega_ally = {
        name: "???",
        maxhp: 60,
        specialClass: "intrusiveactor",
        actions: ["special_guard_all"],
        initialStatusEffects: [["weak_point", 1], ["player_ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/2.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_archival_weak_ally = {
        name: "???",
        maxhp: 40,
        hp: 30,
        specialClass: "intrusiveactor",
        actions: ["windup"],
        windupActions: ["trusive_smash"],
		initialStatusEffects: [["player_ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/3.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_archival_micro_ally = {
        name: "???",
        maxhp: 20,
        hp: 15,
        specialClass: "intrusiveactor",
        actions: ["trusive_smash_weak"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/3.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_archival_mega_ally = {
        name: "???",
        maxhp: 80,
        hp: 60,
        specialClass: "intrusiveactor",
        actions: ["windup_surge"],
        windupActions: ["trusive_smash"],
		initialStatusEffects: [["player_ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/3.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_bishopfreak_weak_ally = {
        name: "???",
        maxhp: 20,
        specialClass: "intrusiveactor",
        actions: ["frenzy", "special_restorative_barrier", "coordination"],
        initialStatusEffects: [["impatient", 1], ["player_ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/4.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_bishopfreak_micro_ally = {
        name: "???",
        maxhp: 10,
        specialClass: "intrusiveactor",
        actions: ["stab", "special_restorative_barrier_weak", "evade"],
        initialStatusEffects: [["impatient", 1], ["player_ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/4.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_bishopfreak_mega_ally = {
        name: "???",
        maxhp: 40,
        specialClass: "intrusiveactor",
        actions: ["bazruka", "special_restorative_barrier", "special_hardening_barrier", "special_chitinous_barrier", "special_surge_allies_mega"],
        initialStatusEffects: [["impatient", 1], ["dull_multitool", 1], ["player_ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/4.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_statusoid_weak_ally = {
        name: "???",
        maxhp: 40,
        specialClass: "intrusiveactor",
        actions: ["revise", "special_mass_destabilize"],
        initialStatusEffects: [["impatient", 1], ["active_support", 1], ["player_ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/5.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_statusoid_micro_ally = {
        name: "???",
        maxhp: 20,
        specialClass: "intrusiveactor",
        actions: ["mad_claw", "special_irradiate"],
        initialStatusEffects: [["impatient", 1], ["active_support", 1], ["player_ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/5.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
	env.COMBAT_ACTORS.intrusive_statusoid_mega = {
        name: "???",
        maxhp: 80,
        specialClass: "intrusiveactor",
        actions: ["revise", "special_mass_destabilize", "special_invoke_madness"],
        initialStatusEffects: [["impatient", 1], ["active_support", 1], ["visionary", 1], ["retaliation", 1], ["dull_pragmatist", 1], ["flesh_menace", 1], ["player_ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/5.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        }
    }
	
    env.COMBAT_ACTORS.heart_formless = {
        //basic enemy type that just runs and hits (formless swipe and skitter maybe?)
        name: "Mass",
        maxhp: 5,
        hp: 1,
        move: 2, //leaving this here should be fine maybe
        actions: ["heart_whelm"],
        initialStatusEffects: [["player_ethereal", 1]],
        graphic: `
        <div class="sprite-wrapper spectral autosize" id="%SLUG-sprite-wrapper">
            <div class="target" entity="spectral mass"></div>
            <img class="sprite" src="/img/sprites/combat/foes/constructor_spectral.gif" id="%SLUG-sprite">
        </div>
        `,
		reactions: {} //spectres don't talk i guess
    }
	
    env.COMBAT_ACTORS.heart_puncher = {
        //knockback-focused basic enemy (this can probably stay mostly the same)
        name: "Figure",
        maxhp: 8,
        hp: 4,
        move: 3,
        actions: ["heart_punch"],
        initialStatusEffects: [["player_ethereal", 1]],
        graphic: `
        <div class="sprite-wrapper spectral autosize" id="%SLUG-sprite-wrapper">
            <div class="target" entity="spectral figure"></div>
            <img class="sprite" src="/img/sprites/combat/foes/shaped_1.gif" id="%SLUG-sprite">
        </div>
        `,
		reactions: {} //spectres don't talk i guess
    }
	
    env.COMBAT_ACTORS.heart_harasser = {
        // annoyer enemy
        // teleports to an enemy on turn start, teleports away on stab success (yeah this is gonna require some shenaniganizing)
        name: "Attendant",
        maxhp: 8,
        hp: 4,
        move: 3,
        actions: ["windup_telegraph_flicker"],
		windupActions: ["heart_harasser_stab"],
        initialStatusEffects: [["player_ethereal", 1]],
        graphic: `
        <div class="sprite-wrapper spectral autosize" id="%SLUG-sprite-wrapper">
            <div class="target" entity="spectral attendant"></div>
            <img class="sprite" src="/img/sprites/combat/foes/attendant_spectral.gif" id="%SLUG-sprite">
        </div>
        `,
		reactions: {} //spectres don't talk i guess
    }
	
    env.COMBAT_ACTORS.heart_bomber = {
        name: "Shape",
        maxhp: 8,
        hp: 4,
        move: 3,
        /* Bomb + shape AOE thrown on foes. (no sorrgy you're getting IED now) */
        actions: ["heart_ied"],
        initialStatusEffects: [["player_ethereal", 1]],
        graphic: `
        <div class="sprite-wrapper spectral autosize" id="%SLUG-sprite-wrapper" style="width: 120px;position: absolute;bottom: 0;">
            <div class="target" entity="spectral shape"></div>
            <img class="sprite" src="/img/sprites/combat/foes/shaped_2.gif" id="%SLUG-sprite">
        </div>
        `,
		reactions: {} //spectres don't talk i guess
    }
	
    env.COMBAT_ACTORS.heart_channeler = {
        name: "Glazika",
        maxhp: 12,
        hp: 6,
        move: 3,
        actions: ["windup_telegraph_flat"],
		windupActions: ["heart_tele_channel"],
        initialStatusEffects: [["player_ethereal", 1]],
        graphic: `
        <div class="sprite-wrapper spectral autosize" id="%SLUG-sprite-wrapper">
            <div class="target" entity="spectral glazika"></div>
            <img class="sprite" src="/img/sprites/combat/foes/glazika_spectral.gif" id="%SLUG-sprite">
        </div>
        `,
		reactions: {} //spectres don't talk i guess
    }

    env.COMBAT_ACTORS.heart_charger = {
        name: "Horror",
        maxhp: 25,
        hp: 12,
        move: 6,
        immunities: {
            stun: true,
			vulnerable: true
        },
		actions: ["windup_telegraph_flat"],
        windupActions: ["heart_hulk_rampage"], //pseudo IED thing?
        initialStatusEffects: [["player_ethereal", 1]],
        graphic: `
        <div class="sprite-wrapper spectral autosize riftcharger" id="%SLUG-sprite-wrapper">
            <div class="target" entity="spectral horror"></div>
            <img class="sprite" src="/img/sprites/combat/foes/formless_charger.gif" id="%SLUG-sprite">
        </div>
        `,
		reactions: {} //spectres don't talk i guess
    }
	
	env.COMBAT_ACTORS.heart_puller = {
        name: "Golem", //obviously rename this (hehe)
        maxhp: 8,
        hp: 4,
        move: 4,
        /* like bozko's pull, but it does damage and is for enemies only <--- 1 base damage, inflicts vulnerable on hit, does a random amount of damage and stuns on a rare crit (because it flings them into a wall really hard) */
        actions: ["heart_pull"],
        initialStatusEffects: [["player_ethereal", 1]],
        graphic: `
        <div class="sprite-wrapper spectral autosize" id="%SLUG-sprite-wrapper">
            <div class="target" entity="spectral golem"></div>
            <img class="sprite" src="/img/sprites/combat/foes/golem_spectral.gif" id="%SLUG-sprite" style="transform: translateY(-10%)">
        </div>
        `,
		reactions: {} //spectres don't talk i guess
    }

	env.COMBAT_ACTORS.heart_support = {
        name: "Jutskin",
        maxhp: 8,
        hp: 4,
        move: 0,
        actions: ["windup_telegraph_flat"], //remaking this entirely, i have no fucking clue how special_arch_support works (i figured it out !! wahoo !! :D)
		windupActions: ["heart_support"],
        initialStatusEffects: [["player_ethereal", 1]],
        graphic: `
        <div class="sprite-wrapper spectral autosize" id="%SLUG-sprite-wrapper">
            <div class="target" entity="spectral jutskin"></div>
            <img class="sprite" src="/img/sprites/combat/foes/maintcloak_spectral.gif" id="%SLUG-sprite">
        </div>
        `,
		reactions: {} //spectres don't talk i guess
    }
	
	env.COMBAT_ACTORS.heart_keeper = {
        name: "Keeper",
        maxhp: 5,
        hp: 3,
        move: 3,
        actions: ["heart_golem_lunge"],
        windupActions: ["archival_smash"],
        initialStatusEffects: [["player_ethereal", 1]],
        graphic: `
        <div class="sprite-wrapper spectral autosize" id="%SLUG-sprite-wrapper">
            <div class="target" entity="spectral archival golem"></div>
            <img class="sprite" src="/img/sprites/combat/foes/archivalgolem_spectral.gif" id="%SLUG-sprite">
        </div>`,
		reactions: {} //spectres don't talk i guess
    }
	
	env.COMBAT_ACTORS.heart_formless_enraged = {
        //cribs the archivist's rampage as an extra freak during the finale (just gonna give it wild surge :P)
        name: "Enraged",
        maxhp: 5,
        hp: 1,
        move: 3,
        actions: ["heart_whelm", "wild_surge"],
		statusImmunities: ["stun"],
        initialStatusEffects: [["player_ethereal", 1]],
        graphic: `
        <div class="sprite-wrapper spectral enragedformless autosize" id="%SLUG-sprite-wrapper">
            <div class="target" entity="spectral mass"></div>
            <img class="sprite" src="/img/sprites/combat/foes/constructor_spectral.gif" id="%SLUG-sprite">
        </div>
        `,
        reactions: {} //spectres don't talk i guess
    }
	
	env.COMBAT_ACTORS.heart_golem = {
        name: "Dullfriend",
        maxhp: 40,
        hp: 20,
        initialStatusEffects: [["player_ethereal", 1]],
        immunities: {
            stun: true,
        },
        actions: ["heart_combo"], //dull combo will give windup on crit, windup actions will be the dullfriend's usual kit but with extra prep. removed
		windupActions: ["ik_attack", "dullflare"],
        graphic: `
            <div class="sprite-wrapper autosize spectral" id="%SLUG-sprite-wrapper">
                <div class="target" entity="spectral dull golem"></div>
                <img class="sprite" src="/img/sprites/combat/foes/golemboss_spectral.gif" id="%SLUG-sprite">
            </div>
        `,
		reactions: {} //spectres don't talk i guess
    }
	
	env.COMBAT_ACTORS.crit_tester = {
        name: "crittable critta",
        maxhp: 999,
        hp: 999,
        initialStatusEffects: [["invincible", 1], ["debug_incomingCrit", 1]],
        immunities: {
            stun: true,
        },
        actions: ["special_guard_all_debug"],
        graphic: `
            <div class="sprite-wrapper autosize spectral" id="%SLUG-sprite-wrapper">
                <div class="target" entity="spectral dull golem"></div>
                <img class="sprite" src="/img/sprites/combat/foes/golemboss_spectral.gif" id="%SLUG-sprite">
            </div>
        `,
		reactions: {} //spectres don't talk i guess
    }
	
	env.COMBAT_ACTORS.attack_tester = {
        name: "helpful critta",
        maxhp: 999,
        hp: 999,
        initialStatusEffects: [["invincible", 1]],
        immunities: {
            stun: true,
        },
        actions: ["special_debug"],
        graphic: `
            <div class="sprite-wrapper autosize spectral" id="%SLUG-sprite-wrapper">
                <div class="target" entity="spectral dull golem"></div>
                <img class="sprite" src="/img/sprites/combat/foes/golemboss_spectral.gif" id="%SLUG-sprite">
            </div>
        `,
		reactions: {} //spectres don't talk i guess
    }

		// need to get this creature out of my head and onto da file so i can know peace
	env.COMBAT_ACTORS.hazardous = {
        name: "!!!",
        maxhp: 500000,
        hp: 500000,
        immunities: {
            stun: true,
			weakened: true,
        },
        actions: ["special_hazardshelf_annihilate"],
        graphic: `
            <div class="sprite-wrapper hazardous" id="%SLUG-sprite-wrapper" style="transform: scale(1.85); !important;"> 
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/bstrdsing_hazardousHRM.gif" style="transform: scale(1.85); margin-top: -30vh; animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
		events: {
            onSpawn: (actor) => {
                env.rpg.classList.add('hideteams', 'intrusivetro')
                setTimeout(()=>{
                    env.rpg.classList.remove("intrusivetro")
                    env.bgm.seek(10)
                }, 500)
				
                setTimeout(()=>{
                    env.rpg.classList.remove("hideteams")
                }, 15000)
				
				setTimeout(()=>{
					env.COMBAT_ACTORS.hazardous.actions = ["special_hazardshelf_annihilate"] //this thing sucks when paired with overclock my god
					if(env.COMBAT_ACTORS.hazardous.windupActions) delete env.COMBAT_ACTORS.hazardous.windupActions
				}, 500)

                if(!check("hazard")) {
                    switch(check("e3a2escape")) {
                        case "complete":
                            change("hazard", "post-escape")
                        break

                        default:
                            change("hazard", "pre-escape")
                    }
                }
            }
        },
		reactions: {} // NO TALKING. ONLY VIOLENCE
    }
	
	env.COMBAT_ACTORS.hazardous_deconstructor = { //fucked up and evil constructor
        name: "!!!",
        maxhp: 150,
        hp: 150,
		initialStatusEffects: [["ethereal", 1]],
        actions: ["special_attack_all_wound", "barrier_reverse", "special_limited_uncarapace", "windup"],
		windupActions: ["disabler_pulse_wound"], // that's wound as in "wound up" not "open wound inflicting" btw :P
        graphic: `
            <div class="sprite-wrapper constructor-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/constructor.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/constructor-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/constructor-neck.gif" id="%SLUG-golemsprite-neck" class="sprite golemsprite-neck">
                    <img src="/img/sprites/combat/foes/constructor-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/constructor-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="constructor"></div>
            </div>
            `,
        reactions: {} // NO TALKING. ONLY VIOLENCE
    },
	
	env.COMBAT_ACTORS.hazardous_dullfriend = { //superbuffed dullfriend
        name: "!!!",
        maxhp: 350,
        hp: 350,
		initialStatusEffects: [["ethereal", 1]],
        actions: ["heart_combo", "ik_attack", "dullflare", "evade"],
        windupActions: ["cavernhammer_vanity", "quick_forge_vanity", "focused_windup"],
        graphic: `
            <div class="sprite-wrapper golemsprite bossgolem" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/golemboss.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/golemboss-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/golemboss-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/golemboss-arms.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="foundation golem"></div>
            </div>
            `,
        reactions: {} // NO TALKING. ONLY VIOLENCE
    },
	
	env.COMBAT_ACTORS.hazardous_archival = { //superbuffed archival golem
        name: "!!!",
        maxhp: 400,
        hp: 300,
		initialStatusEffects: [["ethereal", 1]],
        actions: ["heart_golem_lunge", "heart_golem_lunge", "archival_smash"],
        windupActions: ["archival_smash_mega_vanity"],
        graphic: `
            <div class="sprite-wrapper hazardous_archival" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/bstrdsing_archivalHRM.gif" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {} // NO TALKING. ONLY VIOLENCE
    },
	
	env.COMBAT_ACTORS.hazardous_veilklight = { //superbuffed veilklight
        name: "!!!",
        maxhp: 100,
        hp: 100,
		initialStatusEffects: [["ethereal", 1]],
        actions: ["ultra_spy", "optimize", "sidearm"],
        graphic: `
            <div class="sprite-wrapper" id="%SLUG-sprite-wrapper">
                <div class="veilksprite">
                    <img class="sprite" src="/img/sprites/combat/foes/foelampbase.gif" id="%SLUG-sprite">
                </div>
                <div class="target" entity="hostile veilklight"></div>
            </div>
            `,
        reactions: {} // NO TALKING. ONLY VIOLENCE
    },
	
	env.COMBAT_ACTORS.hazardous_velskin = { //inverted husk
        name: "!!!",
        maxhp: 200,
        hp: 200,
		initialStatusEffects: [["ethereal", 1]],
        actions: ["husk_attack_focused", "speak_focused", "tozik_attack_metal", "special_invite_storm"],
        graphic: `
            <div class="sprite-wrapper hazardous_velskin" id="%SLUG-sprite-wrapper" style="transform: scale(1.5);">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/bstrdsing_gakvuHRM.gif" style="transform: scale(1.5); margin-top: -15vh; animation: CONTAINERWOBBLEMINI 10s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {} // NO TALKING. ONLY VIOLENCE
    },
	
	env.COMBAT_ACTORS.hazardous_sniper = { //literally just evil geli
        name: "!!!",
        maxhp: 250,
		hp: 250,
        actions: ["unfocused_shot", "windup_cover"],
        windupActions: ["focused_shot", "hold_aim"],
        initialStatusEffects: [["visionary_geli", 1], ["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper hazardous_sniper" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/bstrdsing_hitozikHRM.gif" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {} // NO TALKING. ONLY VIOLENCE
    },
	
	env.COMBAT_ACTORS.hazardous_shotgunner = { //what it says on da tin :P
        slug: "hazardous_shotgunner",
        name: "!!!",
        maxhp: 500,
        hp: 500,
		initialStatusEffects: [["ethereal", 1]],
        actions: ["fullauto_shotgun"],
        graphic: `
            <div class="sprite-wrapper archival-golem bstrd-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/bstbody.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/bsthead.gif" id="%SLUG-golemsprite-head">
                        <img src="/img/sprites/combat/foes/bstface.gif" id="%SLUG-golemsprite-face">
                    </div>
                    <img src="/img/sprites/combat/foes/bstbody.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/bstgun.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms gunlower">
                    <img src="/img/sprites/combat/foes/bstgunraise.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms gunraise">
                    <img src="/img/sprites/combat/foes/bstgunblam.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms gunblam">
                </div>

                <div class="target" entity="bstrd golem"></div>
            </div>
            `,
        reactions: {} // NO TALKING. ONLY VIOLENCE
    },
	
	env.COMBAT_ACTORS.hazardous_kivskin = { //superbuffed kivskin
        name: "!!!",
        maxhp: 250,
        hp: 250,
		initialStatusEffects: [["ethereal", 1]],
        actions: ["cripple", "special_guard_all_bonus"],
        graphic: `
            <div class="sprite-wrapper pressure-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/pressure.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/pressure-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/pressure-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/pressure-leftarm.gif" id="%SLUG-golemsprite-leftarm" class="sprite golemsprite-leftarm">
                    <img src="/img/sprites/combat/foes/pressure-rightarm.gif" id="%SLUG-golemsprite-rightarm" class="sprite golemsprite-rightarm">
                </div>

                <div class="target" entity="kivskin"></div>
            </div>
            `,
        reactions: {} // NO TALKING. ONLY VIOLENCE
    },
	
	env.COMBAT_ACTORS.hazardous_basic_golem = { //pseudo bstrdbomb
        name: "!!!",
        maxhp: 1000,
        hp: 1000,
		initialStatusEffects: [["ethereal", 1]],
        actions: ["special_fragmentation"],
        graphic: `
            <div class="sprite-wrapper hazardous_bomber" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/bstrdsing_xplosive.gif" style="transform: scale(1.25); margin-top: -33vh; animation: SHAKE 0.05ms linear infinite;">
            </div>
            `,
        reactions: {} // NO TALKING. ONLY VIOLENCE
    },
	
	env.COMBAT_ACTORS.hazardous_slasher = { //gogo gadget CHAINSAW!!!!!!!!!!
        name: "!!!",
        maxhp: 150,
        hp: 150,
		initialStatusEffects: [["ethereal", 1]],
        actions: ["windup"],
		windupActions: ["frenzy_chainsaw"],
        graphic: `
            <div class="sprite-wrapper surgeon-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/surgeon.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/surgeon-head.gif" id="%SLUG-golemsprite-head">
                    </div>
                    <img src="/img/sprites/combat/foes/surgeon-body.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="/img/sprites/combat/foes/surgeon-arms.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms">
                </div>

                <div class="target" entity="repairfriend"></div>
            </div>
        `,
        reactions: {} // NO TALKING. ONLY VIOLENCE
    },
	
	env.COMBAT_ACTORS.hazardous_bomber = { //bazrukafreak
        name: "!!!",
        maxhp: 200,
        hp: 200,
        actions: ["bazruka"],
		initialStatusEffects: [["ethereal", 1], ["pain_rampage", 1]],
        graphic: `
            <div class="sprite-wrapper hazardous_bomber" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/bstrdsing_bazrukHRM.gif" style="transform: scale(1.25); margin-top: -33vh; animation: SHAKE 0.05ms linear infinite;">
            </div>
            `,
        reactions: {} // NO TALKING. ONLY VIOLENCE
    },
	
	env.COMBAT_ACTORS.order_spawner_bee = {
        name: "IDEA",
        specialClass: "daemonactor",
        maxhp: 5,
		hp: 2,
        actions: ["husk_attack_rot", "surge"],
        initialStatusEffects: [["ethereal", 1]],
        turnCheck: "genericEthereal",
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="idea"></div>
                <figure class="daemon bee"><div class="sides"><span></span><span></span><span></span><span></span><span></span><span></span></div></figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.order_pawn = {
        name: "WRK",
        specialClass: "daemonactor",
        maxhp: 10,
		hp: 5,
        actions: ["revise", "mad_claw", "evade"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="wrk"></div>
                <figure class="daemon pawn accurate-position"> 
                    <img src="/img/sprites/daemons/pawn/base.gif">
                    <div class="eye"></div>
                    <div class="scraps noimg">
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                    </div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.order_knight = {
        name: "CLW",
        specialClass: "daemonactor",
        maxhp: 15,
		hp: 8,
        actions: ["cripple", "exploit", "surge"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="clw"></div>
                <figure class="daemon rook accurate-position">
                    <img src="/img/sprites/daemons/rook/body.gif">
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="leftarm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                    <div class="rightarm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                </figure>
                
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.order_bishop = {
        name: "NET",
        specialClass: "daemonactor",
        maxhp: 12,
		hp: 6,
        actions: ["speak", "parasite", "empower", "rez_player"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="net"></div>
                <figure class="daemon bishop accurate-position">
                    <img src="/img/sprites/daemons/bishop/base.gif">
                    <div class="eye"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.order_rook = {
        name: "ENFC",
        specialClass: "daemonactor",
        maxhp: 20,
		hp: 10,
        actions: ["enforce", "focused_guard"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="enfc"></div>
                <figure class="daemon knight accurate-position">
                    <img src="/img/sprites/daemons/knight/body.gif">
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="uparm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.order_queen = {
        name: "SEER",
        specialClass: "daemonactor",
        maxhp: 22,
		hp: 11,
        actions: ["windup"],
        windupActions: ["special_rule", "wound_lastresort"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="seer"></div>
                <figure class="daemon queen accurate-position">
                    <img src="/img/sprites/daemons/queen/core.gif">
                    <div class="eye"></div>
                    <div class="ring"></div>
                    <div class="ring"></div>
                    <div class="ring"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.order_king = {
        name: "ARCHN",
        specialClass: "daemonactor",
        maxhp: 25,
		hp: 12,
        actions: ["windup"],
        windupActions: ["special_judgement"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="archn"></div>
                <figure class="daemon king accurate-position">
                    <img src="/img/sprites/daemons/king/angles.gif">
                    <img src="/img/sprites/daemons/king/angles.gif">
                    <div class="box center"></div>
                    <div class="box outer"></div>
                    <div class="ring"></div>
                    <div class="eye"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.order_pawn_mega = {
        name: "PRCS",
        specialClass: "daemonactor",
        maxhp: 20,
		hp: 10,
        actions: ["revise_all", "wild_claw", "evade_hyper"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="wrk"></div>
                <figure class="daemon pawn accurate-position"> 
                    <img src="/img/sprites/daemons/pawn/base.gif">
                    <div class="eye"></div>
                    <div class="scraps noimg">
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                    </div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.order_knight_mega = {
        name: "SPK",
        specialClass: "daemonactor",
        maxhp: 30,
		hp: 15,
        actions: ["distraction_cripple", "optimize", "plot", "special_enact"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="clw"></div>
                <figure class="daemon rook accurate-position">
                    <img src="/img/sprites/daemons/rook/body.gif">
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="leftarm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                    <div class="rightarm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                </figure>
                
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.order_bishop_mega = {
        name: "WEB",
        specialClass: "daemonactor",
        maxhp: 25,
		hp: 12,
        actions: ["speak_mega", "speak_focused", "parasite", "team_huddle", "tozik_attack_metal", "rez_player"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="net"></div>
                <figure class="daemon bishop accurate-position">
                    <img src="/img/sprites/daemons/bishop/base.gif">
                    <div class="eye"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.order_rook_mega = {
        name: "CNSTRNT",
        specialClass: "daemonactor",
        maxhp: 40,
		hp: 20,
        actions: ["enforce", "special_guard_all_focused", "windup"],
		windupActions: ["frenzy_chainsaw"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="enfc"></div>
                <figure class="daemon knight accurate-position">
                    <img src="/img/sprites/daemons/knight/body.gif">
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="uparm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.order_queen_mega = {
        name: "STHSYR",
        specialClass: "daemonactor",
        maxhp: 45,
		hp: 22,
        actions: ["windup"],
        windupActions: ["special_rule_mega", "wound"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="seer"></div>
                <figure class="daemon queen accurate-position">
                    <img src="/img/sprites/daemons/queen/core.gif">
                    <div class="eye"></div>
                    <div class="ring"></div>
                    <div class="ring"></div>
                    <div class="ring"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.order_king_mega = {
        name: "DMIRGE",
        specialClass: "daemonactor",
        maxhp: 50,
		hp: 25,
        actions: ["windup"],
        windupActions: ["special_judgement_mega"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="archn"></div>
                <figure class="daemon king accurate-position">
                    <img src="/img/sprites/daemons/king/angles.gif">
                    <img src="/img/sprites/daemons/king/angles.gif">
                    <div class="box center"></div>
                    <div class="box outer"></div>
                    <div class="ring"></div>
                    <div class="eye"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.cmb_cop_pawn = {
        name: "Civil Protection", // TODO::figure out better names for these guys to make them more distinct from one another
        maxhp: 8,
        hp: 8,
        actions: ["stun_baton"], // TODO::give these guys HL2 style MYNUMS/MYNAMES stuff; let them give themselves a callsign
		initialStatusEffects: [["ethereal", 1]],
		specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/cop_pawn_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_cop_knight = {
        name: "Civil Protection", // TODO::figure out better names for these guys to make them more distinct from one another
        maxhp: 8,
        hp: 8,
        actions: ["sidearm_weak", "special_semiauto"], // TODO::maybe make a version of interruptible that's like . aiming that gets removed when receiving a critical hit/stun
		initialStatusEffects: [["ethereal", 1]],
		specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/cop_knight_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_cop_bishop = {
        name: "Civil Protection", // TODO::figure out better names for these guys to make them more distinct from one another
        maxhp: 8,
        hp: 8,
        actions: ["special_fullauto_smg", "windup_aim"],
		aimingActions: ["aim_fullauto_smg"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/cop_bishop_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_cop_bishop_support = {
        name: "Civil Protection", // TODO::figure out better names for these guys to make them more distinct from one another
        maxhp: 8,
        hp: 8,
        actions: ["sidearm_weak", "sidearm_weak", "barrier_stimpatch", "limited_scanner_summon"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/cop_bishop_support_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_cityscanner = {
        name: "Scanner",
        maxhp: 6,
        hp: 6,
        actions: ["windup", "spy_analyze"],
		windupActions: ["speak_blind"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/cityscanner_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {}, // SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.cmb_cop_rook = {
        name: "Riot Officer",
        maxhp: 6,
        hp: 6,
        actions: ["special_fullauto_smg"],
		initialStatusEffects: [["ethereal", 1], ["shield_bearer", 1]], // will grant the user the guard and enemy_shell actions along with stat bonuses, removed by stun
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/cop_rook_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_cop_queen = {
        name: "Rank Leader",
        maxhp: 8,
        hp: 8,
        actions: ["special_fullauto_smg", "special_fullauto_smg", "limited_manhack_summon", "special_spy_all_flare"],
		initialStatusEffects: [["ethereal", 1]], 
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/cop_queen_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_manhack = {
        name: "Viscerator",
        maxhp: 5,
        hp: 5,
        actions: ["wound_stab_weak"],
		initialStatusEffects: [["ethereal", 1], ["heart_adaptive", 1]], // reskin this as like, "lightweight" or something
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/manhack_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {}, // SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.cmb_cop_king = {
        name: "Emplacement Gunner",
        maxhp: 8,
        hp: 8,
        actions: ["windup_aim"],
		aimingActions: ["aim_fullauto"],
		initialStatusEffects: [["ethereal", 1]], 
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/cop_king_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_cop_king_target = {
        name: "Civil Marksman",
        maxhp: 8,
        hp: 8,
        actions: ["unfocused_shot_357", "windup_aim"],
		aimingActions: ["focused_shot_357"],
		initialStatusEffects: [["ethereal", 1]], 
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/cop_king_target_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_soldier_pawn = {
        name: "Soldier",
        maxhp: 10,
        hp: 10,
        actions: ["special_fullauto_smg", "special_fullauto_smg", "special_grenade", "windup_aim"], // make the grenade an annihilation menu thing
		aimingActions: ["aim_fullauto_smg"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/soldier_pawn_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_soldier_knight = {
        name: "Soldier",
        maxhp: 10,
        hp: 10,
        actions: ["special_fullauto_ar2", "special_fullauto_ar2", "special_grenade", "windup_aim"],
		aimingActions: ["aim_fullauto_ar2"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/soldier_knight_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_soldier_bishop = {
        name: "Shotgunner",
        maxhp: 10,
        hp: 10,
        actions: ["fullauto_shotgun_cmb", "special_grenade", "surge", "windup_aim"],
		aimingActions: ["aim_fullauto_shotgun"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/soldier_bishop_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_soldier_bishop_support = {
        name: "Recon Soldier",
        maxhp: 10,
        hp: 10,
        actions: ["special_fullauto_smg", "limited_shieldscanner_summon", "windup_aim"],
		aimingActions: ["aim_fullauto_smg"],
		initialStatusEffects: [["ethereal", 1]], /* i feel like this one can use soldier_pawn as its graphic again... */
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/soldier_pawn_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_shieldscanner = {
        name: "Shield Scanner",
        maxhp: 6,
        hp: 6,
        actions: ["windup", "spy_analyze"],
		windupActions: ["speak_blind", "deploy_mine"], // this is gonna need its own status effect (when evading an offensive strike, launch mine at attacker?)
		initialStatusEffects: [["ethereal", 1]], 
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/shieldscanner_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {}, // SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.cmb_soldier_rook = {
        name: "Elite",
        maxhp: 15,
        hp: 15,
        actions: ["special_fullauto_ar2", "special_fullauto_ar2", "special_fullauto_ar2", "special_grenade", "windup_aim", "windup"],
		aimingActions: ["aim_fullauto_ar2"],
		windupActions: ["ar2_orb"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/soldier_rook_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_soldier_rook_prospekt = {
        name: "Prospekt Soldier",
        maxhp: 10,
        hp: 10,
        actions: ["special_fullauto_smg", "special_fullauto_smg", "special_fullauto_smg", "special_grenade", "windup_aim"],
		aimingActions: ["aim_fullauto_smg", "smg_grenade"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/soldier_rook_prospekt_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_soldier_queen = {
        name: "Prospekt Engineer",
        maxhp: 10,
        hp: 10,
        actions: ["special_fullauto_ar2", "special_fullauto_ar2", "limited_sentry_summon", "special_grenade", "windup_aim", "windup"],
		aimingActions: ["aim_fullauto_ar2"],
		windupActions: ["ar2_orb"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/soldier_queen_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_soldier_queen_shotgun = {
        name: "Prospekt Shotgunner",
        maxhp: 10,
        hp: 10,	
        actions: ["fullauto_shotgun_cmb", "fullauto_shotgun_cmb", "limited_sentry_summon", "special_grenade", "windup_aim"],
		aimingActions: ["aim_fullauto_shotgun"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/soldier_queen_shotgun_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_sentry = {
        name: "Sentry",
        maxhp: 20,
        hp: 20,
        actions: ["special_fullauto_sentry"], // we're definitely gonna need multiple passive carapaces (-50% incoming damage/healing, -1HP incoming base damage)
		initialStatusEffects: [["ethereal", 1], ["weak_point", 1], ["passive_carapace_sentry", 1]], // to simulate tipping over turrets and the fact that only explosions hurt them
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/sentry_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {}, // SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.cmb_soldier_king = {
        name: "Hunter",
        maxhp: 40,
        hp: 40,
        actions: ["windup", "windup_aim"],
		aimingActions: ["aim_fullauto_hunter"],
		windupActions: ["hunter_smash"],
		initialStatusEffects: [["ethereal", 1], ["passive_carapace_hunter", 1]], // -40% incoming damage/healing
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/soldier_king_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_soldier_king_support = {
        name: "Sniper",
        maxhp: 25,
        hp: 25, // i know I KNOW I KNOW
        actions: ["windup_aim"], /* I KNOW THERE IS RED LEAKING THROUGH THE GRASS */
		aimingActions: ["focused_shot_cmb", "hold_aim_cmb"], /* NO MORE NO MORE NO MORE */
		initialStatusEffects: [["ethereal", 1]], /* WHY CAN THE COMMENTS COME THROUGH THE GRAPHIC PROPERTY */
        specialClass: "notadaemonactor", /* FUCK !!!!!!!!!!!!!!!!!!!!! */
        graphic: ` 
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper"> 
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/soldier_king_support_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_special_pawn = {
        name: "Engineer",
        maxhp: 12,
        hp: 12,
        actions: ["special_fullauto_smg", "special_fullauto_smg", "limited_defensestation_summon", "windup_aim"],
		aimingActions: ["aim_fullauto_smg", "smg_grenade"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/special_pawn_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_special_pawn_shotgun = {
        name: "Engineer",
        maxhp: 12,
        hp: 12,
        actions: ["fullauto_shotgun_cmb", "fullauto_shotgun_cmb", "limited_defensestation_summon", "special_grenade", "windup_aim"],
		aimingActions: ["aim_fullauto_shotgun"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/special_pawn_shotgun_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_defensestation = {
        name: "Defense Station",
        maxhp: 20,
        hp: 20,
        actions: ["special_fullauto_sentry", "special_restorative_barrier"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/defensestation_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {}, // SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.cmb_special_knight = {
        name: "Grenadier",
        maxhp: 15,
        hp: 15,
        actions: ["smg_grenade", "windup_aim"],
		aimingActions: ["focused_shot_missile_cmb"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/special_knight_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_special_bishop = {
        name: "Medic",
        maxhp: 12,
        hp: 12,
        actions: ["special_fullauto_smg", "special_fullauto_smg", "optimize", "special_restorative_barrier", "special_grenade_poison", "windup_aim"],
		aimingActions: ["aim_fullauto_smg", "smg_grenade"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/special_bishop_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_special_bishop_shotgun = {
        name: "Medic",
        maxhp: 12,
        hp: 12,
        actions: ["fullauto_shotgun_cmb", "fullauto_shotgun_cmb", "optimize", "special_restorative_barrier", "special_grenade_poison", "windup_aim"],
		aimingActions: ["aim_fullauto_shotgun"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/special_bishop_shotgun_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_special_bishop_support = {
        name: "Support",
        maxhp: 16,
        hp: 16,
        actions: ["special_fullauto_smg", "special_fullauto_smg", "empower", "special_hardening_barrier", "special_grenade", "windup_aim"],
		aimingActions: ["aim_fullauto_smg", "smg_grenade"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/special_bishop_support_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_special_bishop_support_shotgun = {
        name: "Support",
        maxhp: 16,
        hp: 16,
        actions: ["fullauto_shotgun_cmb", "fullauto_shotgun_cmb", "empower", "special_hardening_barrier", "special_grenade", "windup_aim"],
		aimingActions: ["aim_fullauto_shotgun"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/special_bishop_support_shotgun_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_special_rook = {
        name: "Synth",
        maxhp: 15,
        hp: 15,
        actions: ["special_fullauto_flechette", "special_fullauto_flechette", "special_grenade_teleport", "windup_aim"],
		aimingActions: ["aim_fullauto_flechette"],
		initialStatusEffects: [["ethereal", 1], ["passive_carapace_synth", 1]], // -20% incoming damage/healing, cannot receive critical hits
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/special_rook_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {}, // SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.cmb_special_rook_elite = {
        name: "Synth Elite",
        maxhp: 22,
        hp: 22,
        actions: ["special_fullauto_flechette_strong", "special_fullauto_flechette_strong", "special_grenade_teleport", "windup_aim"],
		aimingActions: ["aim_fullauto_flechette_strong"],
		initialStatusEffects: [["ethereal", 1], ["passive_carapace_synthelite", 1]], // -40% incoming damage/healing, cannot receive critical hits
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/special_rook_elite_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {}, // SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.cmb_special_queen = {
        name: "Commander",
        maxhp: 20,
        hp: 20,
        actions: ["special_fullauto_ar2", "special_fullauto_ar2", "coordination", "limited_combatdrone_summon", "windup_aim"],
		aimingActions: ["aim_fullauto_ar2", "ar2_orb"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/special_queen_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_special_queen_smg = {
        name: "Commander",
        maxhp: 20,
        hp: 20,
        actions: ["special_fullauto_smg", "special_fullauto_smg", "coordination", "limited_combatdrone_summon", "windup_aim"],
		aimingActions: ["aim_fullauto_smg", "smg_grenade"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/special_queen_smg_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_combatdrone = {
        name: "Battle Drone", // god this thing is a fucking nightmare
        maxhp: 40,
        hp: 40,
        actions: ["windup_aim", "windup", "windup"], // discharge can probably be a mad claw reskin
		windupActions: ["speak_blind", "special_fullauto_drone"],
		aimingActions: ["aim_fullauto_drone"],
		initialStatusEffects: [["ethereal", 1], ["cmb_attackdrone", 1]], // on turn, attack all vulnerable foes for -3HP (but it can't crit!)
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/combatdrone_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {}, // SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.cmb_special_queen_assassin = {
        name: "Assassin", 
        maxhp: 24,
        hp: 24,
        actions: ["primary", "special_semiauto_mega", "special_semiauto_mega", "special_grenade_fear", "evade_hyper"],
		initialStatusEffects: [["ethereal", 1], ["heart_adaptive", 1], ["retaliation", 1]], // this one can be normal evasive maneuvers
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/special_queen_assassin_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_special_king = {
        name: "Sterilizer",
        maxhp: 30,
        hp: 30,
        actions: ["special_fullauto_incendiary", "special_grenade_incendiary", "windup_aim"], // special is the weird flame pellet gun
		aimingActions: ["aim_fullauto_incendiary"], // aim is the flamethrower
		initialStatusEffects: [["ethereal", 1], ["metal_explode", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/special_king_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_special_king_veteran = {
        name: "Veteran",
        maxhp: 20,
        hp: 20,
        actions: ["special_fullauto_smg", "special_fullauto_smg", "special_fullauto_smg", "special_grenade", "windup_aim"],
		aimingActions: ["aim_fullauto_smg", "smg_grenade"],
		initialStatusEffects: [["ethereal", 1], ["passive_carapace_veteran", 1]], // -100% incoming damage/healing, -1 incoming base damage +10% incoming damage/healing per received critical hit (passive removed once it reaches 0%)
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/special_king_veteran_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_special_king_veteran_ar2 = {
        name: "Veteran",
        maxhp: 20,
        hp: 20,
        actions: ["special_fullauto_ar2", "special_fullauto_ar2", "special_grenade", "windup_aim"],
		aimingActions: ["aim_fullauto_ar2", "ar2_orb"],
		initialStatusEffects: [["ethereal", 1], ["passive_carapace_veteran", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/special_king_veteran_ar2_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_special_king_veteran_shotgun = {
        name: "Veteran",
        maxhp: 20,
        hp: 20,
        actions: ["fullauto_shotgun_cmb", "fullauto_shotgun_cmb", "special_grenade", "windup_aim"],
		aimingActions: ["aim_fullauto_shotgun"],
		initialStatusEffects: [["ethereal", 1], ["passive_carapace_veteran", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/special_king_veteran_shotgun_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_special_king_juggernaut = {
        name: "Juggernaut",
        maxhp: 60,
        hp: 60,
        actions: ["windup_aim"],
		aimingActions: ["aim_fullauto_minigun"],
		initialStatusEffects: [["ethereal", 1], ["passive_carapace_juggernaut", 1]], // -50% incoming damage/healing
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/special_king_juggernaut_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_hunterchopper = { // i think we're gonna mix in actors from other stages for the last part so we're not gonna sort these guys into ranks
        name: "Winder",
        maxhp: 120,
        hp: 120,
        actions: ["windup"],
		windupActions: ["special_fullauto_chopper", "lastresort_bombingrun"],
		initialStatusEffects: [["ethereal", 1], ["passive_carapace_juggernaut", 1]], // they're immune to anything except explosives* but 120 is too much health for that
        specialClass: "notadaemonactor", // note::i actually have no idea exactly how much health hunter choppers are supposed to have? the combine overwiki says it has 5600(!!!) HP, but in gmod it usually only has 600 HP which is what i decided to go with here
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/hunterchopper_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {}, // SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.cmb_gunship = {
        name: "Skyshield",
        maxhp: 20,
        hp: 20,
        actions: ["windup_aim", "windup_aim", "windup"],
		windupActions: ["warp_cannon_gunship"],
		aimingActions: ["aim_fullauto_gunship"],
		initialStatusEffects: [["ethereal", 1], ["passive_carapace_sentry", 1], ["weak_point", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/gunship_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {}, // SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.cmb_strider = {
        name: "Cauterizer",
        maxhp: 70,
        hp: 70,
        actions: ["aim_fullauto_strider", "aim_fullauto_strider", "aim_fullauto_strider", "windup"],
		windupActions: ["warp_cannon_strider", "aim_fullauto_strider_mega"],
		initialStatusEffects: [["ethereal", 1], ["passive_carapace_sentry", 1], ["weak_point", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/strider_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {}, // SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.cmb_canister = {
        name: "Canister",
        maxhp: 100,
        hp: 100,
        actions: ["special_headcrab_summon"],
		initialStatusEffects: [["ethereal", 1], ["limited_actor", 3]], // this actor will be removed from combat on status expiry
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/canister_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {}, // SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.cmb_headcrab = {
        name: "Headcrab",
        maxhp: 2,
        hp: 2,
        actions: ["headcrab_parasitize"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/headcrab_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_headcrab_fast = {
        name: "Fast Headcrab",
        maxhp: 2,
        hp: 2,
        actions: ["headcrab_parasitize_fast", "headcrab_parasitize_fast", "headcrab_parasitize_fast", "skitter"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/headcrab_fast_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_headcrab_poison = {
        name: "Poison Headcrab",
        maxhp: 6,
        hp: 6,
		actions: ["windup"],
        windupActions: ["headcrab_parasitize_poison"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/headcrab_poison_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_zombie = {
        name: "Zombie",
        maxhp: 10,
        hp: 10,
        actions: ["husk_attack", "swipe", "speak"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/zombie_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_zombie_fast = {
        name: "Fast Zombie",
        maxhp: 10,
        hp: 10,
        actions: ["frenzy", "speak", "surge"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/zombie_fast_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_zombie_poison = {
        name: "Poison Zombie",
        maxhp: 35,
        hp: 35,
        actions: ["windup", "swipe"],
		windupActions: ["special_poisonheadcrab_summon"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/zombie_poison_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_zombine = {
        name: "Zombine",
        maxhp: 20,
        hp: 20,
        actions: ["husk_attack", "swipe", "speak", "surge", "special_grenade_kamikaze"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/zombine_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_zombine_elite = {
        name: "Zombine Elite",
        maxhp: 28,
        hp: 28,
        actions: ["husk_attack", "swipe", "speak", "surge", "special_grenade_kamikaze"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/zombine_elite_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_zombine_poison = {
        name: "Poison Zombine",
        maxhp: 45,
        hp: 45,
        actions: ["windup", "swipe", "surge"],
		windupActions: ["special_poisonheadcrab_summon"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/zombine_poison_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_zombine_poison_elite = {
        name: "Poison Zombine Elite",
        maxhp: 55,
        hp: 55,
        actions: ["windup", "swipe", "surge"],
		windupActions: ["special_poisonheadcrab_summon"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/zombine_poison_elite_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_thumper = {
        name: "Restrictor",
        maxhp: 100,
        hp: 100,
        actions: ["special_antlion_summon"],
		initialStatusEffects: [["ethereal", 1], ["limited_actor", 6]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/thumper_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {}, // SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.cmb_antlion = {
        name: "Antlion",
        maxhp: 6,
        hp: 6,
        actions: ["swipe", "evade"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/antlion_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_antlion_worker = {
        name: "Worker",
        maxhp: 12,
        hp: 12,
        actions: ["swipe", "worker_attack", "evade"],
		initialStatusEffects: [["ethereal", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/antlion_worker_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_antlion_guard = {
        name: "Guard",
        maxhp: 100,
        hp: 100,
        actions: ["windup"],
		windupActions: ["antlion_smash"],
		initialStatusEffects: [["ethereal", 1], ["passive_carapace_antlion", 1]], // -75% incoming damage/healing
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/antlion_guard_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	env.COMBAT_ACTORS.cmb_antlion_guard_cave = {
        name: "Cavern Guardian",
        maxhp: 100,
        hp: 100,
        actions: ["windup"],
		windupActions: ["antlion_smash_toxin"],
		initialStatusEffects: [["ethereal", 1], ["passive_carapace_antlion", 1]],
        specialClass: "notadaemonactor",
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="https://narrativohazard-expunged.neocities.org/img/cmb/antlion_guard_cave_dither.png" style="animation: bomber 20s ease-in-out infinite alternate;">
            </div>
            `,
        reactions: {
            catchall: ["1UiÃ«2Wâ€¡", "â€¡eÃŽKÃŸJÃ¤Ã¤", "/â€¦Â¿?Ã· Ã´LÃ£Ã˜", "CÂ©Ã‹", "0Eâ„¢NÃ³Â¨Ã½QÃ’", "â‚¬LWÃ©{Ã°Ã", "Ã‡Ã¦Ã½Ã™â€¡ÃŸâ€ C", "Â£~UÃ¾fÃ¢", "â€¦TÃº**"],
            dead: ["Â¿", "???"]
        },
    },
	
	// TODO::make combine APC and advisor actors because we may have Forgor
	
	env.COMBAT_ACTORS.interviewer = { // nothing to see here
        name: "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ",
        maxhp: 500000,
        specialClass: "intrusiveactor mainfoe",
        //statusImmunities: ["stun"],
        actions: ["mad_claw_mega", "mad_claw_mega", "husk_attack_light", "husk_attack_light", "special_invite_storm", "special_inversion", "surge"],
		initialStatusEffects: [["autoplay_incoherent", 1]], // this is going to be interesting
        graphic: `
            <div class="sprite-wrapper interviewer" id="%SLUG-sprite-wrapper">
                <img src="/img/local/ocean/ship/help.gif">
            </div>
            `,
        reactions: {}, //SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.cmb_mainfoe = {
        name: "CITADEL",
        maxhp: 500000,
        specialClass: "notadaemonactor combineactor mainfoe",
        statusImmunities: ["stun"],
        actions: ["special_incoherent_combinesummon"],
		initialStatusEffects: [["appeasement_mega", 1], ["ominous_timer_cmb", 1]], // either six or ten minute timer; combat will be lost once timer expires (oh god we absolutely cannot make it ten minutes that is Not Enough Time)
        graphic: `
            <div class="sprite-wrapper cmb" id="%SLUG-sprite-wrapper">
				<div class="timer"></div>
                <img src="/img/local/orbit/dullportal_backed_small.gif">
            </div>
            `,
        reactions: {}, //SILENT CREATURE
		events: {
            onSpawn: (actor) => {
                if(!check("cmb_unlocked")) {
                    switch(check("e3a2escape")) {
                        case "complete":
                            change("cmb_unlocked", "post-escape")
                        break

                        default:
                            change("cmb_unlocked", "pre-escape")
                    }
                }
            }
        },
    },
	
	env.COMBAT_ACTORS.bstrdboss_shotgun = { // heho funny firing squad bosses
        name: "Shotgun Golem", // note to self::unlock this boss revision with a claws impulse named "CALL TO ARMS" or something
        maxhp: 100000,
        specialClass: "intrusiveactor mainfoe",
        statusImmunities: ["stun"],
        actions: ["fullauto_shotgun_mega"], // like boomstick but it hits the target 20 times - this golem has a super shotgun >:)
		initialStatusEffects: [["rewardsHandler", 1]],
        graphic: `
            <div class="sprite-wrapper archival-golem bstrd-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/bstbody_mimic.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/bsthead_mimic.gif" id="%SLUG-golemsprite-head">
                        <img src="/img/sprites/combat/foes/bstface_mimic.gif" id="%SLUG-golemsprite-face">
                    </div>
                    <img src="/img/sprites/combat/foes/bstbody_mimic.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="https://narrativohazard-expunged.neocities.org/img/firing_squad/bstgun_ssg.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms gunlower">
                    <img src="https://narrativohazard-expunged.neocities.org/img/firing_squad/bstgunraise_ssg.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms gunraise">
                    <img src="https://narrativohazard-expunged.neocities.org/img/firing_squad/bstgunblam_ssg.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms gunblam">
                </div>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.bstrdboss_rifle = {
        name: "Rifle Golem",
        maxhp: 100000,
        specialClass: "intrusiveactor mainfoe",
        statusImmunities: ["stun"],
        actions: ["special_fullauto_heavy"], // like full auto, but deals 2 base damage and inflicts +1T:HYPERVULNERABLE on crit - this golem has a battle rifle
        initialStatusEffects: [["rewardsHandler", 1]],
		graphic: `
            <div class="sprite-wrapper archival-golem bstrd-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/bstbody_mimic.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/bsthead_mimic.gif" id="%SLUG-golemsprite-head">
                        <img src="/img/sprites/combat/foes/bstface_mimic.gif" id="%SLUG-golemsprite-face">
                    </div>
                    <img src="/img/sprites/combat/foes/bstbody_mimic.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="https://narrativohazard-expunged.neocities.org/img/firing_squad/bstgun_fal.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms gunlower">
                    <img src="https://narrativohazard-expunged.neocities.org/img/firing_squad/bstgunraise_fal.gif" class="sprite golemsprite-arms gunraise">
                    <img src="https://narrativohazard-expunged.neocities.org/img/firing_squad/bstgunblam_fal.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms gunblam">
                </div>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.bstrdboss_grenade = {
        name: "Grenade Golem",
        maxhp: 100000,
        specialClass: "intrusiveactor mainfoe",
        statusImmunities: ["stun"],
        actions: ["special_fullauto_grenade"], // like full auto, but crits explode instead of inflicting +1T:VULNERABLE - this golem has an M32 grenade launcher
		initialStatusEffects: [["rewardsHandler", 1]],
        graphic: `
            <div class="sprite-wrapper archival-golem bstrd-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/bstbody_mimic.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/bsthead_mimic.gif" id="%SLUG-golemsprite-head">
                        <img src="/img/sprites/combat/foes/bstface_mimic.gif" id="%SLUG-golemsprite-face">
                    </div>
                    <img src="/img/sprites/combat/foes/bstbody_mimic.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="https://narrativohazard-expunged.neocities.org/img/firing_squad/bstgun_m32.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms gunlower">
                    <img src="https://narrativohazard-expunged.neocities.org/img/firing_squad/bstgunraise_m32.gif" class="sprite golemsprite-arms gunraise">
                    <img src="https://narrativohazard-expunged.neocities.org/img/firing_squad/bstgunblam_m32.gif" class="sprite golemsprite-arms gunblam">
                </div>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.bstrdboss_sniper = {
        name: "AMR Golem",
        maxhp: 100000,
        specialClass: "intrusiveactor mainfoe",
        statusImmunities: ["stun"],
        actions: ["daze_lastresort_mega", "windup_amr"], // literally just evil geli - but it has an anti-materiel rifle instead this time !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        windupActions: ["focused_shot_amr", "hold_aim_amr"],
        initialStatusEffects: [["visionary_amr", 1], ["rewardsHandler", 1]],
        graphic: `
            <div class="sprite-wrapper archival-golem bstrd-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/bstbody_mimic.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/bsthead_mimic.gif" id="%SLUG-golemsprite-head">
                        <img src="/img/sprites/combat/foes/bstface_mimic.gif" id="%SLUG-golemsprite-face">
                    </div>
                    <img src="/img/sprites/combat/foes/bstbody_mimic.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="https://narrativohazard-expunged.neocities.org/img/firing_squad/bstgun_m82.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms gunlower">
                    <img src="https://narrativohazard-expunged.neocities.org/img/firing_squad/bstgunraise_m82.gif" class="sprite golemsprite-arms gunraise">
                    <img src="https://narrativohazard-expunged.neocities.org/img/firing_squad/bstgunblam_m82.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms gunblam">
                </div>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.bstrdboss_bfg = {
        name: "BFG Golem",
        maxhp: 100000,
        specialClass: "intrusiveactor mainfoe",
        statusImmunities: ["stun"],
        actions: ["windup_bfg"],
        windupActions: ["bfg_shot"], // basically just trying to represent original doom's BFG as closely as we can (4 base damage, +1T:STUN on crit, hit all foes for -2HP with 70% accuracy on use)
        initialStatusEffects: [["rewardsHandler", 1]],
		graphic: `
            <div class="sprite-wrapper archival-golem bstrd-golem golemsprite" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img src="/img/sprites/combat/foes/bstbody_mimic.gif" id="%SLUG-golemsprite-base" class="sprite golemsprite-base">
                    
                    <div class="sprite golemsprite-head">
                        <img src="/img/sprites/combat/foes/bsthead_mimic.gif" id="%SLUG-golemsprite-head">
                        <img src="/img/sprites/combat/foes/bstface_mimic.gif" id="%SLUG-golemsprite-face">
                    </div>
                    <img src="/img/sprites/combat/foes/bstbody_mimic.gif" id="%SLUG-golemsprite-body" class="sprite golemsprite-body">
                    <img src="https://narrativohazard-expunged.neocities.org/img/firing_squad/bstgun_bfg9k.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms gunlower">
                    <img src="https://narrativohazard-expunged.neocities.org/img/firing_squad/bstgunraise_bfg9k.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms gunraise">
                    <img src="https://narrativohazard-expunged.neocities.org/img/firing_squad/bstgunblam_bfg9k.gif" id="%SLUG-golemsprite-arms" class="sprite golemsprite-arms gunblam">
                </div>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.intrusive_rematch = {
        name: "???",
        maxhp: 1000000,
        specialClass: "intrusiveactor mainfoe",
        statusImmunities: ["stun"],
        actions: [ // intrude but it doesn't tell you what the options are :D
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
			"special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch", "special_intrusive_rematch",
		], // spammed so that when you unfold its actions it flows off the screen
        graphic: `
            <div class="sprite-wrapper intrusive maintrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/1.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: [ "D ML" ],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        },
       
        events: {
            onSpawn: (actor) => {
                env.rpg.classList.add('hideteams', 'intrusivetro')
                setTimeout(()=>{
                    env.rpg.classList.remove("intrusivetro")
                    env.bgm.seek(3)
                }, 500)
                setTimeout(()=>{
                    env.rpg.classList.remove("hideteams")
                }, 15000)

                env.rpg.insertAdjacentHTML('beforeend', `
                <figure id="chancepanel" class="hidden" for="${actor.slug}">
                    <img src="/img/sprites/flantrusive/panelbase.gif">
                    <div class="wheel">
                        <ul>
                            <li class="d1">1</li>
                            <li class="d2">2</li>
                            <li class="d3">3</li>
                            <li class="d4">4</li>
                            <li class="d5">5</li>
                            <li class="d6">6</li>
                        </ul>
                    </div>
                    <div class="display">
                        <ol>
                            <li class="d1">1. ??????</li>
                            <li class="d2">2. ??????</li>
                            <li class="d3">3. ??????</li>
                            <li class="d4">4. ??????</li>
                            <li class="d5">5. ??????</li>
                            <li class="d6">6. ??????</li>
                        </ol>
                    </div>
                    <div class="result">
                        <div>
                            <span></span>
                        </div>
                    </div>
                </figure>`)

                actor.chancePanel = env.rpg.querySelector(`#chancepanel[for="${actor.slug}"]`)
                actor.chancePanel.result = actor.chancePanel.querySelector(".result span")
                actor.chancePanel.spin = (state) => { 
                    actor.chancePanel.removeAttribute("chosen")
                    actor.chancePanel.classList.toggle("spinning", state) 
                    actor.chancePanel.result.innerHTML = "???"
                }

                actor.chancePanel.stopAndResult = () => { 
                    let result = rand(1, 7)
                    actor.chancePanel.spin(false)
                    actor.chancePanel.setAttribute("chosen", result)

                    return result
                }

                if(!check("flan")) {
                    switch(check("e3a2escape")) {
                        case "complete":
                            change("flan", "post-escape")
                        break

                        default:
                            change("flan", "pre-escape")
                    }
                }
            }
        },
    },
	
	env.COMBAT_ACTORS.intrusive_blockershelf = {
        name: "???",
		hp: 600,
        maxhp: 700,
        specialClass: "intrusiveactor",
        actions: ["special_trusiveshelf_annihilation"], // gives the player a choice between getting UNNATURAL STRIKE'd or giving everyone redirection
        initialStatusEffects: [["weak_point", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/2.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: ["D ML"],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        },
    },
	
	env.COMBAT_ACTORS.intrusive_bstrd = {
        name: "???",
        maxhp: 800,
        hp: 800,
        specialClass: "intrusiveactor",
        actions: ["windup"],
        windupActions: ["special_fullauto_intrusive"], // full auto but it gives +1T:VULNERABLE +1T:OPEN WOUND and +CRITICAL FLAW on crit
		initialStatusEffects: [["light_veilkdrop", 1]], // hehe >:)
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/3.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: ["D ML"],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        },
    },
	
	env.COMBAT_ACTORS.intrusive_maintcloak = {
        name: "???",
		hp: 200,
        maxhp: 300,
        specialClass: "intrusiveactor",
        actions: ["enforce", "coordination", "special_unnatural_barrier"], // unnatural barrier gives unnatural repairs (+100% outgoing damage/healing, +1%hp/turn, remove puncture and rot while bp is > 0)
        initialStatusEffects: [["impatient", 1], ["visionary", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/4.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: ["D ML"],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        },
    },
	
	env.COMBAT_ACTORS.intrusive_statusfreak = {
        name: "???",
        maxhp: 400,
        specialClass: "intrusiveactor",
        actions: ["miltza_attack", "special_mass_denature", "special_prophesize"],
        initialStatusEffects: [["retaliation", 1], ["dull_pragmatist", 1], ["flesh_menace", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <img src="/img/sprites/flantrusive/5.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: ["D ML"],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        },
    },
	
	env.COMBAT_ACTORS.intrusive_bomblet_kavruka = {
        name: "???",
        maxhp: 100,
        specialClass: "intrusiveactor",
        actions: ["nothing"],
        initialStatusEffects: [["ominous_timer_kavruka", 1]], // 45 second timer, does (relatively) minimal damage, but stuns your whole team
        statusImmunities: ["stun"], // first of three
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <div class="timer"></div>
                <img src="/img/sprites/flantrusive/6.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: ["D ML"],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        },
    },
	
	env.COMBAT_ACTORS.intrusive_bomblet_armored = {
        name: "???",
        maxhp: 100,
        specialClass: "intrusiveactor",
        actions: ["nothing"],
        initialStatusEffects: [["ominous_timer", 1], ["passive_carapace_intrusive", 1]], // 90 second timer, standard damage, HOWEVER, it has unnatural carapace >:)
        statusImmunities: ["stun"], // second of three
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <div class="timer"></div>
                <img src="/img/sprites/flantrusive/6.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: ["D ML"],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        },
    },
	
	env.COMBAT_ACTORS.intrusive_bomblet_mystery = {
        name: "???",
        maxhp: 1000,
        specialClass: "intrusiveactor",
        actions: ["nothing"],
        initialStatusEffects: [["ominous_timer_mystery", 1]], // four minute timer, kills everyone when it goes off, HOWEVER, the timer only shows question marks
        statusImmunities: ["stun"], // last of three
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <div class="timer"></div>
                <img src="/img/sprites/flantrusive/6.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: ["D ML"],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        },
    },
		// actually i have a funnier idea
	env.COMBAT_ACTORS.intrusive_factory = { // oh, these summons aren't home made
        name: "???", // they're made in a factory
        maxhp: 800, // a bomb factory
        specialClass: "intrusiveactor", // they're bombs
		actions: ["windup"],
        windupActions: ["special_bomblet_summon"], // summons 1 intrusive_bomblet (limit is the number of living factories times six)
		initialStatusEffects: [["weak_point", 1]],
        graphic: `
            <div class="sprite-wrapper intrusive" id="%SLUG-sprite-wrapper">
                <div class="timer"></div>
                <img src="/img/sprites/flantrusive/6.gif">
            </div>
            `,
        reactions: {
            evade: ["LD C"],
            crit: ["D ML"],
            crit_buff: ["BL"],
            miss: ["CL"],
            dead: ["P N"],
            receive_hit: ["IL D"],
            receive_crit: ["I LB P"],
            receive_puncture: ["I A D"],
            receive_buff: ["P BD"],
            receive_destabilized: ["S", "T", "Q"],
            receive_rez: ["U P"],
            puncture: ["DL"],
            regen: ["DC"],
            destabilized: ["S", "T", "Q"],
            stun: ["NDN"],
            receive_carapace: ["E"],
            receive_fear: ["I P"],
            receive_redirection: ["PDP"],
        },
    },
	
	env.COMBAT_ACTORS.spine_fodder = {
        name: "BELIEF",
        specialClass: "angelactor", // uses custom target box with blue chains
        maxhp: 10,
		hp: 5,
        actions: ["tozik_attack", "surge"],
        initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="idea"></div>
                <figure class="daemon bee"><div class="sides"><span></span><span></span><span></span><span></span><span></span><span></span></div></figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
    },
	
	env.COMBAT_ACTORS.angel_pawn = {
        name: "ANSWR",
        specialClass: "angelactor",
        maxhp: 20,
		hp: 10,
        actions: ["parasite", "tozik_attack", "sacrifice", "sacrifice_restore"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="wrk"></div>
                <figure class="daemon pawn accurate-position"> 
                    <img src="/img/sprites/daemons/pawn/base.gif">
                    <div class="eye"></div>
                    <div class="scraps noimg">
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                    </div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.angel_knight = {
        name: "DREDGE",
        specialClass: "angelactor",
        maxhp: 30,
		hp: 15,
        actions: ["windup", "miltza_attack", "surge"],
		windupActions: ["archival_smash"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="clw"></div>
                <figure class="daemon rook accurate-position">
                    <img src="/img/sprites/daemons/rook/body.gif">
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="leftarm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                    <div class="rightarm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                </figure>
                
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.angel_bishop = {
        name: "ROOT",
        specialClass: "angelactor",
        maxhp: 25,
		hp: 12,
        actions: ["parasite", "empowering_strike", "special_restorative_barrier", "rez_player"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="net"></div>
                <figure class="daemon bishop accurate-position">
                    <img src="/img/sprites/daemons/bishop/base.gif">
                    <div class="eye"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.angel_rook = {
        name: "KEEPR",
        specialClass: "angelactor",
        maxhp: 40,
		hp: 20,
        actions: ["enforce_support", "blink_guard"], // enforce_support grants all allies +1T:REGEN and +1T:CARAPACE on crit on top of the frenzying
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="enfc"></div>
                <figure class="daemon knight accurate-position">
                    <img src="/img/sprites/daemons/knight/body.gif">
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="uparm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.angel_queen = {
        name: "GATE",
        specialClass: "angelactor",
        maxhp: 45,
		hp: 22,
        actions: ["windup"],
        windupActions: ["special_rule_angel", "reconstruct"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="seer"></div>
                <figure class="daemon queen accurate-position">
                    <img src="/img/sprites/daemons/queen/core.gif">
                    <div class="eye"></div>
                    <div class="ring"></div>
                    <div class="ring"></div>
                    <div class="ring"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.angel_king = {
        name: "JUDGE",
        specialClass: "angelactor",
        maxhp: 50,
		hp: 25,
        actions: ["windup"],
        windupActions: ["special_judgement_angel"],
		initialStatusEffects: [["ethereal", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="archn"></div>
                <figure class="daemon king accurate-position">
                    <img src="/img/sprites/daemons/king/angles.gif">
                    <img src="/img/sprites/daemons/king/angles.gif">
                    <div class="box center"></div>
                    <div class="box outer"></div>
                    <div class="ring"></div>
                    <div class="eye"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.angelGreater_pawn = {
        name: "RETORT",
        specialClass: "angelactor",
        maxhp: 40,
		hp: 20,
        actions: ["windup", "sacrifice", "sacrifice_restore"],
		windupActions: ["special_parasite_all", "special_corruskivi_all"],
		initialStatusEffects: [["ethereal", 1], ["bone_ablative", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="wrk"></div>
                <figure class="daemon pawn accurate-position"> 
                    <img src="/img/sprites/daemons/pawn/base.gif">
                    <div class="eye"></div>
                    <div class="scraps noimg">
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                        <div class="scrap"></div>
                    </div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.angelGreater_knight = {
        name: "HUNTR",
        specialClass: "angelactor",
        maxhp: 60,
		hp: 30,
        actions: ["windup", "ik_attack", "dullflare", "surge"],
		windupActions: ["calculated_distraction"],
		initialStatusEffects: [["ethereal", 1], ["ichor_strength", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="clw"></div>
                <figure class="daemon rook accurate-position">
                    <img src="/img/sprites/daemons/rook/body.gif">
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="leftarm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                    <div class="rightarm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                </figure>
                
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.angelGreater_bishop = {
        name: "HEART",
        specialClass: "angelactor",
        maxhp: 50,
		hp: 25,
        actions: ["windup", "focusing_strike", "special_combo_barrier", "rez_player"], // combo barrier gives two random BP statuses because we have enough of those now where this is feasible
		windupActions: ["special_parasite_all"],
		initialStatusEffects: [["ethereal", 1], ["flesh_terminallucidity", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="net"></div>
                <figure class="daemon bishop accurate-position">
                    <img src="/img/sprites/daemons/bishop/base.gif">
                    <div class="eye"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                    <div class="tendril"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.angelGreater_rook = {
        name: "WARDN",
        specialClass: "angelactor",
        maxhp: 80,
		hp: 40,
        actions: ["enforce_support", "blink_guard_all"],
		initialStatusEffects: [["ethereal", 1], ["eyes_woundedego", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="enfc"></div>
                <figure class="daemon knight accurate-position">
                    <img src="/img/sprites/daemons/knight/body.gif">
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="eye"></div>
                    <div class="uparm">
                        <div class="downarm">
                            <div class="upclaw"></div>
                            <div class="downclaw"></div>
                        </div>
                    </div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.angelGreater_queen = {
        name: "BLCKADE",
        specialClass: "angelactor",
        maxhp: 90,
		hp: 45,
        actions: ["windup"],
        windupActions: ["windup_winderup"],
		winderupActions: ["special_rule_angelGreater", "reconstruct_mega"],
		initialStatusEffects: [["ethereal", 1], ["eyes_spotter", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="seer"></div>
                <figure class="daemon queen accurate-position">
                    <img src="/img/sprites/daemons/queen/core.gif">
                    <div class="eye"></div>
                    <div class="ring"></div>
                    <div class="ring"></div>
                    <div class="ring"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.angelGreater_king = {
        name: "EXEC",
        specialClass: "angelactor",
        maxhp: 100,
		hp: 50,
        actions: ["windup"],
		windupActions: ["windup_winderup"],
        winderupActions: ["special_judgement_angelGreater"],
		initialStatusEffects: [["ethereal", 1], ["metal_drone", 1]],
        graphic: `
            <div class="sprite-wrapper daemonsprite" id="%SLUG-sprite-wrapper">
                <div class="target" entity="archn"></div>
                <figure class="daemon king accurate-position">
                    <img src="/img/sprites/daemons/king/angles.gif">
                    <img src="/img/sprites/daemons/king/angles.gif">
                    <div class="box center"></div>
                    <div class="box outer"></div>
                    <div class="ring"></div>
                    <div class="eye"></div>
                </figure>
            </div>
            `,
        reactions: {}, //SILENT CREATURE
        events: {
            onSpawn: () => change("daemon", "saw")
        },
    },
	
	env.COMBAT_ACTORS.dullzkovik = {
        name: "Dullzkovik",
        maxhp: 500000,
        hp: 500000,
        actions: ["special_dullfriendsummon", "special_dullfriendsummon", "special_dullfriendsummon", "special_dullfriendbuff", "speak", "spy_target"],
        statusImmunities: ["stun"],
        graphic: `
            <div class="sprite-wrapper kivii" id="%SLUG-sprite-wrapper">
                <div class="sprite-overflow spritestack">
                    <img class="sprite" src="/img/sprites/combat/foes/kivii/combat.gif" id="%SLUG-sprite">
                    <div class="target" entity="dozkallvi"></div>
                </div>
            </div>
            `,
        reactions: {
            evade: ["s tÅ’Â¥Ã³ y  aw Å“ y", "n o  c l os er"],
            crit: ["ÃœÂ diÂ¢Ã¶1â‚¬Oe ÃŽ", "R E TU RN"],
            receive_crit: ["hu r ts"],
            receive_puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
            puncture: ["hÂ¿(â€°n g er", "e}vÂªer ytÃ­h&i ng", "%ÂÃ¿oÃ›Ã™"],
            receive_buff: ["ÂµÃ¿ÃiKÂp%Ã‘"],
            receive_destabilized: ["Ã¢ÂªÂ¥lÃ©Â§ÃŽÃ©Ã½Ã"],
            receive_vulnerable: ["Æ’Ã¸ÃŠ=Ã¨Â¶"],
            receive_carapace: ["MÃ‹ÂºYÂ¾Ã‘"],
            receive_redirection: ["f ina l ly aw  ake"],
            stun: ["o u  t ou t o ut", "ou to u t o  ut"],
            regen: ["m y f  le sh", "cl oÂ½ se Â®Â±â€¦ r", "mÂ¿ Ã³+r  e"],
            give_fear: ["cÃ…4Ã„â€“sT Ã½ Ã¦Ã´r,Â§Â½Ã¿lfÃƒ Ã„SÂ¿De", "Ãâ±¤0 Ã˜ â±²Æž ", "Â§Â±Ã‚â±¤ á¹¾á¸®É²Gâ”€", "YÂºÅ® ÉƒÄ›C â€° á¹‚á»ƒ", "Å¡Ã¸á»« ÉŒâ‚¬cÉ‡ hÈ©á¸¸â”€lÆ¥ mÄ’ á¹¨Ã˜Â°á¹¹È‘Ä‰Å“", "á¸§á»‚á¸ºáµ½ á¸¿á¸ á¸«eÈ½Æ¤ á¹ƒá»‡ Ä¦É†È½â±£ á¹‚á»†", "â±¤EMÅ’M BEÉŒ"],
        },
        initialStatusEffects: [["conjoined", 1]],
    },

    env.COMBAT_ACTORS.dullzkovik_gauntlet = {
        name: "Gauntlet",
        maxhp: 500000,
        hp: 500000,
        actions: ["windup", "kivii_grasp", "evade", "guard"],
        windupActions: ["ik_attack", "dullflare", "focused_windup"],
        graphic: `
            <div class="sprite-wrapper kiviigauntlet" id="%SLUG-sprite-wrapper">
                <img class="sprite" src="/img/sprites/combat/foes/kivii/gauntlet.gif" id="%SLUG-sprite">
                <div class="target" entity="gauntlet"></div>
            </div>
            `,
        reactions: {},
        initialStatusEffects: [["conjoined", 1]],
    },

// COMBAT ACTIONS
    // flesh
        // primary default
	//HOW TO EP4-IFY ACTIONS !!!!
		//add details property
			//desc property becomes flavor property under details
			//help property functionally removed
				//hit and crit effects listed with onHit and onCrit properties under details
					//conditional effects, miss effects, and summoning go in the conditional property under details as well
				//all other stats done separately
		//add stats property
			//accuracy, crit rate, damage, statuses all placed here
				//please note::hitStatus, critStatus, and execs still exist as normal
			
env.ACTIONS.husk_attack_player = {
    slug: "husk_attack_player",
    name: "Familiar Strike",
    type: 'target',
    anim: "basic-attack",
    usage: {
        act: "%USER SPRINTS AT %TARGET",
        crit: "%TARGET FACES THEIR MORTALITY",
        hit: "%TARGET IS STRUCK WITH BROKEN LIMBS",
        miss: "%TARGET EVADES"
    },
	details: {
		flavor: "'utilize warped limbs to strike target';'occasionally terrifying'",
		onHit: `'[STAT::amt]'`,
		onCrit: `'[STATUS::fear] to all foes'`,
	},
	stats: {
		accuracy: 0.8,
		crit: 0.2,
		amt: 2,
		status: {
			fear: {
				name: 'fear',
				length: 3
			}
		},
	},
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,

            critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "fear", origin: user, length: 3}); 
                    play('fear', 0.75);
                }
            })
        })
    }
}

        // secondary default
env.ACTIONS.speak_player = {
    slug: "speak_player",
    name: "Speak",
    type: 'target',
    anim: "skitter",
    usage: {
        act: "%USER APPROACHES %TARGET",
        crit: "%TARGET IS PARALYZED BY FEAR",
        hit: "%USER WHISPERS SOMETHING TO %TARGET",
        miss: "%TARGET RECOILS"
    },
	details: {
		flavor: "'utilize remains to speak';'express aggressor signal directly'",
		onHit: `'[STATUS::fear]'`,
		onCrit:`'[STATUS::stun]'`,
	},
	stats: {
		accuracy: .8,
		crit: 0.2,
		amt: 0,
		status: {
			fear: {
				name: 'fear',
				length: 3
			},
			stun: {
				name: 'stun',
				length: 1
			}
		},
	},
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'talksignal',
                rate: 1
            },
            hitExec: ()=>{
                reactDialogue(user, `give_fear`)
            },
            critSfx: {
                name: 'fear',
                rate: 0.75
            },
            critStatus: {
                name: 'stun',
                length: 1
            },
            hitStatus: {
                name: 'fear',
                length: 3
            },
        })
    }
}

        // utility default
env.ACTIONS.special_demoralize = {
    slug: "special_demoralize",
    name: "Demoralize",
    type: 'special',
    anim: "skitter",
    accuracy: 0.7,
    crit: 0.3,
    amt: 0,
    usage: {
        act: "%USER SHRIEKS AT THEIR FOES"
    },
	details: {
		flavor: "'overexert remains;'broadly express aggressor signal to foes'",
		onHit: `'[STATUS::fear]'`,
		onCrit: `'[STATUS::weakened]'`
	},
	stats: {
		accuracy: .7,
		crit: 0.3,
		amt: 0,
		status: {
			fear: {
				name: 'fear',
				length: 2
			},
			weakened: {
				name: 'weakened',
				length: 1
			},
		},
	},
    exec: function(user, target, beingUsedAsync) {
        let action = this

        env.GENERIC_ACTIONS.teamWave({
            team: user.enemyTeam,
            exec: (actor, i) => {
				if(actor.slug == user.slug) return;
                env.GENERIC_ACTIONS.singleTarget({
                    action: action, 
                    user, 
                    target: actor,
                    hitSfx: { name: 'talksignal' },
                    critSfx: { name: 'fear', rate: 0.75 },
                    hitStatus: {
                        name: 'fear',
                        length: 2
                    },
                    critExec: () => {
                        addStatus({origin: user, target: actor, status: "weakened", length: 1}); 
                    },
                })
            },
            advanceAfterExec: true, beingUsedAsync, user,
        })
    }
}

        // primary augment
env.ACTIONS.necrotic_strike = {
    slug: "necrotic_strike",
    name: "Necrotic Strike",
    type: 'target',
    anim: "basic-attack",
    usage: {
        act: "%USER SPRINTS AT %TARGET",
        crit: "%TARGET'S TEAM ROTS BEFORE THEIR EYES",
        hit: "%TARGET IS STRUCK WITH ROTTING LIMBS",
        miss: "%TARGET EVADES"
    },
    details: {
		flavor: "'utilize rotting limbs to strike target';'occasionally terrifying'",
		onHit: `'[STAT::amt]'`,
		onCrit: `'[STATUS::fear], [STATUS::rot] to all foes'`,
	},
	stats: {
		accuracy: 0.8,
		crit: 0.2,
		amt: 1,
		status: {
			fear: {
				name: 'fear',
				length: 2
			},
			rot: {
				name: 'rot',
				length: 3
			},
		},
	},
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,

            critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "fear", origin: user, length: 2}); 
                    addStatus({target: actor, origin: user, status: "rot", origin: user, length: 3});
                    play('fear', 0.6);
                }
            })
        })
    }
}

        // secondary augment
env.ACTIONS.player_psychosis = {
    slug: "player_psychosis",
    name: "Psychosis",
    type: 'target',
    anim: "skitter",
    usage: {
        act: "%USER APPROACHES %TARGET",
        crit: "%TARGET IS PARALYZED BY FEAR",
        hit: "%USER IS STRUCK, BUT BY WHAT?",
        miss: "%TARGET RECOILS"
    },
	details: {
		flavor: "'utilize remains to inject destructive thoughts';'eat away at foes from the inside'",
		onHit: `'[STATUS::fear] [STATUS::rot]'`,
		onCrit:`'[STAT::selfHP] [STATUS::stun]'`,
	},
	stats: {
		accuracy: .8,
		crit: 0.1,
		selfHP: 1,
		status: {
			fear: {
				name: 'fear',
				length: 2
			},
			rot: {
				name: 'rot',
				length: 3
			},
			stun: {
				name: 'stun',
				length: 2
			},
		},
	},
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'talksignal',
                rate: 0.75
            },
            hitExec: () => {
                addStatus({origin: user, target, status: "fear", length: 2}); 
                addStatus({origin: user, target, status: "rot", length: 3}); 
            },
			critExec: () => {
				combatHit(target, {amt: 1, crit: 0, autohit: true, origin: user});
            },
            critStatus: {
                name: 'stun',
                length: 2
            },
        })
    }
}

        // utility augment
env.ACTIONS.special_player_chant = {
    slug: "special_player_chant",
    name: "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ",
    type: 'special+summon',
    anim: "orbshake",
	details: {
		flavor: "'â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ';'convey malignant thoughtforms via speech'",
		onHit: `'inflict one of following';'[STATUS::fear], [STATUS::puncture], [STAT::selfHP]'`,
		onCrit:`'[STAT::selfHP] [STATUS::weakened]';'summon hallucination (max:4)'`,
	},
	stats: {
		accuracy: .7,
		crit: 0.1,
		amt: 0,
		selfHP: 1,
		status: {
			fear: {
				name: 'fear',
				length: 2
			},
			puncture: {
				name: 'puncture',
				length: 1
			},
			weakened: {
				name: 'weakened',
				length: 1
			},
		},
	},
    usage: {
        act: "%USER â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ" //unrelated but i think the action message says "SPEAKS THE TRUTH" but redacted :P
    },
    exec: function(user, target, beingUsedAsync) {
        let action = this
		let fated = user.statusEffects.find(status => status.slug == "fated_flesh")

        env.GENERIC_ACTIONS.teamWave({
            team: user.enemyTeam,
            exec: (actor, i) => {
                env.GENERIC_ACTIONS.singleTarget({
                    action: action, 
                    user, 
                    target: actor,
                    hitSfx: { name: 'talksignal' },
                    critSfx: { name: 'fear', rate: 0.75 },
                    hitExec: ({target})=> {
						let rand = Math.random()
						if(rand < 0.3) {
							addStatus({target, origin: user, status: "fear", origin: user, length: 2}); 
							
						} else if(rand < 0.6) {
							addStatus({target, origin: user, status: "puncture", origin: user, length: 1}); 

						} else {
							combatHit(actor, {amt: 1, crit: 0, autohit: true, origin: user});
						}
					},
                    critStatus: {
                        name: 'weakened',
                        length: 1
                    },
                    critExec: ({target}) => {
						reactDialogue(user, 'summon')
                        user.lastSide = !user.lastSide
                        if(user.team.members.filter(m=>m.slug.includes('player_hallucination')).length < (fated ? fated.power + 4 : 4)) {
                            midCombatAllyAdd('player_hallucination', user.lastSide ? "left" : "right")
                        }
						combatHit(actor, {amt: 1, crit: 0, autohit: true, origin: user});
                    }
                })
            },
            advanceAfterExec: true, beingUsedAsync, user,
        })
    }
}

        // daemon thing
env.ACTIONS.recall = {
    slug: "recall",
    name: "Recall",
    type: 'autohit',
    desc: "'suffer from partial ruleset paradox'",
    anim: "skitter",
    help: "-1HP, +1T:STUN",
    usage: {
        act: "THE FIRMAMENT UNDOES %USER'S ACTION"
    },
    acc: 100,
    crit: -1,
    exec: function(user, target) {
        combatHit(user, {amt: 1, acc: this.accuracy, crit: this.crit, origin: user})
        addStatus({target: user, status: "stun", length: 1, noReact: true}); 
        return 'nothing';
    }
}

    env.ACTIONS.malfunction_good = {
        slug: "malfunction_good",
        name: "Malfunction",
        type: 'autohit',
        desc: "'suffer from internal deterioration'",
        anim: "skitter",
        help: "-1HP, +1T:VULNERABLE",
        usage: {
            act: "%USER'S SKIN WRITHES"
        },
        acc: 100,
        crit: -1,
        exec: function(user, target) {
            combatHit(user, {amt: 1, acc: this.accuracy, crit: this.crit, origin: user})
            addStatus({target: user, status: "vulnerable", length: 1, noReact: true});
			advanceTurn(user)
            return 'nothing';
        }
    },

    // dull
        //warped collapse actions
env.ACTIONS.foe_stab_weak = {
    slug: "foe_stab_weak",
    name: "Clumsy Swing",
    type: 'target',
    desc: "'unwieldy strike with weak limbs';'attempt to puncture vital corrucystic components'",
    help: "35% -1HP +3T:PUNCTURE -REGEN, 10%C x2 +3T:PUNCTURE",
    anim: "basic-attack",
    usage: {
        act: "%USER BLINDLY STABS %TARGET",
        crit: "%TARGET BLEEDS PROFUSELY",
        hit: "%TARGET IS CUT",
        miss: "%TARGET EVADES"
    },
	details: {
		flavor: "'unwieldy strike with weak limbs';'attempt to puncture vital corrucystic components'",
		onHit: `'[STAT::amt] [STATUS::puncture]'`,
		onCrit: ()=> `'puncture vital cystic component for [STATUS::puncture]'${env?.rpg?.is2D ? ";'KB::2'" : ''}`,
	},
	stats: {
		accuracy: 0.35,
		crit: 0.1,
		amt: 1,
		status: {
			puncture: {
				name: 'puncture',
				length: 3
			}
		}
	},
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'stab',
                rate: 1
            },
            critStatus: {
                name: 'puncture',
                length: 3
            },
            hitStatus: {
                name: 'puncture',
                length: 3
            },
        })
    }
}

env.ACTIONS.spy_weak = {
    slug: "spy_weak",
    name: "Spy",
    verb: "spy on",
    type: 'target',
    desc: "'attempt to expose enemy weakness';'increase hit and crit chances'",
    help: "80% +3T:VULNERABLE -EVASION",
    anim: "spying",
    frameClass: "temp-perspective",
    animDuration: 2000,
    usage: {
        act: "%USER SPIES UPON %TARGET",
        crit: "%TARGET IS MARKED FOR DEATH",
        hit: "%TARGET FEELS TARGETED",
        miss: "%USER LOOSES SIGHT OF %TARGET"
    },
	details: {
		onHit: `'[STATUS::vulnerable]'`,
	},
	stats: {
		accuracy: 0.8,
		crit: 0,
		status: {
			vulnerable: {
				name: 'vulnerable',
				length: 3
			}
		}
	},
    exec: function(user, target) {
        reactDialogue(user, `give_vulnerable`)
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'status',
                rate: 0.75
            },
            hitStatus: {
                name: 'vulnerable',
                length: 3
            },
        })
    }
}

env.ACTIONS.mend_weak = {
    slug: "mend_weak",
    name: "Clumsy Mend",
    type: 'support+target+self+autohit',
    desc: "'restore health';'heal over time';'cure puncture'",
    help: "AUTOHIT +1HP +2T:REGEN -PUNCTURE, 10%C +1HP",
    anim: "heal",
    usage: {
        act: "%USER FIXES UP %TARGET",
        crit: "%TARGET FEELS BETTER",
        hit: "%TARGET FEELS A LITTLE BETTER",
        miss: "%TARGET IS TOO SLIPPERY"
    },
	details: {
		onHit: `'[STAT::amt] [STATUS::regen]'`,
	},
	stats: {
		range: 2,
		crit: 0.1,
		autohit: true,
		amt: -1,
		status: {
			regen: {
				name: 'regen',
				length: 2
			}
		}
	},
    autohit: true,
    beneficial: true,
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            beneficial: true,
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'mend',
                rate: 1
            },
            hitStatus: {
                name: 'regen',
                length: 2
            },
        })
    },

    avoidChaining: true,
    disableIf: (actor) => {
        return (
            actor.team.name == "enemy" &&
            !actor.team.members.some(member => ((member != actor) && (member.state != "dead") ))
        )
    }
}

env.ACTIONS.daze_lastresort_weak = {
    slug: "daze_lastresort_weak",
    name: "Blind Bash",
    type: 'target',
    desc: "'swing self'",
    anim: "basic-attack",
    help: "25% -1HP, 25%C x2 +1T:STUN",
    usage: {
        act: "%USER SWINGS AT %TARGET",
        crit: "%TARGET IS LEFT REELING",
        hit: "%TARGET IS STRUCK",
        miss: "%TARGET EVADES"
    },
	details: {
		flavor: "'last resort attack';'swing self'",
		onHit: `'[STAT::amt]'`,
		onCrit:`'[STATUS::stun]'`,
	},
	stats: {
		accuracy: 0.25,
		crit: 0.25,
		amt: 1,
		status: {
			stun: {
				name: 'stun',
				length: 1
			},
		},
	},
    exec: (user, target)=>{env.ACTIONS.secondary.exec(user, target)},
    
}

env.ACTIONS.stab_weak = {
    slug: "stab_weak",
    name: "Clumsy Swing",
    type: 'target',
    desc: "'unwieldy strike with weak limbs';'attempt to puncture vital corrucystic components'",
    help: "50% -1HP +3T:PUNCTURE -REGEN, 10%C -1HP +3T:PUNCTURE",
    anim: "basic-attack",
    usage: {
        act: "%USER STABS %TARGET",
        crit: "%TARGET IS EVISCERATED",
        hit: "%TARGET BLEEDS SLUDGY CORRU",
        miss: "%TARGET EVADES"
    },
    details: {
		flavor: "'unwieldy strike with weak limbs';'attempt to puncture vital corrucystic components'",
		onHit: `'[STAT::amt] [STATUS::puncture]'`,
		onCrit: ()=> `'puncture vital cystic component for [STATUS::puncture]'${env?.rpg?.is2D ? ";'KB::2'" : ''}`,
	},
	stats: {
		accuracy: 0.5,
		crit: 0.1,
		amt: 1,
		status: {
			puncture: {
				name: 'puncture',
				length: 3
			}
		}
	},
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'stab',
                rate: 1
            },
            critStatus: {
                name: 'puncture',
                length: 3
            },
            hitStatus: {
                name: 'puncture',
                length: 3
            },
        })
    }
}

env.ACTIONS.archival_smash_weak = {
    slug: "archival_smash_weak",
    name: "Calculated Strike",
    type: 'target',
    desc: "'focused, deadly attack upon one target';'immense physical trauma'",
    anim: "basic-attack",
    help: "60% -3HP, 30% X2 +1T:STUN",
    usage: {
        act: "%USER CHARGES %TARGET",
        crit: "%TARGET IS LEFT REELING",
        hit: "%TARGET IS STRUCK",
        miss: "%TARGET EVADES"
    },
    details: {
		flavor: "'deadly attack upon one target';'immense physical trauma'",
		onHit: `'[STAT::amt]'`,
		onCrit: `'[STATUS::stun]'`,
	},
	stats: {
		accuracy: 0.7,
		crit: 0.4,
		amt: 3,
		status: {
			stun: {
				name: 'stun',
				length: 1
			}
		},
	},
    exec: function(user, target) {
        removeStatus(user, "windup")
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'hit',
                rate: 0.8
            },
            critStatus: {
                name: 'stun',
                length: 1
            }
        })
    }
}

        //warped golem maintanence actions
env.ACTIONS.special_self_destruct_dull = {
    slug: "special_self_destruct_dull",
    name: "Hypervelocity Detonation",
    type: 'special',
    desc: "'form shrapnel in body';'propel via dull'",
    help: "FOES::70% -2HP, 20%C x2 +1T:STUN, 100% SELF -1HP",
    anim: "explode",
    accuracy: 0.7,
    crit: 0.2,
    amt: 2,
    usage: {
        act: "%USER JUST EXPLODES"
    },
	details: {
		flavor: `'form shrapnel in body';'propel through unsustainable means'`,
		onUse: `'HIT all foes';'[STAT::amt] to self'`,
		onHit: `'[STAT::amt]'`,
		onCrit: `'[STATUS::stun]'`
	},

	stats: {
		accuracy: 0.7,
		crit: 0.2,
		amt: 2,
		status: {
			stun: { name: 'stun', length: 1 }
		}
	},
    exec: function(user, target, beingUsedAsync) {
        let action = this
        play('shot5', 0.6)
        env.GENERIC_ACTIONS.teamWave({
            team: user.enemyTeam,
            exec: (actor, i) => {
                env.GENERIC_ACTIONS.singleTarget({
                    action: action, 
                    user, 
                    target: actor,
                    hitSfx: { name: 'shot2' },
                    critSfx: { name: 'shot6' },
                    critStatus: {
                        name: 'stun',
                        length: 1
                    },
                })
                combatHit(user, {amt: 1, autohit: true, crit: 0, origin: user, redirectable: false, runEvents: false})
            },
            advanceAfterExec: true, beingUsedAsync, user,
        })
    }
}

env.ACTIONS.player_husk_attack_weak = { //vanity rename for the dusk
    slug: "player_husk_attack_weak",
    name: "Psychosis",
    type: 'target',
    desc: "'utilize badly warped limbs to strike foes';'occasionally terrifying'",
    anim: "basic-attack",
    help: "50% -1HP, 10%C x2 + (FOES::+2T:FEAR)",
    usage: {
        act: "%USER SPRINTS AT %TARGET",
        crit: "%TARGET FACES THEIR MORTALITY",
        hit: "%TARGET IS STRUCK",
        miss: "%TARGET EVADES"
    },
	details: {
		flavor: `'manifest imagined attack directly in flesh';'occasionally terrifying'`,
		onHit: `'[STAT::amt]'`,
		onCrit:`'[STATUS::fear] to all foes'`,
	},
	stats: {
		accuracy: .5,
		crit: 0.1,
		amt: 1,
		status: {
			fear: {
				name: 'fear',
				length: 2
			}
		},
	},
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,

            critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "fear", origin: user, length: 2}); 
                    play('fear', 0.75);
                }
            })
        })
    }
}

env.ACTIONS.speak_weak = {
    slug: "speak_weak",
    name: "Dullvoice",
    type: 'target',
    desc: "'utilize dull to speak';'express aggressor signal directly'",
    help: "65% +2T:FEAR, 10%C +1T:STUN",
    anim: "skitter",
    usage: {
        act: "%USER APPROACHES %TARGET",
        crit: "%TARGET IS PARALYZED BY FEAR",
        hit: "%USER WHISPERS SOMETHING TO %TARGET",
        miss: "%USER'S THROAT CLOSES"
    },
    details: {
		flavor: "'establish connection to target via the dull';'express aggressor signal directly'",
		onHit: `'[STATUS::fear]'`,
		onCrit:`'[STATUS::stun]'`,
	},
	stats: {
		accuracy: .65,
		crit: 0.1,
		amt: 0,
		status: {
			fear: {
				name: 'fear',
				length: 2
			},
			stun: {
				name: 'stun',
				length: 1
			}
		},
	},
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'talksignal',
                rate: 1
            },
            hitExec: ()=>{
                reactDialogue(user, `give_fear`)
            },
            critSfx: {
                name: 'fear',
                rate: 0.75
            },
            critStatus: {
                name: 'stun',
                length: 1
            },
            hitStatus: {
                name: 'fear',
                length: 2
            },
        })
    }
}

env.ACTIONS.evade_weak = {
    slug: "evade_weak",
    name: "Lesser Focus",
    type: 'autohit',
    desc: "'look for opportunity';'useful against wily foes'",
    anim: "heal",
    details: {
		onUse: () => `'gain [STATUS::focused]'`,
		flavor: "'deliberate on the moment and its opportunities'"
	},
    usage: {
        act: "%USER LOOKS FOR AN OPENING"
    },
	stats: {
		status: {
			focused: {
				name: 'focused',
				length: 1
			},                
		}
	},
    exec: function(user, target) {
        play('mend', 0.66); 
        addStatus({target: user, status: "focused", length: 1, noReact: true}); 
        return 'nothing';
    },
    disableIf: (actor)=>{ if(hasStatus(actor,"fear")) return "PROHIBITED BY FEAR" },
    avoidChaining: true
}

env.ACTIONS.tozik_attack_weak = {
    slug: "tozik_attack_weak",
    name: "Warped Corruskivi",
    type: 'target',
    desc: "'utilize damaged repair tool as weapon';'chance to drain corru for health'",
    anim: "basic-attack",
    help: "50% -1HP, 20%C x2 + (ALLIES::+1HP +1T:REGEN)",
    usage: {
        act: "%USER CLAWS AT %TARGET",
        crit: "%TARGET'S LIFE IS DRAINED AWAY",
        hit: "%TARGET IS SLASHED",
        miss: "%TARGET DODGES"
    },
	details: {
		flavor: `'attack with damaged repair tool';'siphon vital corru'`,
		onHit: `'[STAT::amt]'`,
		onCrit: `'heal nearby allies for [STAT::healHP] [STATUS::regen]'`,
	},
    stats: { // 'base' stats used to modify effective stats. can coexist with legacy stats
		accuracy: 0.5, 
		crit: 0.2,
		amt: 1,
		healHP: -1,
		range: 2,
		status: {
			regen: {
				name: 'regen',
				length: 1
			}
		}
	},
    exec: function(user, target) {
        if(env.rpg.classList.contains("tutorialgolem")) change("PAGE!!earlytoz", true)

        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'stab',
                rate: 1.5
            },

            critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i)=>{
                    combatHit(actor, {amt: -1, origin: user, autohit: true, beneficial: true});
                    addStatus({target: actor, origin: user, status: "regen", length: 1});
                    play('mend')
                }
            })
        })
    }
}

env.ACTIONS.bozko_attack_weak = {
    slug: "bozko_attack_weak",
    name: "Clumsy Disable",
    type: 'target',
    desc: "'strike offensive appendages of target';'chance to greatly weaken attacks'",
    anim: "basic-attack",
    help: "40% -2HP, 30%C x2 +2T:WEAKENED",
    usage: {
        act: "%USER JABS AT %TARGET'S WEAPONRY",
        crit: "%TARGET IS CRIPPLED",
        hit: "%TARGET IS STRUCK",
        miss: "%TARGET EVADES"
    },
    details: {
		flavor: "'strike at offensive appendages of target';'attempt to weaken'",
		onHit: `'[STAT::amt]'`,
		onCrit:`'[STATUS::weakened]'`,
	},
	stats: {
		accuracy: .4,
		crit: 0.3,
		amt: 2,
		status: {
			weakened: {
				name: 'weakened',
				length: 2
			}
		},
	},
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            critStatus: {
                name: 'weakened',
                length: 2
            }
        })
    }
}

env.ACTIONS.ik_attack_vanity = {
    slug: "ik_attack_vanity",
    name: "Veilksplitter",
    verb: "veilksplit",
    type: 'target',
    desc: "'dull-enabled cutting beam';'windup period removed due to heavy dull exposure",
    anim: "basic-attack",
    help: "AUTOHIT -4HP +1T:STUN 5%C x2",
    usage: {
        act: "%USER BLASTS %TARGET",
        crit: "%TARGET IS ANNIHILATED",
        hit: "%TARGET IS SEARED",
        miss: "%TARGET EVADES"
    },
    details: {
		flavor: `'utilize dull-enabled cutting beam';'windup period removed due to dull saturation'`,
		onHit: ()=> `'[STAT::amt] [STATUS::stun]'${env?.rpg?.is2D ? ";'KB::4'" : ''}`,
	},

	stats: { 
		autohit: true, 
		crit: 0.05,
		amt: 4,
		status: {
			stun: {
				name: 'stun',
				length: 1
			}
		}
	},
    exec: function(user, target) {
        removeStatus(user, "windup")
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'dull',
                rate: 0.5
            },
            critSfx: {
                name: 'stab',
                rate: 0.4
            },
            genExec: ({target}) => {
                addStatus({target, status: "stun", length: 1});
            }
        })
    }
}

env.ACTIONS.dullflare_vanity = {
    slug: "dullflare_vanity",
    name: "Dull Flare",
    type: 'special',
    desc: "'wide directional release of rapidly decaying dull light';'windup period removed due to heavy dull exposure'",
    help: "FOES::AUTOHIT -3HP 10%C x2",
    anim: "basic-attack",
    details: {
		flavor: "'wide directional release of rapidly decaying dull light';'windup period removed due to dull saturation'",
		onUse: `'HIT all foes'`,
		onHit: `'[STAT::amt]'`,
	},
	stats: {
		autohit: true,
		accuracy: .8,
		crit: .1,
		amt: 3,
	},
    usage: {
        act: "%USER TEARS OPEN THE DULL"
    },
    exec: function(user, target, beingUsedAsync) {
        removeStatus(user, "windup")
        let action = this
        env.GENERIC_ACTIONS.teamWave({
            team: user.enemyTeam,
            exec: (actor, i) => {
                let anim = env.COMBAT_ANIMS.flare
                let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
                let animDelay = baseDelay + anim.duration;
                    
                setTimeout(()=>anim.exec(action, user, actor), baseDelay)
                setTimeout(function(){
                    env.GENERIC_ACTIONS.singleTarget({
                        beneficial: true,
                        action: action, 
                        user, 
                        target: actor,
                        hitSfx: { name: 'dull', rate: 1.5 },
                        critSfx: { name: 'shot6', rate: 0.75 },
                    })
                }, animDelay);
            },
            advanceAfterExec: true, beingUsedAsync, user,
        })
    }
}

env.ACTIONS.spy_analyze_weak = {
    slug: "spy_analyze_weak",
    name: "Glitched Analysis",
    type: 'target',
    desc: "'expose enemy weakness';'increase hit and crit chances'",
    help: "60% +3T:VULNERABLE -EVASION",
    anim: "spying",
    frameClass: "temp-perspective",
    animDuration: 2000,
    usage: {
        act: "%USER SCANS %TARGET",
        hit: "%TARGET FEELS TARGETED",
        miss: "%TARGET HIDES BEHIND SOMETHING"
    },
    details: {
		onUse: `'[STATUS::vulnerable]'`,
	},
	stats: {
		range: 5,
		autohit: true,
		status: {
			vulnerable: {
				name: 'vulnerable',
				length: 3
			}
		}
	},
    exec: (user, target)=>{env.ACTIONS.spy_weak.exec(user, target)}
}

        //warped boss actions
env.ACTIONS.movefriend_attack_weak = {
    slug: "movefriend_attack_weak",
    name: "Slow Broadcast",
    type: 'target',
    desc: "'directly seize control of corrucystic organs';'chance to utilize target as signal amplifier'",
    anim: "wobble",
    help: "50% -2HP +1T:PUNCTURE, 25%C (FOES::-1HP +2T:VULNERABLE)",
    usage: {
        act: "%USER'S SIGIL WARPS STRANGELY",
        crit: "THE WHOLE TEAM FEELS ILL",
        hit: "%TARGET'S FLESH REVOLTS",
        miss: "%TARGET RECOILS SAFELY"
    },
    details: {
		flavor: `'directly seize control of corrucystic organs';'chance to utilize target as signal amplifier'`,
		onHit: `'[STAT::amt] [STATUS::puncture]'`,
		onCrit:`'[STAT::selfHP] [STATUS::vulnerable] to all foes'`,
	},
	stats: {
		accuracy: .5,
		crit: 0.2,
		amt: 2,
		status: {
			vulnerable: {
				name: 'vulnerable',
				length: 2
			},
			puncture: {
				name: 'puncture',
				length: 1
			}
		},
	},
    exec: function(user, target) {
        content.classList.add('painprep', 'painhalf')
        setTimeout(()=>{content.classList.add('painmode')}, 100)
        setTimeout(()=>{content.classList.remove('painmode')}, 2000)
        setTimeout(()=>{content.classList.remove('painprep', 'painhalf')}, 3000)

        env.rpg.classList.remove('incoherentbg')

        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitStatus: {name: 'puncture', length: 1}, critStatus: {name: 'puncture', length: 1},
            
            critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
                    combatHit(actor, {amt: 1, crit: 0, autohit: true, origin: user});
                    addStatus({target: actor, status: "vulnerable", length: 2}); 
                    play("talksignal", 0.75)
                }
            })
        })
    }
}

env.ACTIONS.player_movefriend_crush = {
    slug: "player_movefriend_crush",
    name: "Crush",
    verb: "crush",
    type: 'target',
    desc: "'utilize walls to crush a target';'attempt to guarantee strike'",
    anim: "basic-attack",
    help: "80% -2HP",
    usage: {
        act: "THE WALLS GROW HOSTILE AROUND %TARGET",
        hit: "%TARGET WITHSTANDS THE STRIKE",
        miss: "%TARGET ESCAPES BY A HAIR"
    },
    accuracy: 0.8,
    amt: 2,
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
        })
    }
}

env.ACTIONS.player_movefriend_annihilation = {
    slug: "player_movefriend_annihilation",
    name: "Annihilation",
    verb: "annihilate",
    type: 'target',
    desc: "'utilize walls to crush a target';'chance for immense physical trauma'",
    anim: "basic-attack",
    help: "40% -2HP, 40%C -2HP +1T:STUN",
    usage: {
        act: "THE WALLS GROW HOSTILE AROUND %TARGET",
        crit: "%TARGET BARELY STANDS",
        hit: "%TARGET DID THEIR BEST",
        miss: "%TARGET ESCAPED BY A HAIR"
    },
    accuracy: 0.4,
    crit: 0.4,
    amt: 2,
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            critStatus: {
                name: 'stun',
                length: 1
            }
        })
    }
}

	env.ACTIONS.special_playershelf_annihilate_movefriend = {
        slug: "special_playershelf_annihilate_movefriend",
        name: "Annihilation",
        type: 'special+target',
        desc: "'utilize walls to crush a target';'offer user responsive choice'",
        anim: "wobble",
        help: "CHOOSE::80% -2HP ::OR:: 40% -2HP, 40%C x2 +1T:STUN",
        usage: {
            act: "THE WALLS GROW HOSTILE AROUND %TARGET",
            crit: "%TARGET BARELY STANDS",
            hit: "%TARGET DID THEIR BEST",
            miss: "%TARGET ESCAPED BY A HAIR"
        },
        details: {
            onUse: `'present target foe a choice of outcome'`,
            conditional: `<em>HIT 1</em>::'HIT::[STAT::hit1ACC]% CRIT::0% [STAT::hit1HP]'\n<em>HIT 2</em>::'HIT::[STAT::hit2ACC]% CRIT::[STAT::hit2CRIT]% [STAT::hit2HP]';'[STATUS::stun] on CRIT'`
        },
        stats: {
            hit1HP: 2,
            hit1ACC: 80,
            hit2HP: 2,
            hit2ACC: 40,
            hit2CRIT: 40,
            status: {
                stun: { name: 'stun', length: 1 },
                puncture: { name: 'puncture', length: 2 }
            },
        },
        noRepeat: true,
        exec: function(user, target) {
            let action = this

            //summon a div that lets the player click guaranteed or chance
            actionChoice({
                user: user,
                action: action,
                choiceText: `${user.name} lunges at ${target.name}...`,
                options: [
                    {text: "Guarantee strike", definition: "NOTE::'80% -2HP'"},
                    {text: "Try a riskier attack", definition: "NOTE::'40% -2HP, 40%C x2 +1T:STUN'"},
                ],
                choiceCallback: (c) => {
                    //reap the consequences
                        
                    var hit
                    switch(c) {
                        case "c0":
                            hit = combatHit(target, {amt: 2, acc: 0.8, crit: 0, origin: user});
                            break;
                        case "c1":
                            hit = combatHit(target, {amt: 2, acc: 0.4, crit: 0.4, origin: user})
                            break
                    }

                    actionMessage(user, action, target, hit)
                    switch(hit) {
                        case "crit":                                
                            playCombatCrit()
                            addStatus({target: target, origin: user, status: "stun", length: 1})
                            removeStatus(target, "windup")
                            break
                        case true:
                            reactDialogue(target, 'receive_hit')
                            play("hit", 0.75)
                            break;
                        case false:
                            reactDialogue(target, 'evade')
                            play("miss", 0.75)
                            break;
                    }

                    setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE);
                }
            })
        }
    }
	
	env.ACTIONS.special_playershelf_annihilate_painshelf = {
        slug: "special_playershelf_annihilate_painshelf",
        name: "Annihilation",
        type: 'special+target',
        desc: "'utilize long limbs to eviscerate a target';'offer user responsive choice'",
        anim: "wobble",
        help: "CHOOSE::80% -3HP ::OR:: 40% -2HP, 40%C x2 +2T:PUNCTURE +1T:STUN",
        usage: {
            act: "%USER LUNGES AT %TARGET",
            crit: "%TARGET IS BRUTALLY STABBED",
            hit: "%TARGET TAKES A SOLID HIT",
            miss: "%TARGET ESCAPED BY A HAIR"
        },
        details: {
            onUse: `'present target foe a choice of outcome'`,
            conditional: `<em>HIT 1</em>::'HIT::[STAT::hit1ACC]% CRIT::0% [STAT::hit1HP]'\n<em>HIT 2</em>::'HIT::[STAT::hit2ACC]% CRIT::[STAT::hit2CRIT]% [STAT::hit2HP]';'[STATUS::stun] [STATUS::puncture] on CRIT'`
        },
        stats: {
            hit1HP: 3,
            hit1ACC: 80,
            hit2HP: 2,
            hit2ACC: 40,
            hit2CRIT: 40,

            status: {
                stun: { name: 'stun', length: 1 },
                puncture: { name: 'puncture', length: 2 }
            },
        },
        exec: function(user, target) {
            let action = this

            //summon a div that lets the player click guaranteed or chance
            actionChoice({
                user: user,
                action: action,
                choiceText: `${user.name} lunges at ${target.name}...`,
                options: [
                    {text: "Guarantee strike", definition: "NOTE::'80% -3HP'"},
                    {text: "Try a riskier attack", definition: "NOTE::'40% -2HP, 40%C x2 +2T:PUNCTURE +1T:STUN'"},
                ],
                choiceCallback: (c) => {
                    //reap the consequences
                        
                    var hit
                    switch(c) {
                        case "c0":
                            hit = combatHit(target, {amt: 3, acc: 0.8, crit: 0, origin: user});
                            break;
                        case "c1":
                            hit = combatHit(target, {amt: 2, acc: 0.4, crit: 0.4, origin: user})
                            break
                    }

                    actionMessage(user, action, target, hit)
                    switch(hit) {
                        case "crit":                                
                            playCombatCrit()
                            addStatus({target: target, origin: user, status: "stun", length: 1})
							addStatus({target: target, origin: user, status: "puncture", length: 2})
                            removeStatus(target, "windup")
                            break
                        case true:
                            reactDialogue(target, 'receive_hit')
                            play("stab", 0.75)
                            break;
                        case false:
                            reactDialogue(target, 'evade')
                            play("miss", 0.75)
                            break;
                    }

                    setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE);
                }
            })
        }
    }

env.ACTIONS.special_player_movefriendsummon = {
    slug: "special_player_movefriendsummon",
    name: "Offensive Groundsmindry",
    type: 'special+summon+nomimic',
    desc: "'utilize aggressor signal to create allies'",
    help: "SUMMON::2 WARPED TENDRILS (MAX: 2 TENDRILS)",
    anim: "heal",
    accuracy: 1,
    crit: 0,
	itemAction: true, //we have to lie here so that imps can't use this action
    noRepeat: true,
	details: {
		flavor: `'utilize groundsmindry authority to create allies'`,
		conditional: `<em>SUMMON::</em>'summon 2 warped tendrils'`,
		onUse: `'remove this action'`
	},
    exec: function(user, target) {
        actionMessage(user, "%USER FORMS WEAPONS FROM THE WALLS", target, 'none', 2000);
        play('stab', 0.5, 1);
        
        //try to center the dude
        if(user.team.members.length == 14) {
            let uI = user.team.members.findIndex(a => a.slug == user.slug)
            if(uI < 3) midCombatAllyAdd('player_dull_tendrils', 'left')
            else if(uI >= 3) midCombatAllyAdd('player_dull_tendrils', 'right')
        } else {
            midCombatAllyAdd('player_dull_tendrils', 'left')
            midCombatAllyAdd('player_dull_tendrils', 'right')
        }
        user.actions = user.actions.filter(action => action !== "special_player_movefriendsummon")
        setTimeout(()=>advanceTurn(user), 1000)
    },
}

env.ACTIONS.swipe_weak = {
    slug: "swipe_weak",
    name: "Wild Swipe",
    type: 'target',
    desc: "'swipe blindly at target';'chance for persistent wound'",
    anim: "basic-attack",
    help: "40% -1HP, 20%C x2 +1T:PUNCTURE -REGEN",
    usage: {
        act: "%USER SWIPES AT %TARGET",
        crit: "%TARGET IS STABBED",
        hit: "%TARGET IS STRUCK",
        miss: "%TARGET DUCKS OUT OF THE WAY"
    },
    details: {
		flavor: "'swipe blindly at target';'chance for persistent wound'",
		onHit: `'[STAT::amt]'`,
		onCrit: ()=> `'puncture vital cystic component for [STATUS::puncture]'${env?.rpg?.is2D ? ";'KB::2'" : ''}`,
	},
	stats: {
		accuracy: 0.4,
		crit: 0.2,
		amt: 1,
		status: {
			puncture: {
				name: 'puncture',
				length: 1
			}
		}
	},
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            critStatus: {
                name: 'puncture',
                length: 1
            }
        })
    }
}

env.ACTIONS.player_archiveshelf_crush = {
    slug: "player_archiveshelf_crush",
    name: "Crush",
    verb: "crush",
    type: 'target',
    desc: "'utilize long limbs to eviscerate to a target';'attempt to guarantee strike'",
    anim: "basic-attack",
    help: "90% -3HP",
    usage: {
        act: "%USER LUNGES AT %TARGET",
        hit: "%TARGET TAKES A SOLID HIT",
        miss: "%TARGET ESCAPES BY A HAIR"
    },
    accuracy: 0.9,
    amt: 3,
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
        })
    }
}

env.ACTIONS.player_archiveshelf_annihilation = {
    slug: "player_archiveshelf_annihilation",
    name: "Annihilation",
    verb: "annihilate",
    type: 'target',
    desc: "'utilize long limbs to eviscerate a target';'chance for immense physical trauma'",
    anim: "basic-attack",
    help: "50% -2HP, 50%C -2HP +2T:PUNCTURE +1T:STUN",
    usage: {
        act: "%USER LUNGES AT %TARGET",
        crit: "%TARGET IS BRUTALLY STABBED",
        hit: "%TARGET TAKES A SOLID HIT",
        miss: "%TARGET ESCAPED BY A HAIR"
    },
    accuracy: 0.5,
    crit: 0.5,
    amt: 2,
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            critExec: ({target})=>{
                addStatus({target, status: "stun", length: 1});
                addStatus({target, status: "puncture", length: 2});
            }
        })
    }
}

env.ACTIONS.player_special_dullauto = {
    slug: "player_special_dullauto",
    name: "Dull Auto",
    type: 'special',
    desc: "'utilize automatic rifle';'rapid inaccurate attacks'",
    anim: "wobble",
    help: "x6 RANDOM ENEMY::33% -1HP +1T:DESTABILIZED 33%C -1HP +1T:VULNERABLE",
    usage: {
        act: "%USER OPENS FIRE",
    },
    details: {
		flavor: "'utilize dull pulse rifle';'rapid inaccurate attacks'",
		onUse: `'HIT random foes 6 times'`,
		onHit: `'[STAT::amt]'`,
		onCrit:`'[STATUS::destabilized]'`
	},
	stats: {
		accuracy: .33,
		crit: 0.33,
		amt: 1,
		status: {
			destabilized: {
				name: 'destabilized',
				length: 1
			},
		},
	},
    exec: function(user, target, beingUsedAsync) {
        let initialRate = env.bgm.rate()

        if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
        play('click1')

        let targetTeam
        switch(user.team.name) {
            case "ally": targetTeam = env.rpg.enemyTeam; break;
            case "enemy": targetTeam = env.rpg.allyTeam; break;
        }

        let anim = env.COMBAT_ANIMS.shoot
        let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

        if(validTargets.length) for (let i = 0; i < 6; i++) {
            let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
            let animDelay = baseDelay + anim.duration;
            if(validTargets) {
                let target = validTargets.sample()
                
                setTimeout(()=>anim.exec(this, user, target), baseDelay)
                setTimeout(()=>{
                    env.GENERIC_ACTIONS.singleTarget({
                        action: this, 
                        user, 
                        target,
                        hitSfx: { name: "dull", volume: 0.5 },
                        critSfx: { name: "dull", rate: 0.75 },
                        missSfx: { name: "dull", rate: 1.5, volume: 0.5 },
                        hitStatus: {
                            name: 'destabilized',
                            length: 1
                        },
                    })
                }, animDelay)
            }
        }

        setTimeout(()=>{                
            if(!beingUsedAsync) advanceTurn(user)
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
        }, (env.ADVANCE_RATE * 0.2) * 7)
    }
}

env.ACTIONS.special_player_chant_weak = {
    slug: "special_player_chant_weak",
    name: "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ",
    type: 'special+summon',
    desc: "'â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ';'convey malignant thoughtforms via speech'",
    help: "FOES::60% -1HP, 15% x2 +1T:WEAKENED SUMMON::+1 HALLUCINATION (MAX:4)",
    anim: "orbshake",
    details: {
		flavor: "'â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ';'convey malignant thoughtforms via speech'",
		onHit: `'[STAT::amt]'`,
		onCrit:`'[STATUS::weakened]';'summon hallucination (max:4)'`,
	},
	stats: {
		accuracy: .5,
		crit: 0.1,
		amt: 1,
		selfHP: 1, //WHY does this not WORK ?????? fjiaW)AUR@JQ)_ITEO
		status: {
			fear: {
				name: 'fear',
				length: 2
			},
			puncture: {
				name: 'puncture',
				length: 1
			},
			weakened: {
				name: 'weakened',
				length: 1
			},
		},
	},
    usage: {
        act: "%USER â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ"
    },
    exec: function(user, target, beingUsedAsync) {
        let action = this

        env.GENERIC_ACTIONS.teamWave({
            team: user.enemyTeam,
            exec: (actor, i) => {
                env.GENERIC_ACTIONS.singleTarget({
                    action: action, 
                    user, 
                    target: actor,
                    hitSfx: { name: 'talksignal' },
                    critSfx: { name: 'fear', rate: 0.75 },
                    critStatus: {
                        name: 'weakened',
                        length: 1
                    },
                    critExec: ({target}) => {
                        user.lastSide = !user.lastSide
                        if(user.team.members.filter(m=>m.slug.includes('player_hallucination')).length < 4) {
                            midCombatAllyAdd('player_hallucination', user.lastSide ? "left" : "right")
                        }
                    }
                })
            },
            advanceAfterExec: true, beingUsedAsync, user,
        })
    }
}

env.ACTIONS.kivii_grasp_weak = {
    slug: "kivii_grasp_weak",
    name: "Blind Grasp",
    type: 'target',
    desc: "'attempt to immobilize and crush target';'leave open to attack'",
    anim: "basic-attack",
    help: "50% -1HP +1T:VULNERABLE, 15% x2 +2T:STUN",
    usage: {
        act: "%USER GRASPS AT %TARGET",
        crit: "%TARGET IS CRUSHED",
        hit: "%TARGET IS CAUGHT",
        miss: "%TARGET EVADES"
    },
    details: {
		flavor: "'attempt to immobilize and crush target';'leave open to attack'",
		onUse: `'[STAT::amt] [STAT::vulnerable]'`,
		onCrit: `'[STATUS::stun]'`,
	},
	stats: {
		accuracy: 0.5,
		crit: 0.15,
		amt: 1,
		status: {
			stun: { name: 'stun', length: 2 },
			vulnerable: { name: 'vulnerable', length: 1 },
		},
	},
    exec: function(user, target) {
        removeStatus(user, "windup")
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'hit',
                rate: 2
            },

            hitExec: ({target})=> {
                addStatus({target, status: "vulnerable", length: 1, noReact: true});
            },

            critExec: ({target})=>{
                addStatus({target, status: "stun", length: 2}); 
            }
        })
    }
}

env.ACTIONS.golemboss_strike = {
    slug: "golemboss_strike",
    name: "STRIKE",
    type: 'target',
    desc: "'swing gauntlet at target';'chance for immense physical trauma'",
    anim: "basic-attack",
    help: "60% -4HP +2T:VULNERABLE, 20%C x2 +1T:STUN",
    usage: {
        act: "%USER SWINGS AT %TARGET",
        crit: "%TARGET IS LAUNCHED BACKWARDS",
        hit: "%TARGET IS LEFT REELING",
        miss: "%TARGET EVADES BY A HAIR"
    },
    details: {
		flavor: "'swing gauntlet at target';'chance for immense physical trauma'",
		onUse: `'[STAT::amt] [STAT::vulnerable]'`,
		onCrit: `'[STATUS::stun]'`,
	},
	stats: {
		accuracy: 0.6,
		crit: 0.2,
		amt: 4,
		status: {
			stun: { name: 'stun', length: 1 },
			vulnerable: { name: 'vulnerable', length: 2 },
		},
	},
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitStatus: {
                name: 'vulnerable',
                length: 2
            },
            critStatus: {
                name: 'stun',
                length: 1
            },
        })
    }
}

env.ACTIONS.golemboss_advance = {
    slug: "golemboss_advance",
    name: "ADVANCE",
    type: 'target',
    desc: "'swing both gauntlets at target';'may inspire additional smashing'",
    anim: "basic-attack",
    help: "50% -1HP +1T:WEAKENED, 15%C USE THIS ACTION AGAIN",
    usage: {
        act: "%USER CHARGES AT %TARGET",
        crit: "%USER JUST KEEPS GOING",
        hit: "%TARGET IS CRUSHED",
        miss: "%TARGET EVADES"
    },
    details: {
		flavor: "'swing both gauntlets at target';'may inspire additional smashing'",
		onHit: `'[STAT::amt]'`,
		onCrit:`'[STATUS::weakened]';'use this action again'`,
	},
	stats: {
		accuracy: .5,
		crit: 0.15,
		amt: 1,
		status: {
			weakened: {
				name: 'weakened',
				length: 1
			}
		},
	},
    exec: function(user, target) {
        let action = this
        return env.GENERIC_ACTIONS.singleTarget({
            action, 
            user, 
            target,
            hitSfx: {
                name: 'stab',
                rate: 0.75
            },
            critSfx: {
                name: 'stab',
                rate: 1.0
            },

            hitExec: ({target}) => {
                addStatus({target, status: "weakened", length: 1});
            },

            critExec: ({target})=> {
                if(target.hp > 0 && target.state != "lastStand") {
                    env.setTimeout(()=>{
                        useAction(user, this, target, {beingUsedAsync: true, reason: "advance"})
                    }, 400)
                }
            }
        })
    }
}

env.ACTIONS.golemboss_guard = { //basically an enemy_shell vanity rename
    slug: "golemboss_guard",
    name: "GUARD",
    type: 'autohit',
    desc: "'raise gauntlets to make simple defense';'reduce incoming attacks'",
    anim: "heal",
    help: "+2T:CARAPACE -VULNERABLE",
    usage: {
        act: "%USER RAISES THEIR GAUNTLETS"
    },
	details: {
		flavor: `'raise gauntlets to form simple defense';'reduce incoming attacks'`,
		onUse: `'[STATUS::carapace]';'remove [STATUS::vulnerable]'`,
	},
	stats: {
		autohit: true,
		status: {
			carapace: {
				name: 'carapace',
				length: 3
			},
			spikes: {
				name: 'spikes',
				length: 3
			},
			vulnerable: {
				name: 'vulnerable',
				showReference: true
			}
		}
	},
    exec: function(user, target) {
        play('guard', 0.75);
        addStatus({target: user, status: "carapace", length: 2, noReact: true});
        removeStatus(user, "vulnerable") 
        return 'nothing';
    },
}

env.ACTIONS.golemboss_windup = {
    slug: "golemboss_windup",
    name: "WINDUP",
    type: 'autohit',
    desc: "'prepare devastating attack';'stay behind';'lose windup if attention diverted'",
    anim: "",
    help: "+WINDUP +2T:EVASION",
    usage: {
        act: "%USER PREPARES AN ATTACK..."
    },
	details: {
		flavor: "'prepare devastating attack';'stay behind';'lose windup if attention diverted'",
		onUse: `'[STATUS::windup] [STATUS::evasion]'`,
	},
	stats: {
		status: {
			evasion: {
				name: 'evasion',
				length: 2
			},
			windup: {
				name: 'windup',
				length: 1
			},
		},
	},
    noRepeat: true,
    exec: function(user, target) {
        play('dull', 1.5)
        addStatus({target: user, status: "evasion", length: 2, noReact: true}); 
        addStatus({target: user, status: "windup", length: 1}); 
        return 'nothing';
    }
}

env.ACTIONS.golemboss_strike_strong = {
    slug: "golemboss_strike_strong",
    name: "WINDUP::STRIKE",
    type: 'target',
    desc: "'swing gauntlet at target';'chance for immense physical trauma'",
    anim: "basic-attack",
    help: "90% -8HP +4T:VULNERABLE, 40%C x2 +2T:STUN",
    usage: {
        act: "%USER SWINGS AT %TARGET",
        crit: "%TARGET IS LAUNCHED BACKWARDS",
        hit: "%TARGET IS LEFT REELING",
        miss: "%TARGET EVADES BY A HAIR"
    },
    details: {
		flavor: "'swing gauntlet at target';'chance for immense physical trauma'",
		onUse: `'[STAT::amt] [STAT::vulnerable]'`,
		onCrit: `'[STATUS::stun]'`,
	},
	stats: {
		accuracy: 0.9,
		crit: 0.4,
		amt: 8,
		status: {
			stun: { name: 'stun', length: 2 },
			vulnerable: { name: 'vulnerable', length: 4 },
		},
	},
    exec: function(user, target) {
        removeStatus(user, "windup")
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'hit',
                rate: 0.75
            },
            hitStatus: {
                name: 'vulnerable',
                length: 4
            },
            critStatus: {
                name: 'stun',
                length: 2
            },
        })
    }
}

env.ACTIONS.golemboss_advance_strong = {
    slug: "golemboss_advance_strong",
    name: "WINDUP::ADVANCE",
    type: 'target',
    desc: "'swing both gauntlets at target';'may inspire additional smashing'",
    anim: "basic-attack",
    help: "80% -2HP +2T:WEAKENED, 30%C USE THIS ACTION AGAIN",
    usage: {
        act: "%USER CHARGES AT %TARGET",
        crit: "%USER JUST KEEPS GOING",
        hit: "%TARGET IS CRUSHED",
        miss: "%TARGET EVADES"
    },
    details: {
		flavor: "'swing both gauntlets at target';'may inspire additional smashing'",
		onHit: `'[STAT::amt]'`,
		onCrit:`'[STATUS::weakened]';'use this action again'`,
	},
	stats: {
		accuracy: .8,
		crit: 0.3,
		amt: 2,
		status: {
			weakened: {
				name: 'weakened',
				length: 2
			}
		},
	},
    exec: function(user, target) {
        removeStatus(user, "windup")
        let action = this
        return env.GENERIC_ACTIONS.singleTarget({
            action, 
            user, 
            target,
            hitSfx: {
                name: 'stab',
                rate: 0.6
            },
            critSfx: {
                name: 'stab',
                rate: 0.8
            },

            hitExec: ({target}) => {
                addStatus({target, status: "weakened", length: 1});
            },

            critExec: ({target})=> {
                if(target.hp > 0 && target.state != "lastStand") {
                    env.setTimeout(()=>{
                        useAction(user, this, target, {beingUsedAsync: true, reason: "advance"})
                    }, 400)
                }
            }
        })
    }
}

env.ACTIONS.golemboss_guard_strong = { //basically an enemy_shell vanity rename
    slug: "golemboss_guard_strong",
    name: "WINDUP::GUARD",
    type: 'autohit',
    desc: "'raise gauntlets to simple defense';'reduce incoming attacks'",
    anim: "heal",
    help: "+WINDUP +4T:CARAPACE, +2T:SPIKES -VULNERABLE",
    usage: {
        act: "%USER RAISES THEIR GAUNTLETS"
    },
	details: {
		flavor: `''raise gauntlets to form simple defense';'reduce incoming attacks'`,
		onUse: `'[STATUS::carapace] [STATUS::spikes]';'remove [STATUS::vulnerable]'`,
	},
	stats: {
		autohit: true,
		status: {
			carapace: {
				name: 'carapace',
				length: 4
			},

			spikes: {
				name: 'spikes',
				length: 2
			},

			vulnerable: {
				name: 'vulnerable',
				showReference: true,
			}
		}
	},
    exec: function(user, target) {
        play('guard', 0.75);
        addStatus({target: user, status: "carapace", length: 4, noReact: true});
        addStatus({target: user, status: "spikes", length: 2, noReact: true});
        removeStatus(user, "vulnerable") 
        return 'nothing';
    },
}

env.ACTIONS.golemboss_focused_strong = {
    slug: "golemboss_focused_strong",
    name: "WINDUP::FOCUS",
    type: 'autohit',
    desc: "'hold prepared attack';'look for opportunity'",
    anim: "",
    help: "+WINDUP +2T:EVASION +1T:FOCUSED -VULNERABLE -WEAKENED",
    usage: {
        act: "%USER WAITS FOR THE RIGHT MOMENT..."
    },
	details: {
		onUse: `'[STATUS::windup] [STATUS::evasion] [STATUS::focused]'`,
		flavor: "'hold prepared attack';'look for opportunity'"
	},
	stats: {
		status: {
			evasion: {
				name: 'evasion',
				length: 2
			},
			windup: {
				name: 'windup',
				length: 1
			},
			focused: {
				name: 'focused',
				length: 1
			},
		},
	}, 
    avoidChaining: true,
    exec: function(user, target) {
        play('dull', 1.0);
        addStatus({target: user, status: "windup", length: 1}); 
        addStatus({target: user, status: "evasion", length: 2, noReact: true}); 
        addStatus({target: user, status: "focused", length: 1, noReact: true});
        return 'nothing';
    }
}

// warped daemon actions

env.ACTIONS.revise_weak = {
    slug: "revise_weak",
    name: "Attempt Revision",
    type: 'target',
    desc: "'strike at foes and grasp beyond flesh';'corrupt beneficial statuses'",
    anim: "basic-attack",
    help: "40% -2HP, 10%C x2 + BENEFICIAL STATUS INVERSION",
    usage: {
        act: "%USER GRASPS BEYOND %TARGET",
        crit: "A FRIGHTENING BLOW",
        hit: "%TARGET FEELS SOMETHING TORN AWAY",
        miss: "%TARGET EVADES"
    },
    details: {
		flavor: "'strike at foes and grasp beyond flesh'",
		onHit: `'[STAT::amt]'`,
		onCrit:`'<em>invert target's beneficial statuses</em>'`,
	},
	stats: {
		accuracy: .4,
		crit: 0.1,
		amt: 2,
	},
    exec: function(user, target, beingUsedAsync) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'dull',
                rate: 1.25
            },

            critExec: ({target})=> {
                invertStatuses(target, (statusObj)=>statusObj.beneficial)
            }
        })
    }
}

env.ACTIONS.mad_claw_weak = {
    slug: "mad_claw_weak",
    name: "Clumsy Mad Claw",
    verb: "claw at",
    type: 'target',
    desc: "'utilize unpredictable weaponry';'guarantee of trauma'",
    anim: "basic-attack",
    help: "50% -2HP + ONE OF (+2T:DESTABILIZED, +2T:FEAR, +1T:STUN), 20%C x2",
    usage: {
        act: "%USER ATTACKS %TARGET",
        crit: "A FRIGHTENING BLOW",
        hit: "%TARGET IS STRUCK",
        miss: "%TARGET EVADES"
    },
    details: {
            flavor: "'utilize unpredictable weaponry';'guarantee of trauma'",
		onHit: `'[STAT::amt]';'inflict one of following';'[STATUS::destabilized]';'[STATUS::fear]';'[STATUS::stun]'`,
	},
	stats: {
		accuracy: .5,
		crit: 0.2,
		amt: 2,
		status: {
			destabilized: {
				name: 'destabilized',
				length: 2
			},
			fear: {
				name: 'fear',
				length: 2
			},
			stun: {
				name: 'stun',
				length: 1
			},
		},
	},
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'dull',
                rate: 1.25
            },
            hitExec: ({target})=> {
                let rand = Math.random()
                if(rand < 0.6) {
                    addStatus({target, origin: user, status: "destabilized", origin: user, length: 2}); 
                    
                } else if(rand < 0.8) {
                    addStatus({target, origin: user, status: "fear", origin: user, length: 2}); 

                } else {
                    addStatus({target, origin: user, status: "stun", origin: user, length: 1}); 
                }
            }
        })
    }
}

env.ACTIONS.cripple_weak = {
    slug: "cripple_weak",
    name: "Clumsy Cripple",
    type: 'target',
    desc: "'strike neural center of target to disorient';'chance to greatly weaken attacks'",
    anim: "basic-attack",
    help: "60% -2HP +1T:STUN, 40%C x2 +2T:WEAKENED",
    usage: {
        act: "%USER JABS AT %TARGET'S WEAPONRY",
        crit: "%TARGET IS CRIPPLED",
        hit: "%TARGET IS STRUCK",
        miss: "%TARGET EVADES"
    },
    details: {
		flavor: "'strike neural center of target';'guaranteed disorientation'",
		onHit: `'[STAT::amt] [STATUS::stun]'`,
		onCrit:`'[STATUS::weakened]'`,
	},
	stats: {
		accuracy: .6,
		crit: 0.4,
		amt: 2,
		status: {
			weakened: {
				name: 'weakened',
				length: 2
			},
			stun: {
				name: 'stun',
				length: 1
			}
		},
	},
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            critStatus: {
                name: 'weakened',
                length: 2
            },
            hitStatus: {
                name: 'stun',
                length: 1
            },
        })
    }
}

env.ACTIONS.exploit_weak = {
    slug: "exploit_weak",
    name: "Clumsy Exploit",
    type: 'target',
    desc: "'locate or take advantage of vulnerability in foe'",
    anim: "basic-attack",
    help: "60% -1HP, 20%C x2 +2T:VULNERABLE -EVASION\nADD::-1HP IF TARGET IS VULNERABLE",
    usage: {
        act: "%USER REACHES TOWARDS %TARGET",
        crit: "%TARGET FALLS APART",
        hit: "%TARGET'S FLESH MELTS AWAY",
        miss: "%TARGET RESISTS CONTROL"
    },
    details: {
		flavor: `'locate or take advantage of vulnerability in foe'`,
		onHit: `'[STAT::amt]'`,
		onCrit: `'[STATUS::vulnerable]'`,
		conditional: `<em>VS VULNERABLE::</em>'additional [STAT::amt]'`
	},
	stats: {
		accuracy: .6,
		crit: 0.2,
		amt: 1,
		status: {
			vulnerable: {
				name: 'vulnerable',
				length: 2
			},
		},
	},
    exec: function(user, target) {
        let amt = this.stats.amt

        if(hasStatus(target, "vulnerable")) {
            amt = this.stats.amt + 1
        }

        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            specialAmt: amt,
            user, 
            target,
            hitSfx: {
                name: 'destabilize',
                rate: 1.5
            },
            critStatus: {
                name: 'vulnerable',
                length: 2
            },
            critExec: ()=>{reactDialogue(user, `give_vulnerable`)}
        })
    }
}

env.ACTIONS.surge_weak = {
    slug: "surge_weak",
    name: "Lesser Surge",
    type: 'self+autohit+support',
    desc: "'charge forward without worry';'next action is taken twice'",
    anim: "",
    help: "+SURGE",
    usage: {
        act: "%USER IS ENERGIZED"
    },
	details: {
		onUse: () => `'[STATUS::surge]'`,
		flavor: "'charge forward without worry'"
	},

	stats: {
		status: {
			surge: {
				name: 'surge',
				length: 1
			},
			focused: {
				name: 'focused',
				length: 1
			},                
		}
	},
    beneficial: true,
    
    disableIf: (actor)=>{ if(hasStatus(actor,"fear")) return "PROHIBITED BY FEAR" },
    exec: function(user, target) {
        play("talkchoir7", 2)
        addStatus({target: user, status: "surge", length: 1, noReact: true})
        return 'nothing'
    }, 

    avoidChaining: true
}

env.ACTIONS.parasite_weak = {
    slug: "parasite_weak",
    name: "Clumsy Parasite",
    verb: "parasitize",
    type: 'target',
    desc: "'utilize modified repair tool';'tap vital corru of foes to sustain allies'",
    anim: "basic-attack",
    help: "50% -2HP +1T:SIPHON, 30%C x2 + (FOES::+2T:SIPHON)",
    usage: {
        act: "%USER GRASPS AT %TARGET",
        crit: "%TARGET'S TEAM IS INFESTED",
        hit: "%TARGET IS INFESTED",
        miss: "%TARGET DODGES"
    },
	details: {
		flavor: "'utilize modified repair tool';'tap vital corru of foes to sustain allies'",
		onHit: () => "'[STAT::amt] [STATUS::hitSiphon]'",
		onCrit: () => "'infest oppposing team with [STATUS::critSiphon]'",
	},
	stats: {
		accuracy: 5,
		crit: 0.3,
		amt: 2,
		status: {
			hitSiphon: {
				name: 'siphon',
				length: 1,
			},
			critSiphon: {
				name: 'siphon',
				length: 2,
			}
		}
	},
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'stab',
                rate: 0.75
            },
            hitExec: ({target})=> {
                addStatus({target, origin: user, status: "siphon", length: 1}); 
            },
            critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "siphon", length: 2}); 
                    play('status', 0.75);
                }
            })
        })
    }
}

env.ACTIONS.enforce_weak = {
    slug: "enforce_weak",
    name: "Clumsy Enforcement",
    type: 'target',
    desc: "'relentless assault with claws';'may inspire additional smashing'",
    anim: "basic-attack",
    help: "50% -1HP +1T:OPEN WOUND +1T:PUNCTURE, 15%C USE THIS ACTION AGAIN",
    usage: {
        act: "%USER STABS %TARGET",
        crit: "%USER JUST KEEPS GOING",
        hit: "%TARGET BLEEDS SLUDGY CORRU",
        miss: "%TARGET EVADES"
    },
    details: {
		flavor: "'relentless assault with positioning appendages';'may inspire additionals smashing'",
		onHit: `'[STAT::amt] [STATUS::puncture] [STATUS::open_wound]'`,
		onCrit:`'use this action again'`,
	},

	stats: {
		accuracy: .5,
		crit: 0.15,
		amt: 1,
		status: {
			puncture: {
				name: 'puncture',
				length: 1
			},
			open_wound: {
				name: 'open_wound',
				length: 1
			}
		},
	},
    exec: function(user, target) {
        let action = this
        return env.GENERIC_ACTIONS.singleTarget({
            action, 
            user, 
            target,
            hitSfx: {
                name: 'hit',
                rate: 0.7
            },
            critSfx: {
                name: 'hit',
                rate: 1.5
            },

            hitExec: ({target}) => {
                addStatus({target, status: "puncture", length: 1});
                addStatus({target, status: "open_wound", length: 1});
            },

            critExec: ({target})=> {
                if(target.hp > 0 && target.state != "lastStand") {
                    env.setTimeout(()=>{
                        useAction(user, this, target, {beingUsedAsync: true, reason: "enforcement"})
                    }, 400)
                }
            }
        })
    }
}

env.ACTIONS.special_rule_weak = {
    slug: "special_rule_weak",
    name: "Attempt Adjustment",
    type: 'special',
    desc: "'utilize status control to empower and repair team';'afflict opponents with critical vulnerability'",
    help: "+WINDUP, ALLIES::+1BP +REPAIRS +1T:EMPOWERED, FOES::50% -1HP +2T:VULNERABLE +CRITICAL FLAW",
    anim: "",
    details: {
		flavor: "'utilize status control to empower and repair team';'afflict opponents with critical vulnerability'",
		conditional: "<em>SELF::</em>[STATUS::windup]\n<em>ALLIES::</em>[STAT::amtBP] [STATUS::repairs]\n<em>FOES::</em>[STAT::amt] [STATUS::vulnerable] [STATUS::critical_flaw]",
	},
	stats: {
		accuracy: 0.5,
		crit: 0,
		amt: 1,
		amtBP: 1,
		status: {
			windup: {
				name: 'windup',
				length: 1
			},
			repairs: {
				name: 'repairs',
				length: 1
			},
			empowered: {
				name: 'empowered',
				length: 1
			},
			vulnerable : {
				name: 'vulnerable',
				length: 2
			},
			critical_flaw: {
				name: 'critical_flaw',
				length: 1
			},
		},
	},
    usage: {
        act: "%USER SHIFTS THE BALANCE"
    },
    exec: function(user, target, beingUsedAsync) {
        let action = this
        let allyTeam = user.team.name
        let enemyTeam = user.enemyTeam.name
        if(user.sprite) user.sprite.classList.add("basic-attack") 

        env.GENERIC_ACTIONS.teamWave({
            arbitraryActorList: env.rpg.turnOrder,
            extraDelay: 200,
            endCallback: () => {
                if(user.sprite) user.sprite.classList.remove("basic-attack")
                readoutAdd({
                    message: `${user.name} stays wound up!`, 
                    name: "sourceless", 
                    type: "sourceless combat minordetail", 
                    show: true,
                    forceMini: true,
                    sfx: false
                })
            },
            advanceAfterExec: true, beingUsedAsync, user,
            exec: (actor, i) => {
                if(actor.slug == user.slug) return;

                switch(actor.team.name) {
                    case allyTeam:
                        env.GENERIC_ACTIONS.singleTarget({
                            beneficial: true,
                            type: 'barrier',
                            action, 
                            user, 
                            target: actor,
                            canCrit: false,
                            hitSfx: {
                                name: 'mend',
                                rate: 2
                            },
                            hitStatus: {
                                name: 'repairs',
                                length: 1
                            },
                        })
                    break

                    case enemyTeam:
                        env.GENERIC_ACTIONS.singleTarget({
                            action: this, 
                            user, 
                            target: actor,
                            hitSfx: {
                                name: 'talkcroak',
                                rate: 2
                            },
                            canCrit: false,
                            hitExec: (target) => {
                                addStatus({origin: user, target: actor, status: "vulnerable", length: 2}); 
                                addStatus({origin: user, target: actor, status: "critical_flaw", length: 1}); 
                            }
                        })                            
                    break
                }
            }
        })
    }
}

env.ACTIONS.daemon_wound = {
    slug: "daemon_wound",
    name: "Wound",
    type: 'target',
    desc: "'focused attack on vitals';'increase pain of target'",
    anim: "basic-attack",
    help: "80% -3HP +4T:OPEN WOUND, 20%C x2 +2T:STUN",
    usage: {
        act: "%USER CHARGES %TARGET",
        crit: "%TARGET IS LEFT REELING",
        hit: "%TARGET IS STRUCK",
        miss: "%TARGET EVADES"
    },
    accuracy: 0.8,
    crit: 0.2,
    amt: 3,
    exec: function(user, target) {
        removeStatus(user, "windup")
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'stab',
                rate: 0.8
            },
            hitStatus: {
                name: 'open_wound',
                length: 4
            },
            critStatus: {
                name: 'stun',
                length: 2
            }
        })
    }
}

env.ACTIONS.special_judgement_weak = {
    slug: "special_judgement_weak",
    name: "Continuous Rewrite",
    type: 'special',
    desc: "'utilize thoughtspace influence to empower massive strike'",
    help: "+WINDUP, 70% -2HP, 30%C x2 +2T:DESTABILIZED +2T:FEAR",
    anim: "",
    details: {
		flavor: "'utilize thoughtspace influence to empower massive strike'",
		onUse: `'[STATUS::windup]';'HIT all foes'`,
		onHit: `'[STAT::amt]'`,
		onCrit: `'[STATUS::destabilized] [STATUS::fear]`
	},
	usage: {
		act: "%USER TURNS THE MEMORY AGAINST THEIR FOES"
	},
	stats: {
		accuracy: 7,
		crit: 0.3,
		amt: 2,
		 status: {
			windup: {
				name: 'windup',
				length: 2
			},
			destabilized: {
				name: 'destabilized',
				length: 2
			},
			fear: {
				name: 'fear',
				length: 2
			}, 
		}
	},
    exec: function(user, target, beingUsedAsync) {
        let action = this
        if(user.sprite) user.sprite.classList.add("basic-attack")

        env.GENERIC_ACTIONS.teamWave({
            team: user.enemyTeam,
            extraDelay: 150,
            endCallback: () => {
                if(user.sprite) user.sprite.classList.remove("basic-attack")
                readoutAdd({
                        message: `${user.name} stays wound up!`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: true,
                        forceMini: true,
                        sfx: false
                    })
                },
            exec: (actor, i) => {
                if(actor.slug == user.slug) return
                env.GENERIC_ACTIONS.singleTarget({
                    action, 
                    user, 
                    target: actor,
                    hitSfx: {
                        name: 'dull',
                        rate: 1
                    },
                    critExec: ({target})=>{
                        addStatus({target, origin: user, status: "destabilized", length: 2})
                        addStatus({target, origin: user, status: "fear", length: 2})
                    }                
                })
            },
            advanceAfterExec: true, beingUsedAsync, user,
        })
    }
}

env.ACTIONS.special_player_kiviisummon = {
    slug: "special_player_kiviisummon",
    name: "Retrieve Gauntlets",
    type: 'special+summon+nomimic',
    desc: "'collect additional allies from elsewhere'",
    help: "SUMMON::2 WARPED GAUNTLETS (MAX: 2 GAUNTLETS)",
    anim: "heal",
    details: {
		flavor: `'repossess gauntlets';'wield as improvised weapons'`,
		conditional: `<em>SUMMON::</em>'summon 2 warped gauntlets'`,
		onUse: `'remove this action'`
	},
	itemAction: true, //we have to lie here so that imps can't use this action
    noRepeat: true,
    exec: function(user, target) {
        actionMessage(user, "%USER DRAGS THEIR GAUNTLETS INTO POSITION", target, 'none', 2000);
        play('crit', 0.7, 0.9);
        
        //try to center the dude
        if(user.team.members.length == 14) {
            let uI = user.team.members.findIndex(a => a.slug == user.slug)
            if(uI < 3) midCombatAllyAdd('player_dull_kivii_gauntlet', 'left')
            else if(uI >= 3) midCombatAllyAdd('player_dull_kivii_gauntlet', 'right')
        } else {
            midCombatAllyAdd('player_dull_kivii_gauntlet', 'left')
            midCombatAllyAdd('player_dull_kivii_gauntlet', 'right')
        }
        user.actions = user.actions.filter(action => action !== "special_player_kiviisummon")
        setTimeout(()=>advanceTurn(user), 1000)
    }
}

env.ACTIONS.special_player_daemon_guard = {
    slug: "special_player_daemon_guard",
    name: "Idolatry",
    type: 'special',
    desc: "'intercept all attacks on allies';'prepare to take great damage'",
    help: "ALLIES::+3T:REDIRECTION (TO USER), +3T:CARAPACE +3T:SPIKES -VULNERABLE",
    anim: "basic-attack",
    accuracy: 1,
    crit: 0,
    usage: {
        act: "%USER BLESSES THEIR TEAM"
    },
    exec: function(user, target, beingUsedAsync) {
        reactDialogue(user, `give_redirection`)

        addStatus({target: user, status: "carapace", length: 3, noReact: true}); 
        addStatus({target: user, status: "spikes", length: 3}); 
        removeStatus(user, "vulnerable") 

        env.GENERIC_ACTIONS.teamWave({
            team: user.team,
            exec: (actor, i) => {
                if(actor.slug == user.slug) return
                addStatus({target: actor, origin: user, status: "redirection", length: 3}); 
                play('guard', 1.33, 0.6);
            },
            advanceAfterExec: true, beingUsedAsync, user,
        })
    }
}

env.ACTIONS.special_daemon_fullauto = {
    slug: "special_daemon_fullauto",
    name: "Full Auto",
    type: 'special',
    desc: "'utilize automatic rifle';'prioritize accuracy'",
    anim: "wobble",
    help: "x6 RANDOM ENEMY::75% -1HP 20%C -1HP +1T:VULNERABLE",
    usage: {
        act: "%USER OPENS FIRE",
    },
    accuracy: 0.75,
    crit: 0.2,
    amt: 1,
    exec: function(user, target, beingUsedAsync) {
        let initialRate = env.bgm.rate()

        if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
        play('click1')

        let targetTeam
        switch(user.team.name) {
            case "ally": targetTeam = env.rpg.enemyTeam; break;
            case "enemy": targetTeam = env.rpg.allyTeam; break;
        }

        let anim = env.COMBAT_ANIMS.shoot
        let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

        if(validTargets.length) for (let i = 0; i < 6; i++) {
            let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
            let animDelay = baseDelay + anim.duration;
            if(validTargets) {
                let target = validTargets.sample()
                
                setTimeout(()=>anim.exec(this, user, target), baseDelay)
                setTimeout(()=>{
                    env.GENERIC_ACTIONS.singleTarget({
                        action: this, 
                        user, 
                        target,
                        hitSfx: { name: "shot2", volume: 0.5 },
                        critSfx: { name: "shot6" },
                        missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
                        critStatus: {
                            name: 'vulnerable',
                            length: 1
                        },
                    })
                }, animDelay)
            }
        }

        setTimeout(()=>{                
            if(!beingUsedAsync) advanceTurn(user)
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
        }, (env.ADVANCE_RATE * 0.2) * 7)
    }
}

env.ACTIONS.daemon_windup = {
    slug: "daemon_windup",
    name: "Rev Up",
    type: 'autohit',
    desc: "'prepare devastating attack';'briefly lose defensive focus'",
    anim: "",
    help: "+WINDUP",
    usage: {
        act: "%USER PREPARES AN ATTACK..."
    },
    exec: function(user, target) {
        play('talklaugh', 0.5);
        addStatus({target: user, status: "windup", length: 1}); 
        return 'nothing';
    }
}

env.ACTIONS.special_daemon_fullerauto = {
    slug: "special_daemon_fullerauto",
    name: "Fuller Auto",
    type: 'special',
    desc: "'utilize automatic rifle';'greatly enhance rate of fire';'best paired with FLOOR IT'",
    anim: "wobble",
    help: "x12 RANDOM ENEMY::33% -1HP 33%C -1HP +1T:VULNERABLE",
    usage: {
        act: "%USER OPENS FIRE",
    },
    accuracy: 0.66,
    crit: 0.33,
    amt: 1,
    exec: function(user, target, beingUsedAsync) {
        let initialRate = env.bgm.rate()

        if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
        play('click1')

        let targetTeam
        switch(user.team.name) {
            case "ally": targetTeam = env.rpg.enemyTeam; break;
            case "enemy": targetTeam = env.rpg.allyTeam; break;
        }

        let anim = env.COMBAT_ANIMS.shoot
        let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

        if(validTargets.length) for (let i = 0; i < 12; i++) {
            let baseDelay = ((env.ADVANCE_RATE * 0.1) * i)
            let animDelay = baseDelay + anim.duration;
            if(validTargets) {
                let target = validTargets.sample()
                
                setTimeout(()=>anim.exec(this, user, target), baseDelay)
                setTimeout(()=>{
                    env.GENERIC_ACTIONS.singleTarget({
                        action: this, 
                        user, 
                        target,
                        hitSfx: { name: "shot2", volume: 0.5 },
                        critSfx: { name: "shot6" },
                        missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
                        critStatus: {
                            name: 'vulnerable',
                            length: 1
                        },
                    })
                }, animDelay)
            }
        }

        setTimeout(()=>{                
            if(!beingUsedAsync) advanceTurn(user)
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
        }, (env.ADVANCE_RATE * 0.2) * 13)
    }
}

env.ACTIONS.daemon_floor_it = {
    slug: "daemon_floor_it",
    name: "Floor It",
    type: 'support+target+self+autohit',
    desc: "'restore health and instill great energy';'heal over time';'cure puncture'",
    help: "AUTOHIT +1HP +2T:REGEN +FLOOR IT -PUNCTURE, 20%C +1HP",
    anim: "heal",
    usage: {
        act: "%USER FIXES UP %TARGET",
        crit: "%TARGET HAS A BURST OF ENERGY",
        hit: "%TARGET IS READY TO FIGHT",
        miss: "%TARGET IS TOO SLIPPERY"
    },
    crit: 0.2,
    amt: -1,
    autohit: true,
    beneficial: true,
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            beneficial: true,
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'mend',
                rate: 0.66
            },

            hitExec: ({target})=> {
                addStatus({target, origin: user, status: "regen", length: 2, noReact: true})
                addStatus({target, origin: user, status: "floor_it", length: 1, noReact: true})
            },
        })
    }
}

env.ACTIONS.daemon_cull = {
    slug: "daemon_cull",
    name: "Cull",
    type: 'support+target+self+autohit',
    desc: "'slight damage';'apply one effect from wide array of negative statuses';'best used by PROCESS'",
    help: "100% -1HP ONE OF (+2T:FEAR, +2T:VULNERABLE, +2T:WEAKENED, +2T:OPEN WOUND, +2T:SIPHON, +3T:PUNCTURE, +2T:DESTABILIZED, +1T:STUN), 10%C x2",
    anim: "basic-attack",
    usage: {
        act: "%USER REACHES BEYOND %TARGET",
        crit: "%TARGET FEELS WAY WORSE",
        hit: "%TARGET FEELS WORSE",
        miss: "%TARGET IS TOO SLIPPERY"
    },
    crit: 0.1,
    amt: 1,
    accuracy: 1,
    beneficial: true,
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            beneficial: false,
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'stab',
                rate: 2
            },
           hitExec: ({target})=> {
                let rand = Math.random()
                if(rand < 0.125) {
                    addStatus({target, origin: user, status: "fear", origin: user, length: 2}); 
                    
                } else if(rand < 0.25) {
                    addStatus({target, origin: user, status: "vulnerable", origin: user, length: 2}); 

                } else if(rand < 0.375) {
                    addStatus({target, origin: user, status: "weakened", origin: user, length: 2}); 

                } else if(rand < 0.5) {
                    addStatus({target, origin: user, status: "open_wound", origin: user, length: 2}); 

                } else if(rand < 0.625) {
                    addStatus({target, origin: user, status: "siphon", origin: user, length: 2}); 

                } else if(rand < 0.75) {
                    addStatus({target, origin: user, status: "puncture", origin: user, length: 3}); 

                } else if(rand < 0.875) {
                    addStatus({target, origin: user, status: "destabilized", origin: user, length: 2}); 

                } else {
                    addStatus({target, origin: user, status: "stun", origin: user, length: 1});
                }
            },
        })
    },
}

env.ACTIONS.daemon_tesselate = {
    slug: "daemon_tesselate",
    name: "Tesselate",
    type: 'support+target+self+autohit',
    desc: "'restore health';'apply one effect from wide array of beneficial statuses';'best used with RENDER'",
    help: "AUTOHIT +1HP ONE OF (+1T:FOCUSED, +2T:EVASION, +2T:EMPOWERED, +2T:CARAPACE, +2T:SPIKES, +3T:REGEN, +SURGE, +FLOOR IT), 10%C +1HP",
    anim: "heal",
    usage: {
        act: "%USER FIXES UP %TARGET",
        crit: "%TARGET FEELS WAY BETTER",
        hit: "%TARGET FEELS BETTER",
        miss: "%TARGET IS TOO SLIPPERY"
    },
    crit: 0.1,
    amt: -1,
    autohit: true,
    beneficial: true,
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            beneficial: true,
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'mend',
                rate: 2
            },
           hitExec: ({target})=> {
                let rand = Math.random()
                if(rand < 0.125) {
                    addStatus({target, origin: user, status: "focused", origin: user, length: 1}); 
                    
                } else if(rand < 0.25) {
                    addStatus({target, origin: user, status: "evasion", origin: user, length: 2}); 

                } else if(rand < 0.375) {
                    addStatus({target, origin: user, status: "empowered", origin: user, length: 2}); 

                } else if(rand < 0.5) {
                    addStatus({target, origin: user, status: "carapace", origin: user, length: 2}); 

                } else if(rand < 0.625) {
                    addStatus({target, origin: user, status: "spikes", origin: user, length: 2}); 

                } else if(rand < 0.75) {
                    addStatus({target, origin: user, status: "regen", origin: user, length: 3}); 

                } else if(rand < 0.875) {
                    addStatus({target, origin: user, status: "surge", origin: user, length: 1}); 

                } else {
                    addStatus({target, origin: user, status: "floor_it", origin: user, length: 1});
                }
            },
        })
    },
}

env.ACTIONS.daemon_plot = {
    slug: "daemon_plot",
    name: "Calculate",
    type: 'autohit',
    desc: "'hide vulnerability';'prepare great opportunity'",
    anim: "",
    help: "+8T:EVASION -VULNERABLE",
    usage: {
        act: "%USER WATCHES CAREFULLY"
    },
    
    exec: function(user, target) {
        play('mend', 0.5);
        addStatus({target: user, status: "evasion", length: 8, noReact: true});  
        return 'nothing';
    },

    disableIf: (actor)=>{ if(hasStatus(actor,"fear")) return "PROHIBITED BY FEAR" },
    avoidChaining: true
}

env.ACTIONS.special_daemon_enact_cpu = {
    slug: "special_daemon_enact_cpu",
    name: "Process",
    type: 'special',
    desc: "'finalize calculations';'unleash flurry of attacks upon foes'",
    anim: "basic-attack",
    verb: "render upon",
    help: "UTILIZE PRIMARY ON RANDOM FOES xT:EVASION TIMES, SELF::-EVASION",
    autohit: true,
    noRepeat: true,
    exec: function(user, target) {
            let amt = Math.floor(hasStatus(target, 'evasion'))
			let amt2 = 2 * Math.floor(hasStatus(target, 'evasion_mega'))
			let finalAmt = amt + amt2
            removeStatus(user, "evasion")
			removeStatus(user, "evasion_mega")
			let primary = env.ACTIONS[user.actions[0]]
			if (hasStatus(user, "windup")) (primary = env.ACTIONS[user.windupActions[0]])
            actionMessage(user, "%USER LAUNCHES THEIR ATTACK", target, 'none', 1000 + (finalAmt * 200))

            for (let i = 0; i < finalAmt; i++) {
                env.setTimeout(()=>{
                    let target = user.enemyTeam.members.filter(t=>t.state != "dead").sample()
                    if(target) useAction(user, primary, target, {triggerActionUseEvent: i == 0, beingUsedAsync: true, reason: "enact", noUseMessage: true})
                }, i * 200)
            }

            env.setTimeout(()=>{
                advanceTurn(user)
            }, (finalAmt * 200) + 500)
        },
    disableIf: (actor)=>{
			if(!hasStatus(actor,"evasion") && !hasStatus(actor,"evasion_mega")) return "REQUIRES EVASION/UNNATURAL SPEED" //check for if they have one of the two statuses, and let them through if they do
		}
}

env.ACTIONS.special_daemon_enact_gpu = {
    slug: "special_daemon_enact_gpu",
    name: "Render",
    type: 'special',
    desc: "'finalize calculations';'unleash flurry of buffs upon allies'",
    anim: "basic-attack",
    verb: "render upon",
    help: "UTILIZE PRIMARY ON RANDOM ALLIES xT:EVASION TIMES, SELF::-EVASION",
    autohit: true,
    noRepeat: true,
    exec: function(user, target) {
		let amt = Math.floor(hasStatus(target, 'evasion'))
		let amt2 = 2 * Math.floor(hasStatus(target, 'evasion_mega'))
		let finalAmt = amt + amt2
		removeStatus(user, "evasion")
		removeStatus(user, "evasion_mega")
		let primary = env.ACTIONS[user.actions[0]]
		if (hasStatus(user, "windup")) (primary = env.ACTIONS[user.windupActions[0]])
		actionMessage(user, "%USER LAUNCHES THEIR ATTACK", target, 'none', 1000 + (finalAmt * 200))

		for (let i = 0; i < finalAmt; i++) {
			env.setTimeout(()=>{
				let target = user.team.members.filter(t=>t.state != "dead").sample()
				if(target) useAction(user, primary, target, {triggerActionUseEvent: i == 0, beingUsedAsync: true, reason: "enact", noUseMessage: true})
			}, i * 200)
		}

		env.setTimeout(()=>{
			advanceTurn(user)
		}, (finalAmt * 200) + 500)
	},
	disableIf: (actor)=>{
		if(!hasStatus(actor,"evasion") && !hasStatus(actor,"evasion_mega")) return "REQUIRES EVASION/UNNATURAL SPEED" //check for if they have one of the two statuses, and let them through if they do
	}
}

    env.ACTIONS.special_greater_tesselate = {
        slug: "special_greater_tesselate",
        name: "Greater Tesselation",
        type: 'autohit+support',
        desc: "'restore health';'apply one effect from wide array of beneficial statuses';'best paired with SURGE'",
        anim: "",
        help: "ALLIES::AUTOHIT +2HP ONE OF (+2T:FOCUSED, +4T:EVASION, +4T:EMPOWERED, +4T:CARAPACE, +4T:SPIKES, +6T:REGEN, +SURGE, +FLOOR IT)",
        usage: {
            act: "%USER FIXES UP THEIR TEAM"
        },
        autohit: true,
		amt: -2,
        exec: function(user, target) {
            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i)=>{
					env.GENERIC_ACTIONS.singleTarget({
						action: this,
						user,
						target: actor,
						hitSfx: { name: 'mend' },
						exec: (actor, i)=>{
							let rand = Math.random()
							if(rand < 0.125) {
								addStatus({actor, origin: user, status: "focused", origin: user, length: 2}); 
								
							} else if(rand < 0.25) {
								addStatus({actor, origin: user, status: "evasion", origin: user, length: 4}); 

							} else if(rand < 0.375) {
								addStatus({actor, origin: user, status: "empowered", origin: user, length: 4}); 

							} else if(rand < 0.5) {
								addStatus({actor, origin: user, status: "carapace", origin: user, length: 4}); 

							} else if(rand < 0.625) {
								addStatus({actor, origin: user, status: "spikes", origin: user, length: 4}); 

							} else if(rand < 0.75) {
								addStatus({actor, origin: user, status: "regen", origin: user, length: 6}); 

							} else if(rand < 0.875) {
								addStatus({actor, origin: user, status: "surge", origin: user, length: 1}); 

							} else {
								addStatus({actor, origin: user, status: "floor_it", origin: user, length: 1});
							}
						}
                    })
                },
				advanceAfterExec: true, beingUsedAsync, user,
            })
            return 'nothing'
        }
    }

    env.ACTIONS.special_greater_cull = {
        slug: "special_greater_cull",
        name: "Greater Culling",
        type: 'autohit+special',
        desc: "'slight damage';'apply one effect from wide array of negative statuses';'best paired with SURGE'",
        anim: "",
        help: "'FOES::100% -2HP ONE OF (+4T:FEAR, +4T:VULNERABLE, +4T:WEAKENED, +4T:OPEN WOUND, +4T:SIPHON, +6T:PUNCTURE, +2T:STUN, +WEAK POINT)'",
        usage: {
            act: "%USER REACHES BEYOND THEIR FOES"
        },
        accuracy: 1,
		amt: 2,
        exec: function(user, target, beingUsedAsync) {
			let action = this;
            return env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
					env.GENERIC_ACTIONS.singleTarget({
						action,
						user,
						target: actor,
						hitSfx: { name: 'talksignal' },
						exec: (actor, i)=>{
							let rand = Math.random()
							if(rand < 0.125) {
								addStatus({target, origin: user, status: "fear", origin: user, length: 4}); 
							} else if(rand < 0.25) {
								addStatus({target, origin: user, status: "vulnerable", origin: user, length: 4}); 
							} else if(rand < 0.375) {
								addStatus({target, origin: user, status: "weakened", origin: user, length: 4}); 
							} else if(rand < 0.5) {
								addStatus({target, origin: user, status: "open_wound", origin: user, length: 4}); 
							} else if(rand < 0.625) {
								addStatus({target, origin: user, status: "siphon", origin: user, length: 4}); 
							} else if(rand < 0.75) {
								addStatus({target, origin: user, status: "puncture", origin: user, length: 6}); 
							} else if(rand < 0.875) {
								addStatus({target, origin: user, status: "stun", origin: user, length: 2}); 
							} else {
								addStatus({target, origin: user, status: "weak_point", origin: user, length: 1});
							}
						}
					})
                },
				advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    }

env.ACTIONS.rez_player = { 
    slug: "rez_player",
    name: "Unfair Advantage",
    type: 'support+target+self+rez+autohit',
    desc: "'repair ally to fighting condition';'used only as last resort'",
    help: "AUTOHIT +25%HP -DOWN",
    anim: "heal",
    usage: {
        act: "%USER FIXES UP %TARGET",
        crit: "%TARGET FEELS WAY BETTER",
        hit: "%TARGET FEELS BETTER",
        miss: "%TARGET IS TOO SLIPPERY"
    },
    details: {
		flavor: "'repair ally to fighting condition';'used only as last resort'",
		onUse: `'revive target at [STAT::percentage]%HP'`,
	},
	stats: {
		autohit: true,
		percentage: 25,
	},
    itemAction: true,
    exec: function(user, target) {
        return env.GENERIC_ACTIONS.singleTarget({
            beneficial: true,
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'mend',
                rate: 0.5
            },
            genExec: ({target})=>{
                if(target.state == "dead") {
                    target.hp = target.maxhp * 0.25
                    combatRevive(target)
                    reactDialogue(target, 'receive_rez')
                }
            }
        })
    },
}

env.ACTIONS.special_dullsummon_weak = {
    slug: "special_dullsummon_weak",
    name: "Risky Portal",
    type: 'special+summon+nomimic',
    desc: "'collect additional allies from elsewhere'",
    help: "SUMMON::2 DULL CONTAINER (MAX: 12 SUMMONS)",
    anim: "heal",
    details: {
		flavor: `'collect additional allies from elsewhere'`,
		onUse: `'[STATUS::destabilized]'`,
		conditional: `<em>SUMMON::</em>'summon 2 dull containers (max:7)'`
	},
	stats: {
		status: {
			destabilized: { name: 'destabilized', length: 2 }
		},
	},
	itemAction: true, //we have to lie here so that imps can't use this action
    exec: function(user, target) {
        actionMessage(user, "%USER CONJURES CONTAINERS VIA THE DULL", target, 'none', 2000);
        play('dull', 0.8, 1);
        
        //try to center the dude
        if(user.team.members.length == 14) {
            let uI = user.team.members.findIndex(a => a.slug == user.slug)
            if(uI < 3) midCombatAllyAdd('player_dull_container', 'left')
            else if(uI >= 3) midCombatAllyAdd('player_dull_container', 'right')
        } else {
            midCombatAllyAdd('player_dull_container', 'left')
            midCombatAllyAdd('player_dull_container', 'right')
        }
        addStatus({target: user, status: "destabilized", length: 2, noReact: true});

        setTimeout(()=>advanceTurn(user), 1000)
    },
    disableIf: (actor) => {if(actor.team.members.length > 15) return "TOO MANY ALLIES" }
}

    env.ACTIONS.special_chant_mega_weak = {
        slug: "special_chant_mega_weak",
        name: "New Process",
        type: 'special+summon',
        desc: "'remove resources from foes to create new daemon processes'",
        help: "FOES::70% -2HP, 20% x2 +1T:WEAKENED SUMMON::+1 HALLUCINATION (MAX:4)",
        anim: "spinny",
        details: {
            flavor: "'remove resources from foes to create new daemon processes'",
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::weakened]'`,
            conditional: `<em>SUMMON::</em>'+1 hallucination (max:4)'`
        },
        stats: {
            accuracy: .7,
            crit: 0.2,
            amt: 1,
            status: {
                weakened: {
                    name: 'weakened',
                    length: 1
                },
            },
        },
        usage: {
            act: "%USER DRAWS IN RESOURCES"
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this

            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action: action, 
                        user, 
                        target: actor,
                        hitSfx: { name: 'talksignal' },
                        critSfx: { name: 'fear', rate: 0.75 },
                        critStatus: {
                            name: 'weakened',
                            length: 1
                        },
                        critExec: ({target}) => {
                            user.lastSide = !user.lastSide
                            env.hallucinator = target.slug
                            if(user.team.members.filter(m=>m.slug.includes('player_critta_spawner_bee')).length < 4) {
                                midCombatAllyAdd('player_critta_spawner_bee', user.lastSide ? "left" : "right")
                            }
                        }
                    })
                    
                }, 
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },

    env.ACTIONS.daemon_smash = {
        slug: "daemon_smash",
        name: "Deleterious Strike",
        type: 'target',
        desc: "'focused, deadly attack upon one target';'attempt to remove target from memory'",
        anim: "basic-attack",
        help: "100% -5HP, 50% x2 +2T:STUN +10T:ROT +4T:DESTABILIZED +4T:VULNERABLE +4T:FEAR +CRITICAL FLAW +MADNESS",
        usage: {
            act: "%USER CHARGES %TARGET",
            crit: "%TARGET IS FADES FROM MEMORY",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET EVADES"
        },
        accuracy: 1,
        crit: 0.5,
        amt: 5,
        exec: function(user, target) {
            removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'dull',
                    rate: 0.75
                },
                critExec: ({target})=> {
                    addStatus({target, origin: user, status: "stun", length: 2})
                    addStatus({target, origin: user, status: "rot", length: 10, noReact: true})
					addStatus({target, origin: user, status: "fear", length: 4, noReact: true})
					addStatus({target, origin: user, status: "madness", length: 1, noReact: true})
                    addStatus({target, origin: user, status: "vulnerable", length: 4, noReact: true})
                    addStatus({target, origin: user, status: "critical_flaw", length: 1, noReact: true})
                }
            })
        }
    },
	//warped actions end here
	
	//metal summon actions
    env.ACTIONS.special_barrier_allies_player = { //god damn it why does the if sprite line break if the user doesn't have a sprite >:(
        slug: "special_barrier_allies_player",
        name: "Cover",
        type: 'special',
        desc: "'apply ablative protection'",
        help: "ALLIES::+2 BP",
        anim: "cloak-barrier",
        details: {
            flavor: `'utilize mobile applicators and inbuilt reserve';'apply ablative corru shielding'`,
            onUse: () => `'[STAT::amtBP] ${env?.rpg?.is2D ? "[STATUS::repairs]" : ''} to nearby allies'`, // corru what . why is this how it works
        },
        stats: {
            autohit: true,
            crit: 0,
            amt: 2,
            amtBP: 2,
            range: -1,

            status: {
                repairs: {
                    name: "repairs",
                    length: 1
                }
            },

            extraAOE: {
                barrier: {
                    origin: "self", // primarily used to display range effects rather than in actual attacking/calculation
                    size: 2,
                    shape: 'square',
                    addClass: "beneficial" // added to tiles when displaying range
                }
            }
        },
        usage: {
            act: "%USER SHIELDS THEIR ALLIES"
        },
        beneficial: true,
        exec: function(user, target, beingUsedAsync) {
            let action = this

            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        beneficial: true,
                        type: 'barrier',
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'mend',
                            rate: 2
                        },
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        },
        
        //disable if you're an enemy and anyone on your team has more than 5 bp
        //also if you're an enemy and you're the last standing
        //mainly to avoid repeat/infinite stacking while dealing with a crowd
        disableIf: (actor)=>{
            if(actor.team.name == "ally") return false;
            else if(!actor.team.members.some(member => ((member != actor) && (member.state != "dead") ))) return true;
            else return actor.team.members.some(member => ((member != actor) && member.bp >= 5))
        }
    },
	
	env.ACTIONS.windup_winderup = {
        slug: "windup_winderup",
        name: "Second Preparation",
        type: 'autohit',
        desc: "'continue to prepare devastating attack';'briefly lose defensive focus'",
        anim: "",
        help: "+WINDUP+",
        usage: {
            act: "%USER PREPARES AN ATTACK..."
        },
		details: {
            flavor: `'escalate preparations'`,
            onUse: `'[STATUS::winderup]'`
        },
        stats: {
            status: {
                winderup: {
                    name: 'winderup',
                    length: 1
                },            
            }
        },
        exec: function(user, target) {
            play('talklaugh', 0.45);
			removeStatus(user, "windup")
            addStatus({target: user, status: "winderup", length: 1}); 
            return 'nothing';
        }
    },
	
	env.ACTIONS.windup_windestup = {
        slug: "windup_windestup",
        name: "Third Preparation",
        type: 'autohit',
        desc: "'continue to prepare devastating attack';'briefly lose defensive focus'",
        anim: "",
        help: "+WINDUP+",
        usage: {
            act: "%USER PREPARES AN ATTACK..."
        },
		details: {
            flavor: `'escalate preparations further still'`,
            onUse: `'[STATUS::windestup]'`
        },
        stats: {
            status: {
                windestup: {
                    name: 'windestup',
                    length: 1
                },            
            }
        },
        exec: function(user, target) {
            play('talklaugh', 0.40);
			removeStatus(user, "winderup")
            addStatus({target: user, status: "windestup", length: 1}); 
            return 'nothing';
        }
    },
	
	env.ACTIONS.windup_final_windup = {
        slug: "windup_final_windup",
        name: "Final Preparation",
        type: 'autohit',
        desc: "'continue to prepare devastating attack';'briefly lose defensive focus'",
        anim: "",
        help: "+WINDUP+",
        usage: {
            act: "%USER PREPARES AN ATTACK..."
        },
		details: {
            flavor: `'finalize preparations';'brace for devastation'`,
            onUse: `'[STATUS::final_windup]'`
        },
        stats: {
            status: {
                final_windup: {
                    name: 'final_windup',
                    length: 1
                },            
            }
        },
        exec: function(user, target) {
            play('talklaugh', 0.35);
			removeStatus(user, "windestup")
            addStatus({target: user, status: "final_windup", length: 1}); 
            return 'nothing';
        }
    },
	
	env.ACTIONS.focused_winderup = {
        slug: "focused_winderup",
        name: "Extra Preparation",
        type: 'autohit',
        anim: "",
        usage: {
            act: "%USER WAITS FOR THE RIGHT MOMENT..."
        },
        details: {
            onUse: `'[STATUS::winderup] [STATUS::evasion] [STATUS::focused]'`,
            flavor: "'hold prepared attack';'look for opportunity'"
        },
        stats: {
            status: {
                evasion: {
                    name: 'evasion',
                    length: 1
                },
                winderup: {
                    name: 'winderup',
                    length: 1
                },
                focused: {
                    name: 'focused',
                    length: 1
                },
            },
        }, 
        
        avoidChaining: true,
        exec: function(user, target) {
            play('talklaugh', 0.45);
            addStatus({target: user, status: "winderup", length: 1}); 
            addStatus({target: user, status: "evasion", length: 1, noReact: true}); 
            addStatus({target: user, status: "focused", length: 1, noReact: true});
            return 'nothing';
        }
    },
	
	env.ACTIONS.focused_windestup = {
        slug: "focused_windestup",
        name: "Extra Preparation",
        type: 'autohit',
        anim: "",
        usage: {
            act: "%USER WAITS FOR THE RIGHT MOMENT..."
        },
        details: {
            onUse: `'[STATUS::windestup] [STATUS::evasion] [STATUS::focused]'`,
            flavor: "'hold prepared attack';'look for opportunity'"
        },
        stats: {
            status: {
                evasion: {
                    name: 'evasion',
                    length: 1
                },
                windestup: {
                    name: 'windestup',
                    length: 1
                },
                focused: {
                    name: 'focused',
                    length: 1
                },
            },
        }, 
        
        avoidChaining: true,
        exec: function(user, target) {
            play('talklaugh', 0.4);
            addStatus({target: user, status: "windestup", length: 1}); 
            addStatus({target: user, status: "evasion", length: 1, noReact: true}); 
            addStatus({target: user, status: "focused", length: 1, noReact: true});
            return 'nothing';
        }
    },
	
	env.ACTIONS.focused_final_windup = {
        slug: "focused_final_windup",
        name: "Extra Preparation",
        type: 'autohit',
        anim: "",
        usage: {
            act: "%USER WAITS FOR THE RIGHT MOMENT..."
        },
        details: {
            onUse: `'[STATUS::final_windup] [STATUS::evasion] [STATUS::focused]'`,
            flavor: "'hold prepared attack';'look for opportunity'"
        },
        stats: {
            status: {
                evasion: {
                    name: 'evasion',
                    length: 1
                },
                final_windup: {
                    name: 'final_windup',
                    length: 1
                },
                focused: {
                    name: 'focused',
                    length: 1
                },
            },
        }, 
        
        avoidChaining: true,
        exec: function(user, target) {
            play('talklaugh', 0.35);
            addStatus({target: user, status: "final_windup", length: 1}); 
            addStatus({target: user, status: "evasion", length: 1, noReact: true}); 
            addStatus({target: user, status: "focused", length: 1, noReact: true});
            return 'nothing';
        }
    },

	env.ACTIONS.berserk_mega_golem = {
        slug: "berserk_mega_golem",
        name: "Taunt",
        type: 'autohit',
        desc: "'self-modify for maximum offense';'tempt foes into striking recklessly'",
        help: "+1T:DENATURED +2T:SERRATIONS -VULNERABLE",
        anim: "heal",
        usage: {
            act: "%USER MELTS INTO A MORE AGGRESSIVE SHAPE"
        },
		details: {
            flavor: "'self-modify for maximum offense';;'tempt foes into striking recklessly'",
            onUse: "'[STATUS::denatured] [STATUS::serrations] -[STATUS::vulnerable]'"
        },
        stats: {
            status: {
                denatured: { name: 'denatured', length: 1 },
                serrations: { name: 'serrations', length: 2 },
				vulnerable: { name: 'vulnerable', showReference: true },
            }
        },
        
        exec: function(user, target) {
            play('destabilize', 0.5);
            removeStatus(user, "vulnerable"); 
			removeStatus(user, "windup"); 
            addStatus({target: user, status: "denatured", length: 1, noReact: true}); 
            addStatus({target: user, status: "serrations", length: 2, noReact: true}); 
            return 'nothing';
        }
    },

    env.ACTIONS.special_self_destruct_mega = {
        slug: "special_self_destruct_mega",
        name: "Self Destruct",
        type: 'special',
        desc: "'form shrapnel in body';'propel through unsustainable means'",
        help: "FOES::70% -2HP +2T:PUNCTURE, 20%C x2 +1T:OPEN WOUND\nSELF::-1HP",
        anim: "explode",
        details: {
			flavor: `'form shrapnel in body';'propel through unsustainable means'`,
			onUse: `'HIT all foes';'[STAT::selfHP] to self'`,
			onHit: `'[STAT::amt] [STATUS::puncture]'`,
			onCrit: `'[STATUS::open_wound]'`
		},

		stats: {
			accuracy: 0.7,
			crit: 0.2,
			amt: 2,
			selfHP: 1,
			status: {
				open_wound: { name: 'open_wound', length: 1 },
				puncture: { name: 'puncture', length: 2 }
			}
		},
        usage: {
            act: "%USER JUST EXPLODES"
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup")
            let action = this
            play('shot5', 0.6)
            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action: action, 
                        user, 
                        target: actor,
                        hitSfx: {
							name: 'shot2', 
							rate: 0.75
							},
                        critSfx: {
							name: 'shot6',
							rate: 0.75
							},
						hitStatus: {
							name: 'puncture',
							length: 2
						},
                        critStatus: {
                            name: 'open_wound',
                            length: 1
                        },
                    })

                    combatHit(user, {amt: 1, autohit: true, crit: 0, origin: user, redirectable: false, runEvents: false})
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },

	env.ACTIONS.foe_stab_metal = {
        slug: "foe_stab_metal",
        name: "Eviscerate",
        type: 'target',
        desc: "'puncture vital cystic component';'damage over time';'stop regen'",
        help: "80% -3HP +4T:PUNCTURE -REGEN, 20%C x2 +4T:PUNCTURE, ONE OF (+2T:OPEN WOUND, +2T:WEAKENED, +1T:STUN)",
        anim: "basic-attack",
        usage: {
            act: "%USER STABS %TARGET",
            crit: "%TARGET IS EVISCERATED",
            hit: "%TARGET BLEEDS SLUDGY CORRU",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'puncture vital cystic component'",
            onHit: `'[STAT::amt] [STATUS::puncture]'`,
            onCrit:`'additional [STATUS::puncture]';'inflict one of following';'[STATUS::open_wound]';'[STATUS::weakened]';'[STATUS::stun]'`,
        },
        stats: {
            accuracy: .8,
            crit: 0.2,
            amt: 3,
            status: {
                weakened: {
                    name: 'weakened',
                    length: 2
                },
                puncture: {
                    name: 'puncture',
                    length: 4
                },
                open_wound: {
                    name: 'open_wound',
                    length: 2
                },
				stun: {
                    name: 'stun',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
			removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'stab',
                    rate: 0.75
                },
                hitStatus: {
					name: 'puncture',
					length: 4
				},
                critExec: ({target})=> {
					addStatus({target, origin: user, status: "puncture", length: 4});
					let rand = Math.random()
                    if(rand < 0.3) {
                        addStatus({target, origin: user, status: "open_wound", origin: user, length: 2}); 
                    } else if(rand < 0.6) {
                        addStatus({target, origin: user, status: "weakened", origin: user, length: 2}); 
                    } else {
                        addStatus({target, origin: user, status: "stun", origin: user, length: 1}); 
                    }
				},
            })
        }
    }

	env.ACTIONS.attack_smash = {
        slug: "attack_smash",
        name: "Smash",
        type: 'target',
        desc: "'improvised strike';'may accidentally cause immense damage'",
        anim: "basic-attack",
        help: "100% -4HP, 20%C x2",
        usage: {
            act: "%USER CHARGES %TARGET",
            crit: "%TARGET IS LEFT REELING",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'improvised strike';'may accidentally cause immense damage'",
            onHit: `'[STAT::amt]'`,
        },
        stats: {
			accuracy: 1,
            crit: 0.4,
            amt: 4,
            status: {
                stun: {
                    name: 'stun',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
            removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'hit',
                    rate: 0.75
                }
            })
        }
    }
	
	env.ACTIONS.barrier_mega = {
        slug: "barrier_mega",
        name: "Barrier",
        verb: "shield",
        type: 'support+target+self+autohit',
        desc: "'apply ablative corru layer'",
        help: "AUTOHIT +5BP, 10%C +5BP",
        anim: "heal",
        usage: {
            act: "%USER SHIELDS %TARGET",
            crit: "%TARGET FEELS INVINCIBLE",
            hit: "%TARGET GAINS A BARRIER",
            miss: "IT DOES NOT STICK"
        },
        details: {
            flavor: "apply ablative corru layer to target';'occasionally provide better shielding'",
            onHit: `'[STAT::amtBP]'`,
            onCrit: `'additional [STAT::amtBP]'`,
        },
        stats: {
			autohit: true,
            crit: 0.1,
            amt: 5,
            amtBP: 5
        },
        exec: function(user, target) {
			removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                beneficial: true,
                type: 'barrier',
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'mend',
                    rate: 1.25
                },
            })
        }
    }
	
	env.ACTIONS.ultra_spy_analyze = {
        slug: "ultra_spy_analyze",
        name: "Depth Scan",
        verb: "scan",
        type: 'target',
        desc: "'expose extreme enemy weakness';'increase hit and crit chances';'additional chance for severe damage'",
        help: "AUTOHIT +3T:VULNERABLE +CRITICAL FLAW -EVASION",
        anim: "spying",
        frameClass: "temp-perspective",
        animDuration: 2000,
        usage: {
            act: "%USER SPIES UPON %TARGET",
            crit: "%TARGET IS MARKED FOR DEATH",
            hit: "%TARGET IS MARKED FOR DEATH",
            miss: "%TARGET HIDES BEHIND SOMETHING"
        },
        details: {
            flavor: `'locate core components in target'`,
            onHit: "'[STATUS::vulnerable] [STATUS::critical_flaw]'",
        },
        stats: {
			autohit: true,
			canCrit: false,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 3
                },
                critical_flaw: {
                    name: 'critical_flaw',
                    length: 1
                }
            }
        },
        exec: function(user, target) {
			removeStatus(user, "windup")
            reactDialogue(user, `give_vulnerable`)
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'status',
                    rate: 0.75
                },
                genExec: () => {
                    addStatus({origin: user, target, status: "vulnerable", length: 3}); 
                    addStatus({origin: user, target, status: "critical_flaw", length: 1}); 
                }
            })
        }
    }

	env.ACTIONS.special_limited_carapace_bonus = {
        slug: "special_limited_carapace_bonus",
        name: "Expend carapace",
        type: 'support+target+autohit',
        desc: "'deploy shielding around target ally';'single-use'",
        help: "AUTOHIT +6T:CARAPACE +6T:SPIKES, ONE USE PER COMBAT",
        anim: "heal",
        usage: {
            act: "%USER ATTACHES THEIR SHIELDS TO %TARGET",
            crit: "%TARGET FEELS INVINCIBLE",
            hit: "%TARGET LOOKS MORE HARDY",
            miss: "SOMETHING BROKE LOL"
        },
		details: {
            flavor: `'deploy shielding around target ally';'single-use'`,
            onUse: `'[STATUS::carapace] [STATUS::spikes]';'remove this action'`,
        },
        stats: {
            autohit: true,
            status: {
                carapace: {
                    name: 'carapace',
                    length: 6
                },

                spikes: {
                    name: 'spikes',
                    length: 6
                },

                vulnerable: {
                    name: 'vulnerable'
                }
            }
        },
        autohit: true,
        exec: function(user, target) {
			removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                beneficial: true,
                user, 
                target,
                hitSfx: {
                    name: 'status',
                    rate: 0.75
                },
                hitExec: ({target})=>{
                    addStatus({target, status: "carapace", length: 6, noReact: true});
					addStatus({target, status: "spikes", length: 6, noReact: true});
                },
                genExec: ({user})=>{
                    user.windupActions = user.windupActions.filter(action => action !== "special_limited_carapace_bonus")
                    if(user.sprite) {
                        let bodySprite = user.sprite.querySelector('.golemsprite-body')
                        if(bodySprite) bodySprite.src = bodySprite.src.replace('-body','-body-used')
                    }
                }
            })
        }
    }
	
	env.ACTIONS.special_restorative_barrier_metal = { //basically a vanity rename
        slug: "special_restorative_barrier_metal",
        name: "Mending Cover",
        type: 'special',
        desc: "'apply ablative protection';'upgrades protection to passively repair'",
        help: "ALLIES::+2 BP +REPAIRS",
        anim: "cloak-barrier",
        details: {
            flavor: "'broadly apply ablative protection';'upgraded barrier mends wounds while active'",
            onUse: `'[STAT::amtBP] [STATUS::repairs] to nearby allies'`,
        },
        stats: {
			autohit: true,
            crit: 0,
            amtBP: 2,
            amt: 2,
            status: { 
                repairs: {
                    name: 'repairs', 
                    length: 1
                },
            } 
        },
        usage: {
            act: "%USER SHIELDS THEIR ALLIES"
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup")
            let action = this

            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        beneficial: true,
                        type: 'barrier',
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'mend',
                            rate: 2
                        },
                        hitStatus: {
                            name: 'repairs',
                            length: 1
                        },
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    }
	
	env.ACTIONS.stab_metal = {
        slug: "stab_metal",
        name: "Eviscerate",
        type: 'target',
        desc: "'puncture vital cystic component';'damage over time';'stop regen'",
        help: "100% -3HP +4T:PUNCTURE -REGEN, 20%C x2 +4T:PUNCTURE, ONE OF (+2T:OPEN WOUND, +2T:WEAKENED, +1T:STUN)",
        anim: "basic-attack",
        usage: {
            act: "%USER STABS %TARGET",
            crit: "%TARGET IS EVISCERATED",
            hit: "%TARGET BLEEDS SLUDGY CORRU",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'puncture vital cystic component'",
            onHit: `'[STAT::amt] [STATUS::puncture]'`,
            onCrit:`'additional [STATUS::puncture]';'inflict one of following';'[STATUS::open_wound]';'[STATUS::weakened]';'[STATUS::stun]'`,
        },
        stats: {
            accuracy: 1,
            crit: 0.2,
            amt: 3,
            status: {
                weakened: {
                    name: 'weakened',
                    length: 2
                },
                puncture: {
                    name: 'puncture',
                    length: 4
                },
                open_wound: {
                    name: 'open_wound',
                    length: 2
                },
				stun: {
                    name: 'stun',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
			removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'stab',
                    rate: 0.75
                },
                hitStatus: {
					name: 'puncture',
					length: 4
				},
                critExec: ({target})=> {
					addStatus({target, origin: user, status: "puncture", length: 4});
					let rand = Math.random()
                    if(rand < 0.3) {
                        addStatus({target, origin: user, status: "open_wound", origin: user, length: 2}); 
                        
                    } else if(rand < 0.6) {
                        addStatus({target, origin: user, status: "weakened", origin: user, length: 2}); 

                    } else {
                        addStatus({target, origin: user, status: "stun", origin: user, length: 1}); 
                    }
				},
            })
        }
    }
	
	env.ACTIONS.cripple_metal = {
        slug: "cripple_metal",
        name: "Neural Strike",
        type: 'target',
        desc: "'strike neural center of target to disorient';'chance to greatly weaken attacks'",
        anim: "basic-attack",
        help: "100% -3HP +1T:STUN, 40%C x2 +4T:WEAKENED",
        usage: {
            act: "%USER JABS AT %TARGET'S WEAPONRY",
            crit: "%TARGET IS CRIPPLED",
            hit: "%TARGET IS PARALYZED",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'strike neural center of target';'guaranteed disorientation'",
            onHit: `'[STAT::amt] [STATUS::stun]'`,
            onCrit:`'[STATUS::weakened]'`,
        },
        stats: {
            accuracy: 1,
            crit: 0.4,
            amt: 3,
            status: {
                weakened: {
                    name: 'weakened',
                    length: 4
                },
                stun: {
                    name: 'stun',
                    length: 2
                }
            },
        },
        exec: function(user, target) {
			removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
				hitSfx: {
					name: 'hit',
					rate: 0.75
				},
                critStatus: {
                    name: 'weakened',
                    length: 4
                },
                hitStatus: {
                    name: 'stun',
                    length: 2
                },
            })
        }
    }

    env.ACTIONS.special_guard_all_metal = {
        slug: "special_guard_all_metal",
        name: "Frontline",
        type: 'special',
        desc: "'attain hyper-awareness of proceedings';'intercept all attacks on allies'",
        help: "ALLIES::+4T:REDIRECTION (TO USER)",
        anim: "basic-attack",
        details: {
            flavor: "'attain hyper-awareness of proceedings';'intercept all attacks on allies'",
            onUse: `'[STATUS::redirection] to all allies'`,
        },
        stats: {
            status: {
                redirection: {
                    name: 'redirection',
                    length: 3
                },
            },
        },
        usage: {
            act: "%USER STANDS BEFORE THEIR FOES"
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup")
            reactDialogue(user, `give_redirection`)
            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
                    if(actor.slug == user.slug) return
                    addStatus({target: actor, origin: user, status: "redirection", length: 3}); 
                    play('guard', 2, 0.75);
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    }
	
	env.ACTIONS.mend_metal = {
        slug: "mend_metal",
        name: "Mend",
        type: 'support+target+self+autohit',
        desc: "'restore health';'heal over time';'cure puncture'",
        help: "AUTOHIT +4HP +5T:REGEN -PUNCTURE, 10%C x2",
        anim: "heal",
        usage: {
            act: "%USER FIXES UP %TARGET",
            crit: "%TARGET FEELS WAY BETTER",
            hit: "%TARGET FEELS BETTER",
            miss: "%TARGET IS TOO SLIPPERY"
        },
        details: {
            onHit: `'[STAT::amt] [STATUS::regen]'`,
        },
        stats: {
            range: 2,
            crit: 0.1,
            autohit: true,
            amt: -4,
            status: {
                regen: {
                    name: 'regen',
                    length: 5
                }
            }
        },
        beneficial: true,
        exec: function(user, target) {
			removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                beneficial: true,
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'mend',
                    rate: 0.75
                },
                hitStatus: {
                    name: 'regen',
                    length: 5
                },
            })
        },

        avoidChaining: true,
        disableIf: (actor) => {
            return (
                actor.team.name == "enemy" &&
                !actor.team.members.some(member => ((member != actor) && (member.state != "dead") ))
            )
        }
    }
	
	env.ACTIONS.tozik_attack_metal = {
        slug: "tozik_attack_metal",
        name: "Vivisect",
        type: 'target',
        desc: "'utilize golem repair tool as weapon';'chance to drain corru for health'",
        anim: "basic-attack",
        help: "100% -2HP +2T:PUNCTURE, 30%C x2 + (ALLIES::+2HP +2T:REGEN)",
        usage: {
            act: "%USER CLAWS AT %TARGET",
            crit: "%TARGET'S LIFE IS DRAINED AWAY",
            hit: "%TARGET IS BADLY SLASHED",
            miss: "%TARGET DODGES"
        },
		details: {
            flavor: `'attack with golem repair tool';'siphon vital corru'`,
            onHit: `'[STAT::amt]'`,
            onCrit: `'heal nearby allies for [STAT::healHP] [STATUS::regen]'`,
        },
        stats: { // 'base' stats used to modify effective stats. can coexist with legacy stats
            accuracy: 1, 
            crit: 0.3,
            amt: 2,
            healHP: -2,
            range: 2,
            status: {
                regen: {
                    name: 'regen',
                    length: 2
                }
            },

            extraAOE: {
                regenAura: {
                    origin: "self", // primarily used to display range effects rather than in actual attacking/calculation
                    size: 2,
                    shape: 'square',
                    addClass: "beneficial" // added to tiles when displaying range
                }
            }
        },
        exec: function(user, target) {
			removeStatus(user, "windup")
            if(env.rpg.classList.contains("tutorialgolem")) change("PAGE!!earlytoz", true)

            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'stab',
                    rate: 1
                },

                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.team,
                    exec: (actor, i)=>{
                        combatHit(actor, {amt: -2, origin: user, autohit: true, beneficial: true});
                        addStatus({target: actor, origin: user, status: "regen", length: 2});
                        play('mend')
                    }
                })
            })
        }
    }

    env.ACTIONS.restore_metal = { 
        slug: "restore_metal",
        name: "Restore",
        type: 'support+target+self+rez+autohit',
        desc: "'restore health';'cure puncture';'repair downed target'",
        help: "AUTOHIT +5HP +3T:REGEN -PUNCTURE + (DOWNED: -DOWN, +2T:EVASION), 10%C +5HP +3T:REGEN",
        anim: "heal",
        usage: {
            act: "%USER FIXES UP %TARGET",
            crit: "%TARGET FEELS WAY BETTER",
            hit: "%TARGET FEELS BETTER",
            miss: "%TARGET IS TOO SLIPPERY"
        },
        details: {
            flavor: "'utilize quick-acting repair cyst'",
            onHit: `'[STAT::amt] [STATUS::regen]'`,
            onCrit: `'additional [STAT::amt] [STATUS::regen]'`,
            conditional: `<em>VS DOWN::</em>'revive target';'[STATUS::evasion] [STATUS::regen]'`
        },
        stats: {
            autohit: true,
            crit: 0.2,
            amt: -6,
            status: {
                evasion: { name: "evasion", length: 2 },
                regen: { name: "regen", length: 6 },
            }
        },
        exec: function(user, target) {
			removeStatus(user, "winderup")
            let heal = {name: 'regen', length: 6}
            return env.GENERIC_ACTIONS.singleTarget({
                beneficial: true,
                action: this, 
                user, 
                target,
                critStatus: heal, hitStatus: heal,
                hitSfx: {
                    name: 'mend',
                    rate: 1
                },
                genExec: ({target})=>{
                    if(target.state == "dead") {
                        target.hp = 8
                        combatRevive(target)
                        reactDialogue(target, 'receive_rez')
                        addStatus({target: target, origin: user, status: "evasion", length: 2, noReact: true}); 
                        addStatus({target: target, origin: user, status: "regen", length: heal.length, noReact: true}); 
                    }
                }                
            })
        },
    }

    env.ACTIONS.archival_smash_mega = {
        slug: "archival_smash_mega",
        name: "Massive Strike",
        type: 'target',
        desc: "'devastating attack upon one target';'immense physical trauma'",
        anim: "basic-attack",
        help: "100% -8HP +1T:VULNERABLE, 40%C x2 +2T:STUN +2T:OPEN WOUND",
        usage: {
            act: "%USER CHARGES %TARGET",
            crit: "%TARGET IS OBLITERATED",
            hit: "%TARGET IS LEFT REELING",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'devastating attack upon one target';'immense physical trauma'",
            onHit: `'[STAT::amt] [STATUS::vulnerable]'`,
            onCrit: `'[STATUS::stun] [STATUS::open_wound]'`,
        },
        stats: {
			accuracy: 1,
            crit: 0.4,
            amt: 8,
            status: {
                stun: {
                    name: 'stun',
                    length: 2
                },
				open_wound: {
                    name: 'open_wound',
                    length: 2
                },
				vulnerable: {
                    name: 'vulnerable',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
            removeStatus(user, "winderup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'hit',
                    rate: 0.66
                },
				critSfx: {
					name: 'crit',
					rate: 0.75
				},
				hitStatus: {
					name: 'vulnerable',
					length: 1
				},
                critExec: ({target})=> {
                    addStatus({target, status: "stun", length: 2});
					addStatus({target, status: "open_wound", length: 2, noReact: true});
                },
            })
        },
    }
		// don't feel like putting this one in order :P
	env.ACTIONS.archival_smash_mega_vanity = {
        slug: "archival_smash_mega_vanity",
        name: "Massive Strike",
        type: 'target',
        desc: "'devastating attack upon one target';'immense physical trauma'",
        anim: "basic-attack",
        help: "100% -8HP +1T:VULNERABLE, 40%C x2 +2T:STUN +2T:OPEN WOUND",
        usage: {
            act: "%USER CHARGES %TARGET",
            crit: "%TARGET IS OBLITERATED",
            hit: "%TARGET IS LEFT REELING",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'devastating attack upon one target';'immense physical trauma'",
            onHit: `'[STAT::amt] [STATUS::vulnerable]'`,
            onCrit: `'[STATUS::stun] [STATUS::open_wound]'`,
        },
        stats: {
			accuracy: 1,
            crit: 0.4,
            amt: 8,
            status: {
                stun: {
                    name: 'stun',
                    length: 2
                },
				open_wound: {
                    name: 'open_wound',
                    length: 2
                },
				vulnerable: {
                    name: 'vulnerable',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
            removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'hit',
                    rate: 0.66
                },
				critSfx: {
					name: 'crit',
					rate: 0.75
				},
				hitStatus: {
					name: 'vulnerable',
					length: 1
				},
                critExec: ({target})=> {
                    addStatus({target, status: "stun", length: 2});
					addStatus({target, status: "open_wound", length: 2, noReact: true});
                },
            })
        },
    }

    env.ACTIONS.brawl_metal = {
        slug: "brawl_metal",
        name: "Brawl",
        verb: "brawl with",
        type: 'target',
        desc: "'unwieldy punch';'last resort'",
        anim: "basic-attack",
        help: "90% -2HP, 10%C x2",
        usage: {
            act: "%USER ATTACKS %TARGET",
            hit: "%TARGET IS STRUCK",
			crit: "A FRIGHTENING BLOW",
            miss: "%TARGET EVADES"
        },
        details: {
            onHit: `'[STAT::amt]'`,
        },
        stats: { 
            accuracy: 0.9,
			crit: 0.1,
			amt: 3,
            status: {
                hitStun: {
                    name: 'stun',
                    length: 2
                },
				critStun: {
                    name: 'stun',
                    length: 1
                }
            }
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
            })
        }
    }
	
    env.ACTIONS.cavernhammer = {
        slug: "cavernhammer",
        name: "Cavernhammer",
        verb: "hammer",
        type: 'target',
        desc: "'dull-enabled excavation tool';'short, sharp pulse of dull radiation';'immense physical trauma'",
        anim: "basic-attack",
        help: "AUTOHIT -8HP +2T:STUN 10%C x2 +1T:STUN",
        usage: {
            act: "%USER BLASTS %TARGET",
            crit: "%TARGET IS ANNIHILATED",
            hit: "%TARGET IS SEARED",
            miss: "%TARGET EVADES"
        },
		details: {
            flavor: `'utilize dull-enabled excavation tool';'short, sharp pulse of dull radiation'`,
            onHit: `'[STAT::amt] [STATUS::hitStun]'`,
			onCrit: `'[STATUS::critStun]'`
        },
        stats: { 
            autohit: true,
			crit: 0.1,
			amt: 8,
            status: {
                hitStun: {
                    name: 'stun',
                    length: 2
                },
				critStun: {
                    name: 'stun',
                    length: 1
                }
            }
        },
        exec: function(user, target) {
            removeStatus(user, "winderup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'shot7',
                    rate: 0.5
                },
                critSfx: {
                    name: 'stab',
                    rate: 0.4
                },
				critStatus: {
					name: 'stun',
					length: 1
				},
                genExec: ({target}) => {
                    addStatus({target, status: "stun", length: 2});
                }
            })
        }
    }
		// don't feel like putting these two in order :P
	env.ACTIONS.cavernhammer_vanity = {
        slug: "cavernhammer_vanity",
        name: "Cavernhammer",
        verb: "hammer",
        type: 'target',
        desc: "'dull-enabled excavation tool';'short, sharp pulse of dull radiation';'immense physical trauma'",
        anim: "basic-attack",
        help: "AUTOHIT -8HP +2T:STUN 10%C x2 +1T:STUN",
        usage: {
            act: "%USER BLASTS %TARGET",
            crit: "%TARGET IS ANNIHILATED",
            hit: "%TARGET IS SEARED",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: `'utilize dull-enabled excavation tool';'short, sharp pulse of dull radiation'`,
            onHit: `'[STAT::amt] [STATUS::hitStun]'`,
			onCrit: `'[STATUS::critStun]'` // this better work i swear to god
        },
        stats: { 
            autohit: true,
			crit: 0.1,
			amt: 8,
            status: {
                hitStun: {
                    name: 'stun',
                    length: 2
                },
				critStun: {
                    name: 'stun',
                    length: 1
                }
            }
        },
        exec: function(user, target) {
            removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'shot7',
                    rate: 0.5
                },
                critSfx: {
                    name: 'stab',
                    rate: 0.4
                },
				critStatus: {
					name: 'stun',
					length: 1
				},
                genExec: ({target}) => {
                    addStatus({target, status: "stun", length: 2});
                }
            })
        }
    }

    env.ACTIONS.quick_forge = {
        slug: "quick_forge",
        name: "Quick Forge",
        type: 'special',
        desc: "'improvised method of smelting via dull light';'deconstructs foes'",
        help: "FOES::AUTOHIT -4HP +2T:OPEN WOUND 10%C x2",
        anim: "basic-attack",
        details: {
            flavor: "'improvised method of smelting via dull light';'deconstructs foes'",
            onUse: `'HIT all foes'`,
            onHit: `'[STAT::amt] [STATUS::open_wound]'`,
        },
        stats: {
            autohit: true,
            crit: .1,
            amt: 4,
			status: {
                open_wound: {
                    name: 'open_wound',
                    length: 2
                }
            }
        },
        usage: {
            act: "%USER TEARS OPEN THE DULL"
        },
        exec: function(user, target, beingUsedAsync) {
            removeStatus(user, "winderup")
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
                    let anim = env.COMBAT_ANIMS.flare
                    let baseDelay = ((env.ADVANCE_RATE * 0.3) * i)
                    let animDelay = baseDelay + anim.duration;
                        
                    setTimeout(()=>anim.exec(action, user, actor), baseDelay)
                    setTimeout(function(){
                        env.GENERIC_ACTIONS.singleTarget({
                            beneficial: true,
                            action: action, 
                            user, 
                            target: actor,
                            hitSfx: { name: 'dull', rate: 1 },
                            critSfx: { name: 'shot6', rate: 0.6 },
							hitStatus: {
								name: 'open_wound',
								length: 2
							},
                        })
                    }, animDelay);
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    }
	
	env.ACTIONS.quick_forge_vanity = {
        slug: "quick_forge_vanity",
        name: "Quick Forge",
        type: 'special',
        desc: "'improvised method of smelting via dull light';'deconstructs foes'",
        help: "FOES::AUTOHIT -4HP +2T:OPEN WOUND 10%C x2",
        anim: "basic-attack",
        details: {
            flavor: "'improvised method of smelting via dull light';'deconstructs foes'",
            onUse: `'HIT all foes'`,
            onHit: `'[STAT::amt] [STATUS::open_wound]'`,
        },
        stats: {
            autohit: true,
            crit: .1,
            amt: 4,
			status: {
                open_wound: {
                    name: 'open_wound',
                    length: 2
                }
            }
        },
        usage: {
            act: "%USER TEARS OPEN THE DULL"
        },
        exec: function(user, target, beingUsedAsync) {
            removeStatus(user, "windup")
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
                    let anim = env.COMBAT_ANIMS.flare
                    let baseDelay = ((env.ADVANCE_RATE * 0.3) * i)
                    let animDelay = baseDelay + anim.duration;
                        
                    setTimeout(()=>anim.exec(action, user, actor), baseDelay)
                    setTimeout(function(){
                        env.GENERIC_ACTIONS.singleTarget({
                            beneficial: true,
                            action: action, 
                            user, 
                            target: actor,
                            hitSfx: { name: 'dull', rate: 1 },
                            critSfx: { name: 'shot6', rate: 0.6 },
							hitStatus: {
								name: 'open_wound',
								length: 2
							},
                        })
                    }, animDelay);
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    }
	
    env.ACTIONS.veilkruka = {
        slug: "veilkruka",
        name: "Veilkruka",
        verb: "blast",
        type: 'target',
        desc: "'for emergencies';'overexert golem to create dull blast';'chance to detonate foes';'deals self damage'",
        anim: "basic-attack",
        help: "AUTOHIT -12HP +3T:STUN 15%C (FOES::AUTOHIT -6HP +1T:STUN)\nSELF:: -6HP",
        usage: {
            act: "%USER BLASTS %TARGET",
            crit: "%TARGET'S TEAM EXPLODES",
            hit: "%TARGET IS ANNIHILATED",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: `'overexert dull emitters to create explosion';'deals self damage'`,
			onUse: `'[STAT::selfHP] to self'`,
            onHit: `'[STAT::amt] [STATUS::hitStun]'`,
			onCrit: `'HIT all foes for [STAT::selfHP] [STATUS::critStun]'` // this better work i swear to god
        },
        stats: { 
            autohit: true,
			crit: 0.15,
			amt: 12,
			selfHP: 6,
            status: {
                hitStun: {
                    name: 'stun',
                    length: 3
                },
				critStun: {
                    name: 'stun',
                    length: 1
                }
            }
        },
        exec: function(user, target) {
			combatHit(user, {amt: 6, autohit: true, crit: 0, redirectable: false, origin: user})
            removeStatus(user, "windestup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'stab',
                    rate: 0.4
                },
                critSfx: {
                    name: 'shot6',
                    rate: 0.5
                },
                hitExec: ({target}) => {
                    addStatus({target, status: "stun", length: 3});
                },
				critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i)=>{
                        combatHit(actor, {amt: 6, crit: 0, autohit: true, origin: user});
                        addStatus({target: actor, status: "stun", length: 1}); 
                        play("shot", 0.75)
                    }
                })
            })
        }
    }
	
	env.ACTIONS.incinerate = {
        slug: "incinerate",
        name: "Incinerate",
        type: 'special',
        desc: "'improvised method of waste disposal';'deconstructs foes';'deals self damage'",
        help: "FOES::AUTOHIT -5HP +4T:OPEN WOUND +3T:PUNCTURE 10%C x2\nSELF:: -1HP",
        anim: "basic-attack",
        details: {
            flavor: "'improvised method of waste disposal';'deconstructs foes'",
            onUse: `'HIT all foes'`,
            onHit: `'[STAT::amt] [STATUS::open_wound] [STATUS::puncture]';'[STAT::selfHP] to user per hit'`,
        },
        stats: {
            autohit: true,
            crit: .1,
            amt: 5,
			selfHP: 1,
			status: {
                open_wound: {
                    name: 'open_wound',
                    length: 4
                },
				puncture: {
                    name: 'puncture',
                    length: 3
                }
            }
        },
        usage: {
            act: "%USER TEARS OPEN THE DULL"
        },
        exec: function(user, target, beingUsedAsync) {
            removeStatus(user, "windestup")
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
                    let anim = env.COMBAT_ANIMS.flare
                    let baseDelay = ((env.ADVANCE_RATE * 0.4) * i)
                    let animDelay = baseDelay + anim.duration;
                        
                    setTimeout(()=>anim.exec(action, user, actor), baseDelay)
                    setTimeout(function(){
                        env.GENERIC_ACTIONS.singleTarget({
                            action: action, 
                            user, 
                            target: actor,
                            hitSfx: { name: 'dull', rate: 0.75 },
                            critSfx: { name: 'shot6', rate: 0.5 },
							hitExec: ()=>{
								addStatus({target: actor, status: "open_wound", length: 4, noReact: true}); 
								addStatus({target: actor, status: "puncture", length: 3, noReact: false}); 
							}
                        })
						combatHit(user, {amt: 1, accuracy: this.accuracy, crit: 0, origin: user, redirectable: false, runEvents: false})
                    }, animDelay);
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    }

    env.ACTIONS.cavernsplitter = {
        slug: "cavernsplitter",
        name: "Cavernsplitter",
        verb: "cavernsplit",
        type: 'target',
        desc: "'massively overcharged dull pulse';'significant self damage'",
        anim: "basic-attack",
        help: "AUTOHIT -16HP +4T:STUN 20%C x2 (FOES::AUTOHIT -8HP +2T:STUN +3T:OPEN WOUND +3T:PUNCTURE)\nSELF:: -16HP, +1T:STUN",
        usage: {
            act: "%USER BLASTS %TARGET",
            crit: "%TARGET IS DUST ON THE WIND",
            hit: "%TARGET IS ANNIHILATED",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: `'massively overexert dull emitters to create vicious explosion'`,
			onUse: `'[STAT::amt] [STATUS::selfStun] to self'`,
            onHit: `'[STAT::amt] [STATUS::hitStun]'`,
			onCrit: `'HIT all foes for [STAT::selfHP] [STATUS::critStun] [STATUS::open_wound] [STATUS::puncture]'` // this better work i swear to god
        },
        stats: { 
            autohit: true,
			crit: 0.2,
			amt: 16,
			selfHP: 8,
            status: {
                hitStun: {
                    name: 'stun',
                    length: 4
                },
				critStun: {
                    name: 'stun',
                    length: 2
                },
				selfStun: {
                    name: 'stun',
                    length: 1
                },
				open_wound: {
                    name: 'open_wound',
                    length: 3
                },
				puncture: {
                    name: 'puncture',
                    length: 3
                }
            }
        },
        exec: function(user, target) {
			combatHit(user, {amt: 16, autohit: true, crit: 0, redirectable: false, origin: user})
			addStatus({target: user, origin: user, status: "stun", length: 1});
            removeStatus(user, "final_windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'dull',
                    rate: 0.4
                },
                critSfx: {
                    name: 'shot6',
                    rate: 0.33
                },
                hitExec: ({target}) => {
                    addStatus({target: target, status: "stun", length: 4});
                },
				critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i)=>{
                        combatHit(actor, {amt: 8, crit: 0, autohit: true, origin: user});
                        addStatus({target: actor, status: "stun", length: 2}); 
						addStatus({target: actor, status: "open_wound", length: 3});
						addStatus({target: actor, status: "puncture", length: 3}); 
                        play("shot", 0.55)
                    }
                })
            })
        }
    }

    env.ACTIONS.immolate = {
        slug: "immolate",
        name: "Immolate",
        type: 'special',
        desc: "'broadly exhaust all stored dull radiation';'shred dull emitters to create shrapnel'",
        help: "FOES::AUTOHIT -6HP +1T:STUN +6T:OPEN WOUND +6T:PUNCTURE 20%C x2\nSELF:: -3HP",
        anim: "basic-attack",
        details: {
            flavor: "'improvised method of waste disposal';'deconstructs foes'",
            onUse: `'HIT all foes'`,
            onHit: `'[STAT::amt] [STATUS::open_wound] [STATUS::puncture] [STATUS::stun]';'[STAT::selfHP] to user per hit'`,
        },
        stats: {
            autohit: true,
            crit: .2,
            amt: 6,
			selfHP: 3,
			status: {
                open_wound: {
                    name: 'open_wound',
                    length: 6
                },
				puncture: {
                    name: 'puncture',
                    length: 6
                },
				stun: {
                    name: 'stun',
                    length: 1
                }
            }
        },
        usage: {
            act: "%USER TEARS OPEN THE DULL"
        },
        exec: function(user, target, beingUsedAsync) {
            removeStatus(user, "final_windup")
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
                    let anim = env.COMBAT_ANIMS.flare
                    let baseDelay = ((env.ADVANCE_RATE * 0.5) * i)
                    let animDelay = baseDelay + anim.duration;
                        
                    setTimeout(()=>anim.exec(action, user, actor), baseDelay)
                    setTimeout(function(){
                        env.GENERIC_ACTIONS.singleTarget({
                            beneficial: true,
                            action: action, 
                            user, 
                            target: actor,
                            hitSfx: { name: 'dull', rate: 0.5 },
                            critSfx: { name: 'shot6', rate: 0.4 },
							hitExec: ()=>{
								addStatus({target: actor, status: "stun", length: 1, noReact: true}); 
								addStatus({target: actor, status: "open_wound", length: 6, noReact: true}); 
								addStatus({target: actor, status: "puncture", length: 6, noReact: false}); 
							}
                        })
						combatHit(user, {amt: 3, accuracy: this.accuracy, crit: 0, origin: user, redirectable: false, runEvents: false})
                    }, animDelay);
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    }
	
	//husk actions start here
	env.ACTIONS.husk_attack_ichor = {
        slug: "husk_attack_ichor",
        name: "Familiar Corruskivi",
        type: 'target',
        desc: "'utilize warped repair tool as weapon';'chance to drain corru for extra damage'",
        anim: "basic-attack",
        help: "80% -2HP, 20%C x2 + (FOES::+2T:PUNCTURE +1T:FEAR)",
        usage: {
            act: "%USER SPRINTS AT %TARGET",
            crit: "%TARGET FACES THEIR MORTALITY",
            hit: "%TARGET IS STRUCK WITH BROKEN LIMBS",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: `'utilize warped limbs to strike target';'occasionally terrifying'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::fear] [STATUS::puncture] to all foes'`,
        },
        stats: {
            accuracy: .8,
            crit: 0.2,
            amt: 2,
            status: {
                puncture: {
                    name: 'puncture',
                    length: 2
                },
				fear: {
                    name: 'fear',
                    length: 1
                }
            },
        },
        exec: function(user, target) {

            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'stab',
                    rate: 1.5
                },

                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i)=>{
                        addStatus({target: actor, origin: user, status: "fear", origin: user, length: 1}); 
						addStatus({target: actor, origin: user, status: "puncture", origin: user, length: 2}); 
                        play('stab', 0.6);
                    }
                })
            })
        }
    },
	
    env.ACTIONS.speak_ichor = {
        slug: "speak_ichor",
        name: "Siphon",
        type: 'target',
        desc: "'tap vital corru of target to sustain allies'",
        anim: "basic-attack",
        help: "AUTOHIT +3T:SIPHON",
        usage: {
            act: "%USER GRASPS AT %TARGET",
            crit: "%TARGET IS PARALYZED BY PAIN",
            hit: "%TARGET'S FLESH REVOLTS",
            miss: "%TARGET DODGES"
        },
        details: {
            flavor: `'utilize remains to siphon vital corru';'express aggressor signal directly'`,
            onHit: `'[STATUS::fear] [STATUS::puncture]'`,
            onCrit:`'[STATUS::stun] [STATUS::open_wound]'`,
        },
        stats: {
            accuracy: .8,
            crit: 0.1,
            amt: 0,
            status: {
                puncture: {
                    name: 'puncture',
                    length: 2
                },
				fear: {
                    name: 'fear',
                    length: 2
                },
				stun: {
                    name: 'stun',
                    length: 1
                },
				open_wound: {
                    name: 'open_wound',
                    length: 2
                },
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'stab',
                    rate: 0.75
                },
				critSfx: {
					name: 'scarydoia',
					rate: 1,
				},
                hitExec: ({target})=> {
                    addStatus({target, origin: user, status: "puncture", length: 2}); 
					addStatus({target, origin: user, status: "fear", length: 2}); 
                },
				critExec: ({target})=> {
                    addStatus({target, origin: user, status: "stun", length: 1}); 
					addStatus({target, origin: user, status: "open_wound", length: 2}); 
                },
            })
        }
    },
	
	env.ACTIONS.husk_attack_eyes = {
        slug: "husk_attack_eyes",
        name: "Familiar Exploit",
        type: 'target',
        desc: "'utilized warped limbs to locate vulnerability in target';'occasionally terrifying'",
        anim: "basic-attack",
        help: "80% -2HP, 10%C x2 + (FOES::+1T:FEAR +2T:VULNERABLE)\nADD::-2HP IF TARGET IS VULNERABLE",
        usage: {
            act: "%USER SPRINTS AT %TARGET",
            crit: "%TARGET FACES THEIR MORTALITY",
            hit: "%TARGET IS STRUCK WITH BROKEN LIMBS",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: `'utilize warped limbs to locate vulnerability in target';'occasionally terrifying'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::fear] [STATUS::vulnerable] to all foes'`,
			conditional: `<em>VS VULNERABLE::</em>'additional [STAT::amt]'`
        },
        stats: {
            accuracy: .8,
            crit: 0.1,
            amt: 2,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },
				fear: {
                    name: 'fear',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
			let amt = this.stats.amt

            if(hasStatus(target, "vulnerable")) {
                amt = this.stats.amt + 2
            }
			
            return env.GENERIC_ACTIONS.singleTarget({ 
                action: this, 
                user, 
                target,

                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i)=>{
                        addStatus({target: actor, origin: user, status: "fear", origin: user, length: 1}); 
						addStatus({target: actor, origin: user, status: "vulnerable", origin: user, length: 2}); 
                        play('status', 0.7);
                    }
                })
            })
        }
    },
	
	env.ACTIONS.special_enact_pain = {
        slug: "special_enact_pain",
        name: "Enact",
        type: 'special',
        desc: "'enact plan';'unleash flurry of strikes upon foes'",
        anim: "basic-attack",
        verb: "enact upon",
        help: "UTILIZE PRIMARY ON RANDOM FOES xT:EVASION TIMES, SELF::-EVASION",
        autohit: true,
        noRepeat: true,
        exec: function(user, target) {
            let amt = Math.floor(hasStatus(target, 'evasion'))
			let amt2 = 2 * Math.floor(hasStatus(target, 'evasion_mega'))
			let finalAmt = amt + amt2
            removeStatus(user, "evasion")
			removeStatus(user, "evasion_mega")
			let primary = env.ACTIONS[user.actions[0]]
			if (hasStatus(user, "windup")) (primary = env.ACTIONS[user.windupActions[0]])
            actionMessage(user, "%USER LAUNCHES THEIR ATTACK", target, 'none', 1000 + (finalAmt * 200))

            for (let i = 0; i < finalAmt; i++) {
                env.setTimeout(()=>{
                    let target = user.enemyTeam.members.filter(t=>t.state != "dead").sample()
                    if(target) useAction(user, primary, target, {triggerActionUseEvent: i == 0, beingUsedAsync: true, reason: "enact", noUseMessage: true})
                }, i * 200)
            }

            env.setTimeout(()=>{
                advanceTurn(user)
            }, (finalAmt * 200) + 500)
        },
        disableIf: (actor)=>{
			if(!hasStatus(actor,"evasion")) return "REQUIRES EVASION/UNNATURAL SPEED"
			else if(!hasStatus(actor,"evasion_mega")) return "REQUIRES EVASION/UNNATURAL SPEED" 
		},
    },
	
	env.ACTIONS.husk_attack_claws = {
        slug: "husk_attack_claws",
        name: "Familiar Bomb",
        verb: "throw at",
        type: 'target',
        desc: "'utilize rapid-formed micro-explosive';'chance for terrifying explosion'",
        anim: "basic-attack",
        help: "90% -1HP, 50%C x2 (FOES::90% -1HP +2T:FEAR)",
        usage: {
            act: "%USER SPRINTS AT %TARGET",
            crit: "SHRAPNEL SPRINGS AROUND THE ROOM",
            hit: "%TARGET IS STRUCK WITH BROKEN LIMBS",
            miss: "%TARGET DODGES"
        },
        details: {
            flavor: `'utilize rapid-formed micro-explosive';'chance for greater shrapnel explosion'`,
            onHit: `'[STAT::amt]'`,
            onCrit: () => `'HIT all foes for [STAT::amt] [STATUS::fear]'${page.name == "frame" ? `;'additional hits trigger on-hit effects'` : ``}`,
        },
        stats: {
            accuracy: .9,
            crit: 0.5,
            amt: 1,
            status: {
                fear: {
                    name: 'fear',
                    length: 2
                }
            },
        },
        exec: function(user, target) {
            let action = this;
            return env.GENERIC_ACTIONS.singleTarget({
                action, 
                user, 
                target,

                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i) => {
                        env.GENERIC_ACTIONS.singleTarget({
                            action, 
                            user, 
                            target: actor,
                            hitSfx: { name: 'shot4' },
                            hitStatus: {
                                name: 'fear',
                                length: 2
                            },
                            canCrit: false
                        })
                    }
                })
            })
        }
    },
	
	env.ACTIONS.bite_weak = {
        slug: "bite_weak",
        name: "Bite",
        type: 'target',
        desc: "'become unreasonable';'transfer illness'",
        anim: "basic-attack",
        help: "100% -1HP +3T:ROT + TRANSFER T:ROT TO TARGET, 10%C x2 +3T:ROT",
        accuracy: 1,
        usage: {
            act: "%USER BITES %TARGET",
            hit: "%TARGET FEELS HORRIBLE",
			crit: "%TARGET SHAMBLES AS IF VIOLENTLY ILL",
			miss: "%USER CONTROLS THEMSELVES"
        },
        details: {
            flavor: "'become unreasonable'",
            onHit: `'[STAT::amt] [STATUS::rot]'`,
            onCrit: ()=> `'infect vital cystic component for [STATUS::rot]'${env?.rpg?.is2D ? ";'KB::2'" : ''}`,
        },

        stats: {
            range: 2,
            accuracy: 1,
            crit: 0.1,
            amt: 1,
            status: {
                rot: {
                    name: 'rot',
                    length: 3
                }
            }
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'chomp',
                    rate: 1
                },
				
				critSfx: {
					name: 'chomp',
					rate: 0.55
				},
				
				critStatus: {
					name: 'rot',
					length: 3
				},

                genExec: ()=> {
                    let pow = hasStatus(user, "rot")
                    if(pow) removeStatus(user, "rot")

                    addStatus({target, origin: user, status: "rot", length: 3 + pow});
                }
            })
        }
    },
	
	env.ACTIONS.husk_attack_bone = {
        slug: "husk_attack_bone",
        name: "Familiar Break",
        type: 'target',
        desc: "'utilized warped limbs to strike target';'occasionally terrifying'",
        anim: "basic-attack",
        help: "80% -2HP, 10%C x2 + (FOES::+1T:FEAR, +2T:WEAKENED)",
        usage: {
            act: "%USER SPRINTS AT %TARGET",
            crit: "%TARGET FACES THEIR MORTALITY",
            hit: "%TARGET IS STRUCK WITH BROKEN LIMBS",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: `'utilize warped limbs to strike target';'occasionally terrifying'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::fear] [STATUS::weakened] to all foes'`,
        },
        stats: {
            accuracy: .8,
            crit: 0.1,
            amt: 2,
            status: {
                weakened: {
                    name: 'weakened',
                    length: 2
                },
				fear: {
                    name: 'fear',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,

                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i)=>{
                        addStatus({target: actor, origin: user, status: "fear", origin: user, length: 1}); 
						addStatus({target: actor, origin: user, status: "weakened", origin: user, length: 2}); 
                        play('fear', 0.75);
                    }
                })
            })
        }
    },
	
	env.ACTIONS.speak_bone = {
        slug: "speak_bone",
        name: "Speak",
        type: 'target',
        desc: "'utilize remains to speak';'express aggressor signal directly'",
        help: "80% +2T:WEAKENED, 30%C +1T:STUN",
        anim: "skitter",
        usage: {
            act: "%USER APPROACHES %TARGET",
            crit: "%TARGET IS PARALYZED BY FEAR",
            hit: "%USER WHISPERS SOMETHING TO %TARGET",
            miss: "%TARGET RECOILS"
        },
        details: {
            flavor: `'utilize remains to speak';'express aggressor signal directly'`,
            onHit: `'[STATUS::fear] [STATUS::weakened]'`,
            onCrit:`'[STATUS::stun]'`,
        },
        stats: {
            accuracy: .8,
            crit: 0.1,
            amt: 0,
            status: {
                weakened: {
                    name: 'weakened',
                    length: 2
                },
				fear: {
                    name: 'fear',
                    length: 2
                },
				stun: {
                    name: 'stun',
                    length: 2
                },
				open_wound: {
                    name: 'open_wound',
                    length: 2
                },
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'talksignal',
                    rate: 1
                },
                hitExec: ()=>{
                    reactDialogue(user, `give_fear`)
                },
                critSfx: {
                    name: 'fear',
                    rate: 0.75
                },
                hitExec: ({target})=> {
                    addStatus({target, origin: user, status: "weakened", length: 2}); 
					addStatus({target, origin: user, status: "fear", length: 2}); 
                },
				critExec: ({target})=> {
                    addStatus({target, origin: user, status: "stun", length: 2}); 
                },
            })
        }
    },
	
	env.ACTIONS.husk_attack_light = {
        slug: "husk_attack_light",
        name: "Familiar Claw",
        type: 'target',
        desc: "'utilized warped limbs to strike target';'occasionally terrifying'",
        anim: "basic-attack",
        help: "70% -2HP, 5%C x2 + (FOES::+2T:FEAR +1T:STUN)",
        usage: {
            act: "%USER SPRINTS AT %TARGET",
            crit: "%TARGET FACES THEIR MORTALITY",
            hit: "%TARGET IS STRUCK WITH BROKEN CLAWS",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: `'utilize warped claws to strike target';'occasionally terrifying'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::fear] [STATUS::stun] to all foes'`,
        },
        stats: {
            accuracy: .7,
            crit: 0.1,
            amt: 2,
            status: {
                stun: {
                    name: 'stun',
                    length: 2
                },
				fear: {
                    name: 'fear',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
				hitSfx: {
					name: 'dull',
					rate: 1
				},

                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i)=>{
                        addStatus({target: actor, origin: user, status: "fear", origin: user, length: 1}); 
						addStatus({target: actor, origin: user, status: "stun", origin: user, length: 2}); 
                        play('talkfairy', 0.33);
                    }
                })
            })
        }
    },
	
	env.ACTIONS.speak_light = {
        slug: "speak_light",
        name: "Speak",
        type: 'target',
        desc: "'utilize remains to speak';'express aggressor signal directly'",
        help: "80% ONE OF (+2T:DESTABILIZED, +2T:FEAR, +1T:STUN), 10%C ONE OF (+2T:DESTABILIZED, +2T:FEAR, +1T:STUN)",
        anim: "skitter",
        usage: {
            act: "%USER APPROACHES %TARGET",
            crit: "%TARGET IS PARALYZED BY FEAR",
            hit: "%USER WHISPERS MADNESS TO %TARGET",
            miss: "%TARGET RECOILS"
        },
        details: {
            flavor: "'utilize remains to speak madness'",
            onHit: `'inflict one of following';'[STATUS::destabilized]';'[STATUS::fear]';'[STATUS::stun]'`,
            onCrit:`'inflict one of following';'[STATUS::destabilized]';'[STATUS::fear]';'[STATUS::stun]';'higher chance to apply [STATUS::displayStun]'`,
        },
        stats: {
            accuracy: .7,
            crit: 0.3,
            amt: 0,
            status: {
                destabilized: {
                    name: 'destabilized',
                    length: 2
                },
                fear: {
                    name: 'fear',
                    length: 2
                },
                stun: {
                    name: 'stun',
                    length: 1
                },
				displayStun: {
                    name: 'stun',
                    showReference: true
                },
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'talkfairy',
                    rate: 1
                },
                hitExec: ()=>{
                    reactDialogue(user, `give_fear`)
                },
                critSfx: {
                    name: 'talkfairy',
                    rate: 0.5
                },
                critExec: ({target})=> {
                    let rand = Math.random()
                    if(rand < 0.3) {
                        addStatus({target, origin: user, status: "destabilized", origin: user, length: 2}); 
                        
                    } else if(rand < 0.6) {
                        addStatus({target, origin: user, status: "fear", origin: user, length: 2}); 

                    } else {
                        addStatus({target, origin: user, status: "stun", origin: user, length: 1}); 
                    }
                },
                hitExec: ({target})=> {
                    let rand1 = Math.random()
                    if(rand1 < 0.2) {
                        addStatus({target, origin: user, status: "destabilized", origin: user, length: 2}); 
                        
                    } else if(rand1 < 0.4) {
                        addStatus({target, origin: user, status: "fear", origin: user, length: 2}); 

                    } else {
                        addStatus({target, origin: user, status: "stun", origin: user, length: 1}); 
                    }
                },
            })
        }
    },
	
	env.ACTIONS.husk_attack_dull = {
        slug: "husk_attack_dull",
        name: "Familiar Blade",
        type: 'target',
        desc: "'utilized warped dull blade to strike target';'obliterate destabilized foes'",
        anim: "basic-attack",
        help: "80% -2HP, 10%C x2 + (FOES::+1T:FEAR +2T:DESTABILIZED)\nIF TARGET IS DESTABILIZED::80% -3HP, 30%C x2 + (FOES::-1HP, +2T:FEAR +2T:WEAKENED)",
        usage: {
            act: "%USER SPRINTS AT %TARGET",
            crit: "%TARGET FACES THEIR MORTALITY",
            hit: "%TARGET IS SEARED WITH BROKEN LIMBS",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: `'utilize warped dull blade to strike target';'obliterate destabilized foes'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::fear] [STATUS::vulnerable] to all foes'`,
			conditional: `<em>VS VULNERABLE::</em>'additional [STAT::amt] [STATUS::stun] to all foes on crit'`
        },
		stats: {
            accuracy: .8,
            crit: 0.1,
            amt: 2,
            status: {
                stun: {
                    name: 'stun',
                    length: 1
                },
				vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },
				fear: {
                    name: 'fear',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
				hitSfx: {
					name: 'dull',
					rate: 1.0
				},
				critSfx: {
					name: 'dull',
					rate: 0.6
				},
                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i)=>{
					if(hasStatus(target, "destabilized")) {
						addStatus({target: actor, origin: user, status: "fear", origin: user, length: 1}); 
						addStatus({target: actor, origin: user, status: "vulnerable", origin: user, length: 2}); 
						addStatus({target: actor, origin: user, status: "stun", origin: user, length: 1});
						combatHit(actor, {amt: 2, crit: 0, autohit: true, origin: user});
						play('talksignal', 0.75);
                    } else {
						addStatus({target: actor, origin: user, status: "fear", origin: user, length: 1}); 
						addStatus({target: actor, origin: user, status: "vulnerable", origin: user, length: 2}); 
						play('destabilize', 0.75);
						}
                    }
                })
            })
        }
    },
		// maybe we just don't use this
	env.ACTIONS.speak_dull = {
        slug: "speak_dull",
        name: "Dullvoice",
        type: 'target',
        desc: "'utilize remains to speak';'express aggressor signal directly'",
        help: "80% +2T:DESTABILIZED, 10%C +1T:STUN\nIF TARGET IS DESTABILIZED::100% -1HP +2T:DESTABILIZED +2T:FEAR, 30%C x2 +1T:STUN",
        anim: "skitter",
        usage: {
            act: "%USER APPROACHES %TARGET",
            crit: "%TARGET IS PARALYZED BY FEAR",
            hit: "%USER WHISPERS SOMETHING TO %TARGET",
            miss: "%TARGET RECOILS"
        },
        accuracy: 0.8,
        crit: 0.1,
        amt: 0,
        exec: function(user, target) {
			let amt = this.amt
            let crit = this.crit
			let acc = this.accuracy

            if(hasStatus(target, "destabilized")) {
                amt = this.amt + 1
                crit = this.crit + .2
				acc = this.accuracy + .2
            }
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'destabilize',
                    rate: 1
                },
                hitExec: ()=>{
                    reactDialogue(user, `give_fear`)
					if(hasStatus(target, "destabilized")) {
                        addStatus({target, origin: user, status: "destabilized", length: 2, noReact: true});
						addStatus({target, origin: user, status: "fear", length: 2, noReact: true});
						combatHit(target, {amt: 1, crit: 0, autohit: true, origin: user});
                    }
					else { 
					addStatus({target, origin: user, status: "destabilized", length: 2, noReact: true});
					}
                },
                critSfx: {
                    name: 'fear',
                    rate: 0.75
                },
                critStatus: {
                    name: 'stun',
                    length: 1
                },
				critExec: ()=>{
					if(hasStatus(target, "destabilized")) {
					combatHit(target, {amt: 1, crit: 0, autohit: true, origin: user});
					} else return
				},
            })
        }
    },
	
	env.ACTIONS.husk_smash = {
        slug: "husk_smash",
        name: "Calculated Strike",
        type: 'target',
        desc: "'focused, deadly attack with warped limbs';'immense psychological trauma'",
        anim: "basic-attack",
        help: "100% -4HP, 40% x2 + (FOES::+3T:FEAR +3T:PRONE)",
        usage: {
            act: "%USER CHARGES %TARGET",
            crit: "%TARGET'S TEAM IS LEFT REELING",
            hit: "%TARGET IS STRUCK WITH BROKEN LIMBS",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: `'focused, deadly attack with warped limbs';'immense psychological trauma'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::fear] [STATUS::prone] to all foes'`,
        },
        stats: {
            accuracy: 1,
            crit: 0.4,
            amt: 4,
            status: {
                prone: {
                    name: 'prone',
                    length: 3
                },
				fear: {
                    name: 'fear',
                    length: 3
                }
            },
        },
        exec: function(user, target) {
            removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'hit',
                    rate: 0.8
                },
				critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i)=>{
                        addStatus({target: actor, origin: user, status: "fear", origin: user, length: 3}); 
						addStatus({target: actor, origin: user, status: "prone", origin: user, length: 3}); 
                        play('fear', 0.75);
                    }
                })
            })
        }
    },
	
	env.ACTIONS.husk_attack_hands = {
        slug: "husk_attack_hands",
        name: "Familiar Corikuva",
        type: 'target',
        desc: "'defile ceremonial weaponry';'occasionally terrifying'",
        anim: "basic-attack",
        help: "80% -2HP, 10%C x2 + (FOES::+1T:FEAR, +2T:CURSED)",
        usage: {
            act: "%USER SPRINTS AT %TARGET",
            crit: "%TARGET FACES THEIR MORTALITY",
            hit: "%TARGET IS STRUCK WITH BROKEN LIMBS",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: `'defile ceremonial weaponry';'occasionally terrifying'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::fear] [STATUS::cursed] to all foes'`,
        },
        stats: {
            accuracy: .8,
            crit: 0.2,
            amt: 2,
            status: {
                cursed: {
                    name: 'cursed',
                    length: 2
                },
				fear: {
                    name: 'fear',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,

                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i)=>{
                        addStatus({target: actor, origin: user, status: "fear", origin: user, length: 1}); 
						addStatus({target: actor, origin: user, status: "cursed", origin: user, length: 2}); 
                        play('talkfairy', 0.75);
                    }
                })
            })
        }
    },
		//this is heart's secondary now :P
	env.ACTIONS.falseprayer = {
        slug: "falseprayer",
        name: "False Prayer",
        type: 'target',
        desc: "'make plea to chosen deity';'many detrimental outcomes'",
        help: "80% ONE OF (-3HP +3T:PUNCTURE, +2T:VULNERABLE +1T:STUN, +2T:FEAR +1T:WEAKENED, +3T:CURSED), 10%C CHOOSE ANOTHER RANDOM EFFECT",
        anim: "skitter",
        details: {
            flavor: "make plea to chosen deity'",
            onHit: "'grant one of following';'[STAT::selfHP], [STATUS::puncture]';'[STATUS::vulnerable], [STATUS::stun]';'[STATUS::fear], [STATUS::weakened]';'[STATUS::cursed]'",
            onCrit:"'grant one of following';'[STAT::selfHP], [STATUS::puncture]';'[STATUS::vulnerable], [STATUS::stun]';'[STATUS::fear], [STATUS::weakened]';'[STATUS::cursed]'",
        },
		usage: {
            act: "%USER APPROACHES %TARGET",
            crit: "%TARGET IS JUDGED",
            hit: "%USER SPEAKS MADNESS TO %TARGET",
            miss: "%TARGET RECOILS"
        },
        stats: {
            accuracy: 0.8,
            crit: 0.1,
            amt: 0,
			selfHP: 3,
            status: {
                puncture: { name: 'puncture', length: 3 },
                vulnerable: { name: 'vulnerable', length: 2 },
				stun: { name: 'stun', length: 1 },
				fear: { name: 'fear', length: 2 },
				weakened: { name: 'weakened', length: 1 },
				cursed: { name: 'cursed', length: 3 },
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                beneficial: true,
                action: this, 
                user, 
                target,
				hitSfx: {
					name: "talkfairy",
					rate: 0.8
				},
				critSfx: {
					name: "talkfairy",
					rate: 0.4
				},
                hitExec: ({target})=> {
                    let rand = Math.random()
                    if(rand < 0.25) {

                        addStatus({target, origin: user, status: "puncture", origin: user, length: 3}); 
                        combatHit(target, {amt: 3, origin: user, autohit: true, beneficial: true});
                    } else if(rand < 0.5) {

                        addStatus({target, origin: user, status: "vulnerable", origin: user, length: 2}); 
						addStatus({target, origin: user, status: "stun", origin: user, length: 1}); 
                    } else if(rand < 0.75) {

                        addStatus({target, origin: user, status: "fear", origin: user, length: 2});
						addStatus({target, origin: user, status: "weakened", origin: user, length: 1});
                    } else {

						addStatus({target, origin: user, status: "cursed", origin: user, length: 3}); 
					}
                },
				critExec: ({target})=> {
                    let rand1 = Math.random()
                    if(rand1 < 0.25) {

                        addStatus({target, origin: user, status: "puncture", origin: user, length: 3}); 
                        combatHit(target, {amt: 3, origin: user, autohit: true, beneficial: true});
                    } else if(rand1 < 0.5) {

                        addStatus({target, origin: user, status: "vulnerable", origin: user, length: 2}); 
						addStatus({target, origin: user, status: "stun", origin: user, length: 1}); 
                    } else if(rand1 < 0.75) {

                        addStatus({target, origin: user, status: "fear", origin: user, length: 2});
						addStatus({target, origin: user, status: "weakened", origin: user, length: 1});
                    } else {

						addStatus({target, origin: user, status: "cursed", origin: user, length: 3}); 
					}
                },
            })
        },

        avoidChaining: true,
        disableIf: (actor) => {
            return (
                actor.team.name == "enemy" &&
                !actor.team.members.some(member => ((member != actor) && (member.state != "dead") ))
            )
        }
    }
	
	env.ACTIONS.eviscerate_better = {
        slug: "eviscerate_better",
        name: "Eviscerate",
        type: 'target',
        desc: "'boldly assault target';'target previously inflicted wounds for additional damage'",
        anim: "basic-attack",
        help: "80% -1HP +2T:PUNCTURE, 10%C x2 +2T:PUNCTURE\nADD::-1HP PER 1T:PUNCTURE",
        usage: {
            act: "%USER CLAWS AT %TARGET",
            crit: "%TARGET IS TORN APART",
            hit: "%TARGET IS TORN APART",
            miss: "%TARGET RECOILS"
        },
        details: {
            flavor: `'boldly assault target';'target previously inflicted wounds for additional damage'`, 
            onHit: `'strike for [STAT::amt]'`, 
            conditional: `<em>ADD::</em>'[STAT::amt] PER [STATUS::puncture] ON TARGET'`, 
        },
        stats: {
            accuracy: 0.8, 
			crit: 0.1,
            amt: 1,
            status: { 
                puncture: {
                    name: 'puncture',
                    showReference: true // just for ref
                },

            }
        },
        exec: function(user, target) {
            let specialAmt = 1 + Math.floor(hasStatus(target, 'puncture'))
            
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                specialAmt,
				hitSfx: {
					name: 'stab',
					rate: 0.8
				},
				critSfx: {
					name: 'stab',
					rate: 0.5
				},
				hitStatus: {
					name: 'puncture',
					length: 2
				},
				critStatus: {
					name: 'puncture',
					length: 2
				},
            })
        }
    },
	//secri actor actions
	env.ACTIONS.secri_crush = { //basically a vanity reskin of warped pain shelf's old annihilation
		slug: "secri_crush",
		name: "Crush",
		verb: "crush",
		type: 'target',
		desc: "'utilize long limbs to eviscerate a target';'chance for immense physical trauma'",
		anim: "basic-attack",
		help: "50% -2HP, 50%C -2HP +2T:PUNCTURE +1T:STUN",
		usage: {
			act: "%USER LUNGES AT %TARGET",
			crit: "%TARGET IS BRUTALLY STABBED",
			hit: "%TARGET TAKES A SOLID HIT",
			miss: "%TARGET ESCAPED BY A HAIR"
		},
		details: {
            flavor: "'utilize long limbs to eviscerate a target';'chance for immense physical trauma'",
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::stun] [STATUS::puncture]'`,
        },
        stats: {
            accuracy: .5,
            crit: 0.5,
            amt: 2,
            status: {
                stun: {
                    name: 'stun',
                    length: 1
                },
				puncture: {
                    name: 'puncture',
                    length: 2
                },
            },
        },
		exec: function(user, target) {
			return env.GENERIC_ACTIONS.singleTarget({
				action: this, 
				user, 
				target,
				critExec: ({target})=>{
					addStatus({target, status: "stun", length: 1});
					addStatus({target, status: "puncture", length: 2});
				}
			})
		}
	}
	
	env.ACTIONS.special_fullauto_secri = {
		slug: "special_fullauto_secri",
		name: "Wild Frenzy",
		type: 'special',
		desc: "'utilize long limbs';'rapid inaccurate attacks'",
		anim: "wobble",
		help: "x6 RANDOM ENEMY::33% -1HP +2T:PUNCTURE 33%C x2 +2T:PUNCTURE",
		usage: {
			act: "%USER UNLEASHES A FLURRY OF SWINGS",
		},
		details: {
            flavor: "'utilize long limbs';'rapid inaccurate attacks'",
            onUse: `'HIT random foes 6 times'`,
            onHit: `'[STAT::amt] [STATUS::puncture]'`,
            onCrit:`'[STATUS::puncture]'`
        },
        stats: {
            accuracy: .33,
            crit: 0.33,
            amt: 1,
            status: {
                puncture: {
                    name: 'puncture',
                    length: 2
                },
            },
        },
		exec: function(user, target, beingUsedAsync) {
			let initialRate = env.bgm.rate()

			play('click1')

			let targetTeam
			switch(user.team.name) {
				case "ally": targetTeam = env.rpg.enemyTeam; break;
				case "enemy": targetTeam = env.rpg.allyTeam; break;
			}

			let anim = env.COMBAT_ANIMS.shoot
			let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

			if(validTargets.length) for (let i = 0; i < 6; i++) {
				let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
				let animDelay = baseDelay + anim.duration;
				if(validTargets) {
					let target = validTargets.sample()
					
					setTimeout(()=>anim.exec(this, user, target), baseDelay)
					setTimeout(()=>{
						env.GENERIC_ACTIONS.singleTarget({
							action: this,
							user,
							target,
							hitSfx: { name: "stab", rate: 1.5, volume: 0.5 },
							critSfx: { name: "stab", rate: 0.75 },
							missSfx: { name: "miss", rate: 1.5, volume: 0.5 },
							hitStatus: {
								name: 'puncture',
								length: 2
							},
							critStatus: {
								name: 'puncture',
								length: 2
							},
						})
					}, animDelay)
				}
			}

			setTimeout(()=>{
				if(!beingUsedAsync) advanceTurn(user)
			}, (env.ADVANCE_RATE * 0.2) * 7)
		}
	}
		// maybe we just don't use this one
	env.ACTIONS.special_secri_infest = {
        slug: "special_secri_infest",
        name: "Infest",
        type: 'special',
        desc: "'eject microscopic spores';'cause decay in foes'",
        help: "FOES::40% -1HP +3T:ROT, 10% x2 +3T:ROT +2T:FEAR",
        anim: "orbshake",
        accuracy: 0.4,
        crit: 0.1,
        amt: 1,
        usage: {
            act: "%USER INFESTS THEIR FOES"
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this

            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action: action, 
                        user, 
                        target: actor,
                        hitSfx: { name: 'talksignal', rate: 1 },
                        critSfx: { name: 'stab', rate: 0.75 },
                        hitStatus: {
                            name: 'rot',
                            length: 3
                        },
                        critExec: ({target}) => {
							addStatus({target, status: "rot", length: 3, noReact: true})
							addStatus({target, status: "fear", length: 2})
                        }
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.husk_attack_impulse = {
        slug: "husk_attack_impulse",
        name: "Familiar Strike",
        type: 'target',
        desc: "'utilized warped limbs to strike target';'occasionally terrifying'",
        anim: "basic-attack",
        help: "80% -2HP, 10%C x2 + (TARGET TEAM::+2T:FEAR)",
        usage: {
            act: "%USER SPRINTS AT %TARGET",
            crit: "%TARGET FACES THEIR MORTALITY",
            hit: "%TARGET IS STRUCK WITH BROKEN LIMBS",
            miss: "%TARGET EVADES"
        },
        accuracy: 0.8,
        crit: 0.1,
        amt: 2,
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,

                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: target.team,
                    exec: (actor, i)=>{
                        addStatus({target: actor, origin: user, status: "fear", origin: user, length: 2}); 
                        play('fear', 0.75);
                    }
                })
            })
        }
    },
	
	env.ACTIONS.intrusive_smash_weak = {
        slug: "intrusive_smash_weak",
        name: "Unnatural Claw",
        verb: "claw at",
        type: 'target',
        desc: "'utilize unpredictable weaponry';'guarantee of trauma'",
        anim: "basic-attack",
        help: "70% -2HP + ONE OF (+2T:OPEN WOUND, +3T:VULNERABLE +CRITICAL FLAW, +1T:STUN), 30%C x2",
        usage: {
            act: "%USER ATTACKS %TARGET",
            crit: "A FRIGHTENING BLOW",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET EVADES"
        },
        accuracy: 0.7,
        crit: 0.3,
        amt: 2,
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'dull',
                    rate: 1.25
                },

                hitExec: ({target})=> {
                    let rand = Math.random()
                    if(rand < 0.3) {
                        addStatus({target, origin: user, status: "open_wound", origin: user, length: 2}); 
                        
                    } else if(rand < 0.6) {
                        addStatus({target, origin: user, status: "vulnerable", origin: user, length: 3}); 
						addStatus({target, origin: user, status: "critical_flaw", origin: user, length: 1}); 

                    } else {
                        addStatus({target, origin: user, status: "stun", origin: user, length: 1}); 
                    }
                }
            })
        }
    },
	
	env.ACTIONS.windup_surge = {
        slug: "windup_surge",
        name: "Prepare Surge",
        type: 'autohit',
        desc: "'prepare pair of devastating attacks';'briefly lose defensive focus'",
        anim: "",
        help: "+WINDUP +SURGE",
        usage: {
            act: "%USER PREPARES AN ATTACK..."
        },
		details: {
            flavor: `'prepare pair of devastating attacks'`,
            onUse: `'[STATUS::windup] [STATUS::surge]'`
        },
		stats: {
            status: {
                windup: {
                    name: 'windup',
                    length: 1
                },
				surge: {
                    name: 'surge',
                    length: 1
                }, 
            }
        },
        exec: function(user, target) {
            play('talkchoir7', 2);
            addStatus({target: user, status: "windup", length: 1}); 
			addStatus({target: user, status: "surge", length: 1}); 
            return 'nothing';
        }
    },
	
	env.ACTIONS.detonate_weak = {
        slug: "detonate_weak",
        name: "Detonate",
        type: 'target',
        desc: "'detonate to instantly destroy target'",
        anim: "basic-attack",
        help: "AUTOHIT -10HP, DESTROY SELF\nONCE PER COMBAT",
        usage: {
            act: "%USER EXPLODES NEAR %TARGET",
            hit: "%TARGET IS DESTROYED",
        },
        autohit: true,
        amt: 10,
        exec: function(user, target) {
            user.hp = 0
            user.detonated = true
            updateStats({actor: user})
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'dull',
                    rate: 0.66
                },
            })
        },
        disableIf: (actor)=>{ if(actor.detonated) return "ONCE PER COMBAT" },
    },
	
    env.ACTIONS.detonate_mega = {
        slug: "detonate_mega",
        name: "Detonate",
        type: 'special',
        desc: "'detonate to instantly destroy target'",
        help: "FOES::AUTOHIT -100000000000000HP, DESTROY SELF\nONCE PER COMBAT",
        anim: "basic-attack",
        autohit: true,
        amt: 100000000000000,
        usage: {
            act: "%USER EXPLODES"
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
                    let anim = env.COMBAT_ANIMS.flare
                    let baseDelay = ((env.ADVANCE_RATE * 0.1) * i)
                    let animDelay = baseDelay + anim.duration;
                        
                    setTimeout(()=>anim.exec(action, user, actor), baseDelay)
                    setTimeout(function(){
                        env.GENERIC_ACTIONS.singleTarget({
                            beneficial: true,
                            action: action, 
                            user, 
                            target: actor,
                            hitSfx: { name: 'dull', rate: 0.5 },
                            critSfx: { name: 'shot6', rate: 0.75 },
                        })
                    }, animDelay);
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
			user.hp = 0
			user.detonated = true
			updateStats({actor: user})
        }
    },

	env.ACTIONS.detonate_mega_cmb = {
        slug: "detonate_mega_cmb",
        name: "Singularity",
        type: 'special',
        desc: "'detonate to instantly destroy target'",
        help: "FOES::AUTOHIT -100000000000000HP, DESTROY SELF\nONCE PER COMBAT",
        anim: "basic-attack",
        autohit: true,
        amt: 100000000000000,
        usage: {
            act: "%USER EXPLODES"
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
                    let anim = env.COMBAT_ANIMS.flare
                    let baseDelay = ((env.ADVANCE_RATE * 0.4) * i)
                    let animDelay = baseDelay + anim.duration;
                        
                    setTimeout(()=>anim.exec(action, user, actor), baseDelay)
                    setTimeout(function(){
                        env.GENERIC_ACTIONS.singleTarget({
                            beneficial: true,
                            action: action, 
                            user, 
                            target: actor,
                            hitSfx: { name: 'shot', rate: 0.5 },
                            critSfx: { name: 'shot6', rate: 0.75 },
                        })
                    }, animDelay);
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
			user.detonated = true
			updateStats({actor: user})
        }
    },

		//this is da real trusive primary oops :P
	env.ACTIONS.trusive_smash_weak = { //just here so that it can be used with surge :P
        slug: "trusive_smash_weak",
        name: "Unnatural Claw",
        verb: "claw at",
        type: 'target',
        desc: "'utilize unpredictable weaponry';'guarantee of trauma'",
        anim: "basic-attack",
        help: "70% -2HP + ONE OF (+2T:OPEN WOUND, +3T:VULNERABLE +CRITICAL FLAW, +1T:STUN), 30%C x2",
        usage: {
            act: "%USER ATTACKS %TARGET",
            crit: "A FRIGHTENING BLOW",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET EVADES"
        },
		details: {
            flavor: "'utilize incoherent weaponry';'guarantee of trauma'", 
            onHit: "'[STAT::amt]';'inflict one of following';'[STATUS::stun]';'[STATUS::open_wound]';'[STATUS::vulnerable], [STATUS::critical_flaw]'",
        },
        
        stats: {
            accuracy: 0.7,
            crit: 0.3, 
            amt: 2,
            status: { 
                stun: {
                    name: 'stun',
                    length: 1
                },
                open_wound: {
                    name: 'open_wound',
                    length: 2
                },
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },
                critical_flaw: {
                    name: 'critical_flaw',
                    length: 1
                },

            }
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'dull',
                    rate: 1.25
                },

                hitExec: ({target})=> {
                    let rand = Math.random()
                    if(rand < 0.3) {
                        addStatus({target, origin: user, status: "open_wound", origin: user, length: 2}); 
                        
                    } else if(rand < 0.6) {
                        addStatus({target, origin: user, status: "vulnerable", origin: user, length: 2}); 
						addStatus({target, origin: user, status: "critical_flaw", origin: user, length: 1}); 

                    } else {
                        addStatus({target, origin: user, status: "stun", origin: user, length: 1}); 
                    }
                }
            })
        }
    },
	
    env.ACTIONS.special_surge_allies_mega = {
        slug: "special_surge_allies_mega",
        name: "Surging Offense",
        type: 'special',
        desc: "'inspire allies to attack madly'",
        help: "ALLIES::+SURGE +1T:FOCUSED",
        anim: "heal",
        autohit: true,
        crit: 0,
        usage: {
            act: "%USER COMMANDS THEIR ALLIES TO STRIKE"
        },
        exec: function(user, target, beingUsedAsync) {
            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {

                    play("talkchoir7", 2)
                    addStatus({target: actor, status: "surge", length: 1});
					addStatus({target: actor, status: "focused", length: 1});
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	//weak mending cover doesn't exist anymore !! fuck !!
    special_restorative_barrier_weak = {
        slug: "special_restorative_barrier_weak",
        name: "Mending Cover",
        type: 'special',
        anim: "cloak-barrier",
        animDuration: 4000,
        autohit: true,
        usage: {
            act: "%USER SHIELDS THEIR ALLIES"
        },
        details: {
            flavor: "'broadly apply ablative protection';'upgraded barrier mends wounds while active'",
            onUse: `'[STAT::amtBP] [STATUS::repairs] to nearby allies';'[STATUS::weakened] to user'`,
        },
        stats: {
            crit: 0,
            amtBP: 1,
            amt: 0,
            status: { 
                repairs: {
                    name: 'repairs', 
                    length: 1
                },
				weakened: {
                    name: 'weakened', 
                    length: 1
                },
            } 
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
			addStatus({target: user, status: "weakened", origin: user, length: 1}); 

            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        beneficial: true,
                        type: 'barrier',
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'mend',
                            rate: 2
                        },
                        hitStatus: {
                            name: 'repairs',
                            length: 1
                        },
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
    env.ACTIONS.heart_whelm = { //mostly doing these so that the actions will actually have descriptions
        slug: "heart_whelm",
        name: "Formless Swipe",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER CHARGES AT %TARGET",
            crit: "%TARGET IS KNOCKED BACK",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET EVADES"
        },
		details: {
            onHit: `'[STAT::amt]'`,
        },
        stats: {
            range: 1,
            accuracy: 0.7,
            crit: 0.3,
            amt: 1
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitExec: ({target})=>{ // has a knockback in combat-scene
                    if(env?.rpg?.is2D) {
                        if(target.piece && user.piece) target.piece.knockback({
                            direction: user?.piece?.tile.getRelativeDirection(target?.piece?.tile), 
                            strength: 2, 
                            onImpact: ()=> play("hit", 0.5)
                        })
                    }
                }
            })
        }
    },
	
    env.ACTIONS.heart_punch = {
        slug: "heart_punch",
        name: "Big Punch",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER SWINGS AT %TARGET",
            crit: "%TARGET IS KNOCKED BACK",
            hit: "%TARGET STAGGERS BACK",
            miss: "%TARGET EVADES"
        },
        details: {
            onHit: `'[STAT::amt]'`,
            onCrit: `'[STATUS::stun]'`,
        },
        stats: {
            accuracy: 0.8,
            crit: 0.2,
            amt: 2,
            status: {
                stun: {
                    name: 'stun',
                    length: 1
                }
            }
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                critStatus: this.stats.status.stun
            })
        }
    },
	
	env.ACTIONS.heart_ied = {
        slug: "heart_ied",
        name: "Dullbomb",
        verb: "throw at",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER TOSSES AN EXPLOSIVE AT %TARGET",
            crit: "SHRAPNEL SPRINGS AROUND THE ROOM",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET DODGES"
        },
        
        details: {
            onHit: `'[STAT::amt]'`,
            onCrit: () => `'HIT all foes for [STAT::amt] [STATUS::puncture]'${page.name == "frame" ? `;'additional hits trigger on-hit effects'` : ``}`,
        },

        stats: {
            accuracy: .9,
            crit: 0.5,
            amt: 1,
            status: {
                puncture: {
                    name: 'puncture',
                    length: 1
                }
            },
        },
        
        exec: function(user, target) {
            let action = this;
            return env.GENERIC_ACTIONS.singleTarget({
                action, 
                user, 
                target,

                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i) => {
                        env.GENERIC_ACTIONS.singleTarget({
                            action, 
                            user, 
                            target: actor,
                            hitSfx: { name: 'shot4' },
                            hitStatus: this.stats.status.puncture,
                            canCrit: false
                        })
                    }
                })
            })
        }
    },
	
    env.ACTIONS.windup_telegraph_flat = {
        slug: "windup_telegraph_flat",
        name: "Telegraph",
        type: 'autohit',
        anim: "",
        usage: {
            act: "%USER PREPARES AN ATTACK"
        },
        details: {
            flavor: `'prepare a telegraphed attack'`,
            onUse: `'[STATUS::windup_telegraph_flat]'`
        },
        stats: {
            status: {
                windup_telegraph_flat: {
                    name: 'windup_telegraph_flat',
                    length: 1
                },
            }
        },
        exec: function(user, target) {
            play('talklaugh', 0.75);
            addStatus({target: user, status: "windup_telegraph_flat", length: 1}); 
            return 'nothing';
        }
    },
    
	env.ACTIONS.windup_telegraph_flicker = {
        slug: "windup_telegraph_flicker",
        name: "Flicker",
        type: 'autohit',
        anim: "skitter",
        usage: {
            act: "%USER FLICKERS AWAY"
        },
        details: {
            onUse: () => `'gain [STATUS::evasion_mega] and [STATUS::windup_telegraph_flat]'`,
            flavor: "'focus on evading incoming attacks';'hide vulnerabilities'"
        },
        stats: {
            status: {
                evasion_mega: {
                    name: 'evasion_mega',
                    length: 1
                },  
				windup_telegraph_flat: {
                    name: 'windup_telegraph_flat',
                    length: 1
                }, 				
            }
        },
        exec: function(user, target) {
            addStatus({target: user, status: "evasion_mega", length: 1, noReact: true}); 
			addStatus({target: user, status: "windup_telegraph_flat", length: 1, noReact: true}); 
			play('talkfairy', 0.75)
            return 'nothing';
        },
        avoidChaining: true,
    },
	
    env.ACTIONS.heart_harasser_stab = {
        slug: "heart_harasser_stab",
        name: "Flickering Stab",
        type: 'target', 
        anim: "basic-attack",
        usage: {
            act: "%USER FLICKERS TOWARDS %TARGET",
            crit: "%TARGET IS EVISCERATED",
            hit: "%TARGET BLEEDS SLUDGY CORRU",
            miss: "%TARGET EVADES"
        },
		details: {
            flavor: "'reshape arm into sharpened tendril';'stab target'",
            onHit: `'[STAT::amt] [STATUS::puncture]'`,
            onCrit: `'[STATUS::fear]'`,
        },
        stats: {
            range: 1,
            accuracy: 2.75,
            crit: 0.2,
            amt: 1,
            status: {
                puncture: {
                    name: 'puncture',
                    length: 2
                },
                fear: {
                    name: 'fear',
                    length: 1
                }
            }
        },
        exec: function(user, target) {
			removeStatus(user, "windup_telegraph_flat")
			return env.GENERIC_ACTIONS.singleTarget({
				action: this, 
				user, 
				target,
				hitSfx: {
					name: 'stab',
					rate: 1
				},
				critSfx: {
					name: 'fear',
					rate: 1
				},
				critStatus: this.stats.status.fear,
				hitStatus: this.stats.status.puncture
			})
        }
    },
	
    env.ACTIONS.heart_tele_channel = {
        slug: "heart_tele_channel",
        name: "Channel",
        type: 'target',
        anim: "skitter",
        usage: {
            act: "%USER BENDS THE OVERLAP",
        },
        details: {
            onUse: `'[STATUS::channeling] to user';'[STATUS::channeledUpon] to target'`,
        },
        stats: {
            autohit: true,
            crit: 0,
            status: {
                channeling: {
                    name: 'channeling',
                    length: 1
                },
                channeledUpon: {
                    name: 'channeledUpon',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
			removeStatus(user, "windup_telegraph_flat")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'scarydoia',
                    rate: 1.1
                },
                hitExec: ()=>{
                    reactDialogue(user, `give_fear`)
					addStatus({ target: user, status: "channeling_flat", origin: user, length: 1 })
					addStatus({ target, status: "channeledUpon_flat", origin: user, length: 1 }) //really really hoping this works out because boy howdy i do not know how to make it work otherwise (we figured it out :P)
                },
            })
        }
    },
	
    env.ACTIONS.heart_hulk_rampage = {
        slug: "heart_hulk_rampage",
        name: "Wild Strike",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER CHARGES!",
            crit: "%TARGET IS KNOCKED BACK",
            hit: "%TARGET STAGGERS BACK",
            miss: "%TARGET EVADES"
        },
		details: {
            onHit: `'[STAT::amt]';'[STAT::selfHP] [STATUS::vulnerable] to all foes'`,
			onCrit: `'[STATUS::stun]';'additional [STAT::selfHP] [STATUS::vulnerable] to all foes''`
        },
        stats: {
            accuracy: 0.8,
            crit: 0.2,
            amt: 2,
			selfHP: 1,
            status: {
                stun: { name: 'stun', length: 1 },
				vulnerable: { name: 'vulnerable', length: 1 }
            }
        },
        exec: function(user, target) {
			removeStatus(user, "windup_telegraph_flat")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                critStatus: this.stats.status.stun,
				hitExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
					extraDelay: 200,
                    exec: (actor, i)=>{
						if(actor.slug == target.slug) return;
                        combatHit(actor, {amt: 1, crit: 0.2, accuracy: 0.8, origin: user});
                        addStatus({target: actor, status: "vulnerable", length: 1}); 
                        play("hit", 2)
                    }
                }),
				critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
					extraDelay: 100,
                    exec: (actor, i)=>{
						if(actor.slug == target.slug) return;
                        combatHit(actor, {amt: 1, crit: 0.2, accuracy: 0.8, origin: user});
                        addStatus({target: actor, status: "vulnerable", length: 1}); 
                        play("hit", 2)
                    }
                })
            })
        },
    },
	
    env.ACTIONS.heart_pull = {
        slug: "heart_pull",
        name: "Pull",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER GRABS AT %TARGET",
            hit: "%TARGET IS PULLED",
			crit: "%TARGET IS FLUNG THROUGH THE OVERLAP",
            miss: "%TARGET EVADES"
        },
		details: {
			flavor: `harsh pull to remove foe from advantageous position`,
            onHit: `'[STAT::amt]';'[STATUS::vulnerable]'`,
			onCrit: `'[STATUS::destabilized]';'random additional damage'`
        },
        stats: {
            range: 4,
            accuracy: 1,
			crit: 0.2,
            kb: 1,
            amt: 1,
            status: {
                vulnerable: { name: 'vulnerable', length: 2 },
				destabilized: { name: 'destabilized', length: 2 }
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'miss',
                    rate: 0.5
                },
				critSfx: {
                    name: 'miss',
                    rate: 0.5
                },
                hitStatus: this.stats.status.vulnerable,
                specialAutohit: target.team.name == user.team.name,
                critExec: ({target}) => {
					setTimeout(()=>{
						let randomAmt = randomInt(1, 4)
						addStatus({target, status: "destabilized", length: 2});
						combatHit(target, {amt: randomAmt, crit: 0, autohit: true, origin: user});
						playCombatCrit()
					}, env.ADVANCE_RATE * 0.5)
                },
            })
        },
    },
	
    env.ACTIONS.heart_support = {
        slug: "heart_support",
        name: "Coil",
        type: 'support+target',
        anim: "heal",
        beneficial: true,
        usage: {
            act: "%USER COILS AROUND %TARGET",
        },
        details: {
            onHit: `'[STAT::amt] [STATUS::coiled_flat] to target';'[STATUS::coiling_flat] to user'`,
        },
        stats: {
            range: 2,
            crit: 0,
            autohit: true,
            amt: -1,
            status: {
                coiled_flat: { name: 'coiled_flat', length: 1 },
				coiling_flat: { name: 'coiling_flat', length: 1 }
            }
        },
        exec: function(user, target) {
			removeStatus(user, "windup_telegraph_flat")
            return env.GENERIC_ACTIONS.singleTarget({
                beneficial: true,
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'mend',
                    rate: 1
                },
				hitExec: ({target})=> {
					addStatus({target: target, status: "coiled_flat", origin: user, length: 1})
					addStatus({target: user, status: "coiling_flat", length: 1})
				}
            })
        },
    },
	
    env.ACTIONS.heart_golem_lunge = {
        slug: "heart_golem_lunge",
        name: "Ethereal Lunge",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER LUNGES AT %TARGET",
            crit: "%USER PREPARES A FOLLOW-UP STRIKE...",
            hit: "%TARGET IS KNOCKED BACK",
            miss: "%TARGET EVADES"
        },
		details: {
            onHit: `'[STAT::amt]'`,
			onCrit: `'[STATUS::puncture] to target';'[STATUS::windup] to user'`,
        },
        stats: {
            range: 3,
            accuracy: 1,
            crit: 0.3,
            amt: 2,
            status: {
                puncture: { name: 'puncture', length: 1 },
				windup: { name: 'windup', length: 1 }
            }
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'stab',
                    rate: 1
                },
                critExec: ({target}) => {
					addStatus({target: user, status: "windup", length: 1});
					addStatus({target: target, status: "puncture", origin: user, length: 1}); 
                }
            })
        },
    },
	
	env.ACTIONS.heart_combo = {
        slug: "heart_combo",
        name: "Dull Combo",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER SWINGS AT %TARGET",
            crit: "%USER PREPARES A FOLLOW-UP DULL PULSE...",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET EVADES"
        },
		details: {
            onHit: `'[STAT::amt]'`,
			onCrit: `'[STATUS::fear] to target';'[STATUS::windup] to user'`,
        },
        stats: {
            range: 3,
            accuracy: 1,
            crit: 0.5,
            amt: 1,
            status: {
                fear: { name: 'fear', length: 1 },
				windup: { name: 'windup', length: 1 }
            }
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                critExec: ({target}) => {
					addStatus({target: user, status: "windup", length: 1});
					addStatus({target: target, status: "fear", origin: user, length: 1}); 
                }
            })
        },
    },
	
	env.ACTIONS.special_guard_all_debug = {
        slug: "special_guard_all_debug",
        name: "Frontline",
        type: 'special',
        anim: "basic-attack",
        usage: {
            act: "%USER NEEDS TO TEST SOMETHING"
        },
        details: {
            flavor: "'attain hyper-awareness of proceedings';'intercept all attacks on allies'",
            onUse: `'[STATUS::redirection] to all allies'`,
        },
        stats: {
            status: {
                redirection: {
                    name: 'redirection',
                    length: 2
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
            reactDialogue(user, `give_redirection`)
            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
                    if(actor.slug == user.slug) return
                    addStatus({target: actor, origin: user, status: "redirection", length: 2}); 
					addStatus({target: actor, origin: user, status: "immobile_hardskip", length: 1}); 
                    play('guard', 2, 0.75);
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.special_debug = {
        slug: "special_debug",
        name: "Interrupt",
        type: 'special',
        anim: "basic-attack",
        usage: {
            act: "%USER NEEDS TO TEST SOMETHING"
        },
        details: {
            flavor: "'utilize testing assistance thoughtform';'implement system interruption'",
            onUse: `'[STATUS::immobile] [STATUS::invincible] to all foes'`,
        },
        stats: {
            status: {
                immobile: {
                    name: 'immobile',
                    length: 1
                },
				invincible: {
                    name: 'invincible',
                    length: 1
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
            reactDialogue(user, `give_redirection`)
            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
                    if(actor.slug == user.slug) return
                    addStatus({target: actor, origin: user, status: "invincible", length: 1}); 
					addStatus({target: actor, origin: user, status: "immobile", length: 1}); 
                    play('guard', 2, 0.75);
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
		// i have to get this creature out of my brain and into da code so that i may know peace again
	env.ACTIONS.special_hazardshelf_annihilate = {
        slug: "special_hazardshelf_annihilate",
        name: "Annihilation",
        type: 'special+nomimic',
        anim: "wobble",
        choiceAnim: "special_choice-movefriend",
        choiceAnimDuration: 200,
        help: "CHOOSE::100% -3HP ::OR:: 50% -2HP 50%C -2HP +1T:STUN +2T:PUNCTURE",
		possibleSpawns: ["hazardous_deconstructor", "hazardous_dullfriend", "hazardous_archival", "hazardous_archival", "hazardous_veilklight", "hazardous_veilklight", "hazardous_velskin", "hazardous_sniper", "hazardous_shotgunner", "hazardous_kivskin", "hazardous_basic_golem", "hazardous_slasher", "hazardous_bomber"], //put stuff in here later (did not make the combat actors later, i got too hyperfixated :P)
        usage: {
            act: "%USER LUNGES AT %TARGET",
            crit: "%TARGET IS UNRECOGNIZEABLE",
            hit: "%TARGET IS BRUTALLY STABBED",
            miss: "%TARGET ESCAPED BY A HAIR"
        },
        details: {
            onUse: `'present target foe a choice of outcome'`,
            conditional: `HIT???::<em>AHHAHÃ«AVAHHÃµAHÃ§BÂ¬â‚¬A(:AÃ HHAÂ®Ã´AÃˆHÂ¶Ã¡CybEÃHA</em>'`
        },
        stats: {
            hit1HP: 6,
            hit1ACC: 200,
            hit2HP: 2,
            hit2ACC: 75,
            hit2CRIT: 75,

            status: {
                stun: { name: 'stun', length: 1 },
                puncture: { name: 'puncture', length: 2 }
            },
        },
        noRepeat: true,
        exec: function(user, target) {
            user.sprite.classList.add('special_choice-movefriend')
            let action = this

            //summon a div that lets the player click guaranteed or chance
            actionChoice({
                user: user,
                action: action,
                choiceText: `Ã€HHAÂ¾3AÂ«Å’HE lunges at ${target.name}...`,
                options: [
                    {text: "Withstand the attack", definition: "NOTE::'200% -8HP +2T:PUNCTURE 5%C x2 +1T:STUN +2T:PUNCTURE +2T:UNNATURAL WOUND, SUMMON +2 HAZARDOUS ENTITIES (MAX:6)'"},
                    {text: "Try a risky dodge", definition: "NOTE::'80% -4HP +2T:PUNCTURE 60%C x2 +1T:STUN +2T:PUNCTURE +2T:UNNATURAL WOUND, SUMMON +2 HAZARDOUS ENTITIES (MAX:6)'"},
					{text: "Plead for mercy", definition: "NOTE::'+4HP, +3T:REGEN, -UNNATURAL WOUND, -STUN, SUMMON +1 HAZARDOUS ENTITY'"},
                ],
                choiceCallback: (c) => {
                    //reap the consequences
                    user.sprite.classList.add(action.anim)
                        
                    var hit
                    switch(c) {
                        case "c0":
                            hit = combatHit(target, {amt: 8, acc: 2, crit: 0.05, origin: user});
                            break;
                        case "c1":
                            hit = combatHit(target, {amt: 4, acc: 0.8, crit: 0.6, origin: user})
                            break
						case "c2":
                            hit = play('dull', 0.6)
								if(user.team.members.filter(m=>m.slug.includes('hazard')).length < 7) {
								midCombatActorAdd(env.rpg.enemyTeam, this.possibleSpawns.sample(), 'left')
								actionMessage(user, "%USER LAUGHS MANIACALLY", target)
								combatHit(target, {amt: -4, autohit: true, crit: 0, beneficial: true, origin: user})
								addStatus({target: target, origin: user, status: "regen", length: 4})
								removeStatus(target, "unnatural_wound")
								removeStatus(target, "stun")
								setTimeout(()=> play('talklaugh', 0.6), env.ADVANCE_RATE * 1.5)
							} else {
								actionMessage(user, "%USER LAUGHS MANIACALLY", target)
								useAction(user, env.ACTIONS.special_mass_denature, user, {triggerActionUseEvent: false, beingUsedAsync: true})
								setTimeout(()=> play('talklaugh', 0.6), env.ADVANCE_RATE * 1.5)
							}
                            break
                    }

                    actionMessage(user, action, target, hit)
                    switch(hit) {
                        case "crit":
                            playCombatCrit('crit', 0.6)
                            addStatus({target: target, origin: user, status: "stun", length: 1})
                            addStatus({target: target, origin: user, status: "puncture", length: 2})
							addStatus({target: target, origin: user, status: "unnatural_wound", length: 2, noReact: true})
							if(user.team.members.filter(m=>m.slug.includes('hazard')).length < 7) {
								setTimeout(()=> {
									midCombatActorAdd(env.rpg.enemyTeam, this.possibleSpawns.sample(), 'left');
									midCombatActorAdd(env.rpg.enemyTeam, this.possibleSpawns.sample(), 'right');
									play('dull', 0.6) }, env.ADVANCE_RATE * 0.75);
							}
							setTimeout(()=> { play('talklaugh', 0.6) }, env.ADVANCE_RATE * 2.5);
                            removeStatus(target, "windup")
                            break
                        case true:
                            reactDialogue(target, 'receive_crit')
							addStatus({target: target, origin: user, status: "puncture", length: 2})
                            play("stab", 0.6)
                            break;
                        case false:
                            reactDialogue(target, 'evade')
                            play("miss", 0.6)
                            break;
                    }

                    setTimeout(()=> user.sprite.classList.remove(action.anim), 600);
                    setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE);
                }
            })
        }
    },
	
	env.ACTIONS.special_attack_all_wound = {
        slug: "special_attack_all_wound",
        name: "Explosive",
        type: 'special',
        anim: "basic-attack",
        usage: {
            act: "%USER DEPLOYS A KAVRUKA"
        },
        details: {
            flavor: "'utilize volatile deconstruction tool'",
            onUse: `'HIT all foes'`,
            onHit: `'[STAT::amt]'`,
            onCrit: `'[STATUS::stun]'`
        },
        stats: {
            accuracy: 0.8,
            crit: 0.3,
            amt: 1,
            status: {
                stun: { name: "stun", length: 1 },
            }
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup")
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
                    let anim = env.COMBAT_ANIMS.shoot
                    let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
                    let animDelay = baseDelay + anim.duration * 0.5;
                        
                    setTimeout(()=>anim.exec(action, user, actor), baseDelay)
                    setTimeout(function(){
                        env.GENERIC_ACTIONS.singleTarget({
                            beneficial: true,
                            action: action, 
                            user, 
                            target: actor,
                            hitSfx: { name: 'shot2' },
                            critSfx: { name: 'shot6' },
                            critStatus: {
                                name: 'stun',
                                length: 1
                            },
                        })
                    }, animDelay);
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.disabler_pulse_wound = {
        slug: "disabler_pulse_wound",
        name: "Disabler Pulse",
        verb: "disable",
        type: 'target+autohit',
        anim: "basic-attack",
        usage: {
            act: "%USER LETS LOOSE THE DISABLER",
            hit: "%TARGET IS ANNIHILATED",
        },
        details: {
            flavor: "'emergency security device';'injects self-destructive thoughtform';'for industrial use only'",
            onHit: `'[STAT::amt] [STATUS::stun]'`,
        },
        stats: {
            autohit: true,
            crit: 10,
            amt: 5,
            status: {
                stun: {
                    name: "stun",
                    length: 3
                }
            }
        },
        exec: function(user, target) {
			removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'shot1',
                    rate: 1.1
                },
                critStatus: {
                    name: 'stun',
                    length: 3
                }
            })
        }
    },
	
	env.ACTIONS.barrier_reverse = {
        slug: "barrier_reverse",
        name: "Parasitic Barrier",
        verb: "shield",
        type: 'target+autohit',
        anim: "heal",
        usage: {
            act: "%USER SHIELDS %TARGET?",
            crit: "%TARGET FEELS ILL",
            hit: "%TARGET GAINS A THIN BARRIER",
            miss: "IT DOES NOT STICK"
        },
        details: {
            flavor: "apply ablative corru layer to target';'subvert defenses'",
            onHit: `'[STAT::amtBP]';'inflict one of following';'[STATUS::million_teeth]';'[STATUS::fractalline]';'[STATUS::porous]'`,
            onCrit: `'additional [STAT::amtBP]';'inflict one of following';'[STATUS::million_teeth]';'[STATUS::fractalline]';'[STATUS::porous]'`,
        },
        stats: {
            crit: 0.2,
            amt: 2,
            amtBP: 2,
			status: {
				million_teeth: { name: "million_teeth", length: 1 },
				fractalline: { name: "fractalline", length: 1 },
				porous: { name: "porous", length: 1 },
			}
        },
        autohit: true,
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                beneficial: true,
                type: 'barrier',
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'talkfairy',
                    rate: 1.5
                },
				critSfx: {
                    name: 'talkfairy',
                    rate: 1
                },
				critExec: ({target})=> {
					let rand = Math.random()
                    if(rand < 0.3) {
                        addStatus({target, origin: user, status: "million_teeth", origin: user, length: 1}); 
                        
                    } else if(rand < 0.6) {
                        addStatus({target, origin: user, status: "fractalline", origin: user, length: 1}); 

                    } else {
                        addStatus({target, origin: user, status: "porous", origin: user, length: 1}); 
                    }
				},
				hitExec: ({target})=> {
					let rand1 = Math.random()
                    if(rand1 < 0.3) {
                        addStatus({target, origin: user, status: "million_teeth", origin: user, length: 1}); 
                        
                    } else if(rand1 < 0.6) {
                        addStatus({target, origin: user, status: "fractalline", origin: user, length: 1}); 

                    } else {
                        addStatus({target, origin: user, status: "porous", origin: user, length: 1}); 
                    }
				}
            })
        }
    },
	
	env.ACTIONS.special_limited_uncarapace = {
        slug: "special_limited_uncarapace",
        name: "Strip Carapace",
        type: 'special',
        anim: "skitter",
        usage: {
            act: "%USER RENDS THE FLESH OF THEIR FOES"
        },
        details: {
            onUse:`'[STAT::amt] [STATUS::open_wound] [STATUS::vulnerable] to all foes';'usable once per combat'`,
        },
        stats: {
			autohit: true,
			canCrit: false,
			amt: 2,
            status: {
                open_wound: {
                    name: 'open_wound',
                    length: 4
                },
				vulnerable: {
                    name: 'vulnerable',
                    length: 4
                },
            },
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkfairy", 0.25)
            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "open_wound", origin: user, length: 4, noReact: true}); 
					addStatus({target: actor, origin: user, status: "vulnerable", origin: user, length: 4, noReact: true});
                    play('stab', 0.6);
					user.actions = user.actions.filter(action => action !== "special_limited_uncarapace")
                },
				advanceAfterExec: true, beingUsedAsync, user,
            })
            return 'nothing'
        }
    },
	
	env.ACTIONS.husk_attack_focused = {
        slug: "husk_attack_focused",
        name: "Guiding Strike",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER SPRINTS AT %TARGET",
            crit: "%TARGET EMBOLDENS THEIR ALLIES",
            hit: "%TARGET IS STRUCK WITH METALLIC LIMBS",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: `'utilized mechanized limbs to strike target';'occasionally inspiring'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::focused] to all allies'`,
        },
        stats: {
            accuracy: 1,
            crit: 0.3,
            amt: 1,
            status: {
                focused: {
                    name: 'focused',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.team,
                    exec: (actor, i)=>{
                        addStatus({target: actor, origin: user, status: "focused", origin: user, length: 1}); 
                        play('mend', 0.5);
                    }
                })
            })
        }
    },
	
	env.ACTIONS.speak_focused = {
        slug: "speak_focused",
        name: "Translate",
        type: 'target+self+support',
        anim: "skitter",
		beneficial: true,
        usage: {
            act: "%USER APPROACHES %TARGET",
            crit: "%TARGET IS ENERGIZED",
            hit: "%USER WHISPERS SOMETHING TO %TARGET",
            miss: "%TARGET RECOILS"
        },
        details: {
            flavor: "'express aggressor signal directly';'embolden targeted ally'",
            onHit: `'[STATUS::focused]'`,
            onCrit:`'[STATUS::surge]'`,
        },
        stats: {
            autohit: true,
            crit: 0.2,
            amt: 0,
            status: {
                focused: {
                    name: 'focused',
                    length: 2
                },
                surge: {
                    name: 'surge',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'okidoia',
                    rate: 1.25
                },
                hitExec: ()=>{
                    reactDialogue(user, `give_fear`)
                },
                critSfx: {
                    name: 'scarydoia',
                    rate: 1
                },
                critStatus: {
                    name: 'surge',
                    length: 1
                },
                hitStatus: {
                    name: 'focused',
                    length: 2
                },
            })
        }
    },
	
	env.ACTIONS.frenzy_chainsaw = {
        slug: "frenzy_chainsaw",
        name: "Chainsaw",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER SLASHES %TARGET",
            crit: "%USER JUST KEEPS GOING",
            hit: "%TARGET BLEEDS SLUDGY CORRU",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'puncture vital cystic component';'may inspire additional stabbing'",
            onHit: `'[STAT::amt] [STATUS::puncture]'`,
            onCrit:`'use this action again'`,
        },
        stats: {
            accuracy: 1,
            crit: 0.4,
            amt: 2,
            status: {
                puncture: {
                    name: 'puncture',
                    length: 2
                }
            },
        },
        exec: function(user, target, beingUsedAsync, {actionMessageIndex} = {}) {
            let action = this
            return env.GENERIC_ACTIONS.singleTarget({
                action, 
                user, 
                target,
                hitSfx: {
                    name: 'stab',
                    rate: 0.9
                },
                critSfx: {
                    name: 'stab',
                    rate: 1.85
                },
                hitExec: ({target}) => {
                    addStatus({target, status: "puncture", length: 2});
                },
                critExec: ({target})=> {
                    if(target.hp > 0 && target.state != "lastStand") {
                        env.setTimeout(()=>{
                            useAction(user, this, target, {beingUsedAsync: true, reason: "chainsaw", actionMessageIndex})
                        }, 200)
                    }
                }
            })
        }
    },
	
	env.ACTIONS.special_fragmentation = {
        slug: "special_fragmentation",
        name: "Self-Destruct",
        type: 'special',
        anim: "wobble",
        usage: {
            act: "%USER EXPLODES",
        },
        details: {
            flavor: "'launch fragments of self via unsustainable means';'highly inaccurate'",
            onUse: `'HIT random foes 100 times'`,
            onHit: `'[STAT::amt]'`,
        },
        stats: {
            accuracy: .1,
            crit: 0.05,
            amt: 1,
        },
        exec: function(user, target, beingUsedAsync) {
			play('click1', 0.66)
			setTimeout(()=>{
				playCombatCrit('criticalError', 0.33)
				let animElement = user.sprite || user.box
				let initialRate = env.bgm.rate()
					
				env.rpg.classList.add('incoherentbg')
				content.classList.add('painprep', 'painfade', 'painhalf')
				setTimeout(()=>{content.classList.add('painmode')}, 200)
				setTimeout(()=>{content.classList.remove('painmode')}, 8000)
				setTimeout(()=>{content.classList.remove('painprep', 'painfade', 'painhalf')}, 10000)
				setTimeout(()=>{env.rpg.classList.remove('incoherentbg')}, 8000)

				if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)

				if(user.team.name == "enemy") { combatHit(user, {amt: 100, crit: 0, autohit: true, origin: user}) }
				else { combatHit(user, {amt: 10, crit: 0, autohit: true, origin: user}) }

				let targetTeam
				switch(user.team.name) {
					case "ally": targetTeam = env.rpg.enemyTeam; break;
					case "enemy": targetTeam = env.rpg.allyTeam; break;
				}

				let anim = env.COMBAT_ANIMS.flare
				let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

				if(validTargets.length) for (let i = 0; i < 100; i++) {
					let baseDelay = ((env.ADVANCE_RATE * 0.05) * i)
					let animDelay = baseDelay + anim.duration;
					if(validTargets) {
						let target = validTargets.sample()
						
						setTimeout(()=>anim.exec(this, user, target), baseDelay)
						setTimeout(()=>{
							env.GENERIC_ACTIONS.singleTarget({
								action: this, 
								user, 
								target,
								hitSfx: { name: "shot2", rate: 0.33, volume: 0.01 }, // we don't want the "explosion sound" to get pitch shifted by hit and miss sounds, so we set their rates to 0.25 anyway even if the player won't hear them
								critSfx: { name: "shot2", rate: 0.33, volume: 0.01 },
								missSfx: { name: "shot2", rate: 0.33, volume: 0.01 },
							})

							animElement.classList.add('scramble')
							setTimeout(()=>animElement.classList.remove('scramble'), 100)
						}, animDelay)
					}
				}

				setTimeout(()=>{              
					if(!beingUsedAsync) advanceTurn(user)
					if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
				}, (env.ADVANCE_RATE * 0.05) * 101)
			}, (env.ADVANCE_RATE * 0.66) )
        }
    },
	
	env.ACTIONS.distraction_cripple = {
        slug: "distraction_cripple",
        name: "Neural Feint",
        verb: "distract",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER FEINTS AND STRIKES %TARGET",
            crit: "%USER'S ALLIES ARE INSPIRED",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET DODGES"
        },
        details: {
            flavor: `'strike on neural center with clever feint';'may create distraction'`,
            onHit: `'[STAT::amt] [STATUS::stun]'`,
            onCrit: `'[STATUS::evasion] to allies'`,
            conditional: `<em>VS VULNERABLE::</em>'additional [STAT::amt]'`
        },
        stats: {
            accuracy: 1, 
            crit: 0.3,
            amt: 2,
            status: {
                evasion: {
                    name: 'evasion',
                    length: 2
                },
				stun: {
                    name: 'stun',
                    length: 1
                },
            },
		},
        exec: function(user, target) {
            let specialAmt = this.stats.amt + (hasStatus(target, 'vulnerable') ? 2 : 0)
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                specialAmt,
				hitStatus: this.stats.status.stun,
                critExec: ()=> {
					let targets = user.team.members
                    env.GENERIC_ACTIONS.teamWave({
                        arbitraryActorList: targets,
                        exec: (actor, i)=>{
                            addStatus({target: actor, origin: user, status: "evasion", origin: user, length: 2, noReact: true}); 
                            play('mend', 0.5);
                        }
                    })
                }
            })
        }
    },
	
	env.ACTIONS.speak_mega = {
        slug: "speak_mega",
        name: "Shriek",
        type: 'target',
        anim: "skitter",
        usage: {
            act: "%USER APPROACHES %TARGET",
            crit: "%TARGET IS PARALYZED BY FEAR",
            hit: "%USER SCREAMS",
            miss: "%TARGET RECOILS"
        },
        details: {
            flavor: "'utilize remains to speak';'express aggressor signal directly'",
            onHit: `'[STATUS::fear]'`,
            onCrit:`'[STATUS::stun]'`,
        },
        stats: {
            accuracy: 1,
            crit: 0.4,
            amt: 0,
            status: {
                fear: {
                    name: 'fear',
                    length: 4
                },
                stun: {
                    name: 'stun',
                    length: 2
                }
            },
        },
        exec: function(user, target) {
			removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'talkfairy5',
                    rate: 1.5
                },
                hitExec: ()=>{
                    reactDialogue(user, `give_fear`)
                },
                critSfx: {
                    name: 'talkfairy',
                    rate: 0.25
                },
                critStatus: {
                    name: 'stun',
                    length: 2
                },
                hitStatus: {
                    name: 'fear',
                    length: 4
                },
            })
        }
    },
	
	env.ACTIONS.special_guard_all_focused = {
        slug: "special_guard_all_focused",
        name: "Martyr",
        type: 'special',
        anim: "basic-attack",
        usage: {
            act: "%USER STANDS BEFORE THEIR FOES"
        },
        details: {
            flavor: "'stand in the way of target';'intercept incoming attack';'prepare to deliver destructive assault'",
            onUse: `'[STATUS::focused] [STATUS::surge]';'[STATUS::redirection] to target'`,
        },
        stats: {
            status: {
                focused: {
                    name: 'focused',
                    length: 2
                },
				surge: {
                    name: 'surge',
                    length: 1
                },
                redirection: {
                    name: 'redirection',
                    length: 2
                },
            },
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            reactDialogue(user, `give_redirection`)
            addStatus({target: user, status: "focused", length: 2, noReact: true}); 
            addStatus({target: user, status: "surge", length: 1}); 
            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
                    if(actor.slug == user.slug) return
                    addStatus({target: actor, origin: user, status: "redirection", length: 2}); 
                    play('guard', 2, 0.75);
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.special_rule_mega = {
        slug: "special_rule_mega",
        name: "Hostile Adjustment",
        type: 'special',
        anim: "",
        usage: {
            act: "%USER SHIFTS THE BALANCE"
        },
        details: {
            flavor: "'utilize status control to empower and repair team';'afflict opponents with critical vulnerability'",
            conditional: "<em>SELF::</em>[STATUS::windup]\n<em>ALLIES::</em>[STAT::amtBP] [STATUS::repairs] [STATUS::empowered]\n<em>FOES::</em>[STAT::amt] [STATUS::vulnerable_mega] [STATUS::fatal_flaw] [STATS::weakened]",
        },
        stats: {
            autohit: true,
            crit: 0,
            amt: 2,
            amtBP: 2,
            status: {
                windup: {
                    name: 'windup',
                    length: 1
                },
                repairs: {
                    name: 'repairs',
                    length: 1
                },
                empowered: {
                    name: 'empowered',
                    length: 2
                },
                vulnerable_mega : {
                    name: 'vulnerable_mega',
                    length: 2
                },
                fatal_flaw: {
                    name: 'fatal_flaw',
                    length: 1
                },
				weakened: {
                    name: 'weakened',
                    length: 2
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
            let allyTeam = user.team.name
            let enemyTeam = user.enemyTeam.name
            if(user.sprite) user.sprite.classList.add("basic-attack") 

            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                extraDelay: 100,
                endCallback: () => {
                    if(user.sprite) user.sprite.classList.remove("basic-attack")
                    readoutAdd({
                        message: `${user.name} stays wound up!`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: true,
                        forceMini: true,
                        sfx: false
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
                exec: (actor, i) => {
                    if(actor.slug == user.slug) return;

                    switch(actor.team.name) {
                        case allyTeam:
                            env.GENERIC_ACTIONS.singleTarget({
                                beneficial: true,
                                type: 'barrier',
                                action, 
                                user, 
                                target: actor,
                                canCrit: false,
                                hitSfx: {
                                    name: 'mend',
                                    rate: 1.5
                                },
                                hitExec: (target) => {
                                    addStatus({origin: user, target: actor, status: "empowered", length: 2}); 
                                    addStatus({origin: user, target: actor, status: "repairs", length: 1}); 
                                }
                            })
                        break

                        case enemyTeam:
                            env.GENERIC_ACTIONS.singleTarget({
                                action: this, 
                                user, 
                                target: actor,
                                hitSfx: {
                                    name: 'talkcroak',
                                    rate: 1.5
                                },
                                canCrit: false,
                                hitExec: (target) => {
                                    addStatus({origin: user, target: actor, status: "vulnerable_mega", length: 2}); 
                                    addStatus({origin: user, target: actor, status: "fatal_flaw", length: 1}); 
                                }
                            })                            
                        break
                    }
                }
            })
        }
    },
	
	env.ACTIONS.special_judgement_mega = {
        slug: "special_judgement_mega",
        name: "Hostile Rewrite",
        type: 'special',
        anim: "",
        details: {
            flavor: "'utilize thoughtspace influence to empower massive strike'",
            onUse: `'[STATUS::windup]';'HIT all foes'`,
            onHit: `'[STAT::amt] [STATUS::denatured] [STATUS::fear] [STATUS::madness]'`,
        },
        usage: {
            act: "%USER TURNS THE MEMORY AGAINST YOU"
        },
        stats: {
            accuracy: 1,
            crit: 0.3,
            amt: 3,
             status: {
                windup: {
                    name: 'windup',
                    length: 1
                },
                denatured: {
                    name: 'denatured',
                    length: 2
                },
                fear: {
                    name: 'fear',
                    length: 2
                }, 
				madness: {
                    name: 'madness',
                    length: 1
                }, 
            }
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
            if(user.sprite) user.sprite.classList.add("basic-attack")

            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                extraDelay: 200,
                endCallback: () => {
                    if(user.sprite) user.sprite.classList.remove("basic-attack")
                    readoutAdd({
                            message: `${user.name} stays wound up!`, 
                            name: "sourceless", 
                            type: "sourceless combat minordetail", 
                            show: true,
                            forceMini: true,
                            sfx: false
                        })
                    },
                exec: (actor, i) => {
                    if(actor.slug == user.slug) return
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'dull',
                            rate: 0.75
                        },
                        hitExec: ({target})=>{
                            addStatus({target, origin: user, status: "denatured", length: 2})
                            addStatus({target, origin: user, status: "fear", length: 2})
							addStatus({target, origin: user, status: "madness", length: 1})
                        }                
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.stun_baton = {
        slug: "stun_baton",
        name: "Baton",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER ATTACKS %TARGET",
            crit: "A FRIGHTENING BLOW",
            hit: "%TARGET IS DAZED",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: `'utilize electrified baton'`,
            onHit: `'[STAT::amt] [STATUS::weakened]'`,
			onCrit: `'[STATUS::stun]'`
        },
        stats: {
            accuracy: .9,
            crit: 0.05,
            amt: 1,
			status: {
                stun: { name: 'stun', length: 1 },
				weakened: { name: 'weakened', length: 1 },
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
				hitStatus: {
                    name: 'weakened',
                    length: 1
                },
				critStatus: {
                    name: 'stun',
                    length: 1
                },
            })
        }
    },

	env.ACTIONS.sidearm_weak = {
        slug: "sidearm_weak",
        name: "Sidearm",
        type: 'target',
        anim: "basic-attack",
        verb: "shoot",
        usage: {
            act: "%USER FIRES AT %TARGET",
            crit: "%TARGET IS LEFT REELING",
            hit: "%TARGET IS STRUCK",
            miss: "%USER MISSES"
        },
        details: {
            flavor: "'utilize low-caliber sidearm'",
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable]'`,
        },
        stats: {
            accuracy: .7,
            crit: 0.3,
            amt: 1,
            status: {
                vulnerable: { name: 'vulnerable', length: 2 },
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'shot',
                    rate: 1.25
                },
                critSfx: {
                    name: 'shot',
                    rate: 1
                },
                critStatus: {
                    name: 'vulnerable',
                    length: 2
                },
                missSfx: { name: "shot2", rate: 0.9 },
            })
        }
    },
	
	env.ACTIONS.special_semiauto = {
        slug: "special_semiauto",
        name: "Semi Auto",
        type: 'special',
        anim: "wobble",
        usage: {
            act: "%USER OPENS FIRE",
        },
        details: {
            flavor: "'utilize low-caliber pistol';'rapid inaccurate attacks'",
            onUse: `'HIT random foes 4 times'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable]'`
        },
        stats: {
            accuracy: .25,
            crit: 0.25,
            amt: 1,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            let targetTeam
            switch(user.team.name) {
                case "ally": targetTeam = env.rpg.enemyTeam; break;
                case "enemy": targetTeam = env.rpg.allyTeam; break;
            }

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot
            let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

            if(validTargets.length) for (let i = 0; i < 4; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
                let animDelay = baseDelay + anim.duration;
                if(validTargets) {
                    let target = validTargets.sample()
                    
                    setTimeout(()=>anim.exec(this, user, target), baseDelay)
                    setTimeout(()=>{
                        env.GENERIC_ACTIONS.singleTarget({
                            action: this, 
                            user, 
                            target,
                            hitSfx: { name: "shot2", rate: 1.25, volume: 0.5 },
                            critSfx: { name: "shot6", rate: 1.25 },
                            missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
                            critStatus: {
                                name: 'vulnerable',
                                length: 1
                            }
                        })

                        animElement.classList.add('scramble')
                        setTimeout(()=>animElement.classList.remove('scramble'), 100)
                    }, animDelay)
                }
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.2) * 5)
        }
    },
	
	env.ACTIONS.special_fullauto_smg = {
        slug: "special_fullauto_smg",
        name: "Full Auto::SMG",
        type: 'special',
        anim: "wobble",
        usage: {
            act: "%USER OPENS FIRE",
        },
        details: {
            flavor: "'utilize low-caliber automatic rifle';'rapid inaccurate attacks'",
            onUse: `'HIT random foes 6 times'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable]'`
        },
        stats: {
            accuracy: .25,
            crit: 0.25,
            amt: 1,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            let targetTeam
            switch(user.team.name) {
                case "ally": targetTeam = env.rpg.enemyTeam; break;
                case "enemy": targetTeam = env.rpg.allyTeam; break;
            }

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot
            let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

            if(validTargets.length) for (let i = 0; i < 6; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.15) * i)
                let animDelay = baseDelay + anim.duration;
                if(validTargets) {
                    let target = validTargets.sample()
                    
                    setTimeout(()=>anim.exec(this, user, target), baseDelay)
                    setTimeout(()=>{
                        env.GENERIC_ACTIONS.singleTarget({
                            action: this, 
                            user, 
                            target,
                            hitSfx: { name: "shot2", rate: 1.25, volume: 0.5 },
                            critSfx: { name: "shot6", rate: 1.25 },
                            missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
                            critStatus: {
                                name: 'vulnerable',
                                length: 1
                            }
                        })

                        animElement.classList.add('scramble')
                        setTimeout(()=>animElement.classList.remove('scramble'), 100)
                    }, animDelay)
                }
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.15) * 7)
        }
    },
	
	env.ACTIONS.windup_aim = {
        slug: "windup_aim",
        name: "Take Aim",
        type: 'autohit',
        anim: "",
        usage: {
            act: "%USER WATCHES CAREFULLY..."
        },
        details: {
            flavor: `'prepare a focused attack'`,
            onUse: `'[STATUS::windup_aim]'`
        },
        stats: {
            status: {
                windup_aim: {
                    name: 'windup_aim',
                    length: 1
                },            
            }
        },
        exec: function(user, target) {
            play('talkgal', 0.4);
            addStatus({target: user, status: "windup_aim", length: 1}); 
            return 'nothing';
        }
    },
	
	env.ACTIONS.aim_fullauto_smg = {
        slug: "aim_fullauto_smg",
        name: "Focus Fire::SMG",
        type: 'target',
        anim: "wobble",
		verb: "fire at",
        usage: {
            act: "%USER OPENS FIRE ON %TARGET",
        },
        details: {
            flavor: "'utilize low-caliber automatic rifle';'rapid inaccurate attacks on single target'",
            onUse: `'HIT target 6 times'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable]'`
        },
        stats: {
            accuracy: .25,
            crit: 0.25,
            amt: 1,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup_aim")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot

            if(target) for (let i = 0; i < 6; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.15) * i)
                let animDelay = baseDelay + anim.duration;

				setTimeout(()=>anim.exec(this, user, target), baseDelay)
				setTimeout(()=>{
					env.GENERIC_ACTIONS.singleTarget({
						action: this, 
						user, 
						target,
						hitSfx: { name: "shot2", rate: 1.25, volume: 0.5 },
						critSfx: { name: "shot6", rate: 1.25 },
						missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
						critStatus: {
							name: 'vulnerable',
							length: 1
						}
					})

					animElement.classList.add('scramble')
					setTimeout(()=>animElement.classList.remove('scramble'), 100)
				}, animDelay)
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.15) * 7)
        }
    },
	
	env.ACTIONS.barrier_stimpatch = {
        slug: "barrier_stimpatch",
        name: "Stimpatch",
        verb: "shield",
        type: 'support+target+self+autohit',
        anim: "heal",
        usage: {
            act: "%USER ATTACHES SOMETHING %TARGET",
            crit: "%TARGET FEELS INVINCIBLE",
            hit: "%TARGET FEELS BETTER",
            miss: "IT DOES NOT STICK"
        },
        details: {
            flavor: "apply fragile restorative device to target'",
            onHit: `'[STAT::amtBP] [STATUS::repairs]'`,
        },
        stats: {
            amt: 2,
            amtBP: 2,
			status: {
				repairs: { name: 'repairs', length: 1 },
			},
        },
        autohit: true,
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                beneficial: true,
                type: 'barrier',
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'mend',
                    rate: 1.5
                },
				hitStatus: { name: 'repairs', length: 1 }
            })
        }
    },
	
	env.ACTIONS.limited_manhack_summon = {
		slug: "limited_manhack_summon",
		name: "Deploy Viscerator",
		type: 'special+summon+nomimic',
		anim: "heal",
		details: {
			conditional: `<em>SUMMON::</em>'summon viscerator'`,
			onUse: `'remove this action'`
		},
		itemAction: true, //we have to lie here so that imps can't use this action
		noRepeat: true,
		exec: function(user, target) {
			actionMessage(user, "%USER TOSSES A STRANGE DEAD METAL CYST", target, 'none', 2000);
			play('talkcroak', 1, 0.75);
			if(user.team.name.includes("enemy")) {
				midCombatActorAdd(env.rpg.enemyTeam, 'cmb_manhack', 'left')
			} else {
				midCombatActorAdd(env.rpg.allyTeam, 'cmb_manhack', 'left')
			}
			user.actions = user.actions.filter(action => action !== "limited_manhack_summon")
			setTimeout(()=>advanceTurn(user), 1000)
		}
	},
	
	env.ACTIONS.limited_scanner_summon = {
		slug: "limited_scanner_summon",
		name: "Deploy Scanner",
		type: 'special+summon+nomimic',
		anim: "heal",
		details: {
			conditional: `<em>SUMMON::</em>'summon scanner'`,
			onUse: `'remove this action'`
		},
		itemAction: true, //we have to lie here so that imps can't use this action
		noRepeat: true,
		exec: function(user, target) {
			actionMessage(user, "%USER TOSSES A STRANGE DEAD METAL CYST", target, 'none', 2000);
			play('talkcroak', 1, 0.75);
			if(user.team.name.includes("enemy")) {
				midCombatActorAdd(env.rpg.enemyTeam, 'cmb_cityscanner', 'left')
			} else {
				midCombatActorAdd(env.rpg.allyTeam, 'cmb_cityscanner', 'left')
			}
			user.actions = user.actions.filter(action => action !== "limited_scanner_summon")
			setTimeout(()=>advanceTurn(user), 1000)
		}
	},
	
	env.ACTIONS.special_spy_all_flare = {
        slug: "special_spy_all_flare",
        name: "Flare Shot",
        type: 'special',
        anim: "basic-attack",
        usage: {
            act: "%USER ILLUMINATES THEIR FOES"
        },
        details: {
            flavor: "'fire signaling flare';'expose all weakness'",
            onUse: `'[STATUS::vulnerable] to all foes'`,
        },
        stats: {
            autohit: true,
            status: {
                vulnerable: { name: "vulnerable", length: 3 },
            }
        },
        itemAction: false,
		noRepeat: true,
        exec: function(user, target, beingUsedAsync) {
            let targetTeam
            switch(user.team.name) {
                case "ally": targetTeam = env.rpg.enemyTeam; break;
                case "enemy": targetTeam = env.rpg.allyTeam; break;
            }

            env.GENERIC_ACTIONS.teamWave({
                team: targetTeam,
                exec: (actor, i) => {
                    removeStatus(actor, "evasion");
                    addStatus({target: actor, origin: user, status: "vulnerable", length: 3}); 
                    play('status', 0.75, 0.75);
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.speak_blind = {
        slug: "speak_blind",
        name: "Scan",
        type: 'target',
        anim: "skitter",
        usage: {
            act: "%USER SCANS %TARGET",
            crit: "%TARGET IS BLINDED",
            hit: "%TARGET STAGGERS",
            miss: "%TARGET LOOKS AWAY"
        },
        details: {
            onHit: `'[STATUS::fear] [STATUS::blindness]'`,
            onCrit:`'[STATUS::stun]'`,
        },
        stats: {
            accuracy: .8,
            crit: 0.2,
            amt: 0,
            status: {
                fear: {
                    name: 'fear',
                    length: 2
                },
                stun: {
                    name: 'stun',
                    length: 1
                },
				blindness: {
                    name: 'blindness',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
			removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'talksignal',
                    rate: 1.5
                },
                hitExec: ()=>{
					addStatus({target, origin: user, status: "blindness", origin: user, length: 1})
                },
                critSfx: {
                    name: 'fear',
                    rate: 1
                },
                critStatus: {
                    name: 'stun',
                    length: 1
                },
                hitStatus: {
                    name: 'fear',
                    length: 2
                },
            })
        }
    },
	
	env.ACTIONS.wound_stab_weak = {
        slug: "wound_stab_weak",
        name: "Viscerate",
        type: 'target',
        anim: "basic-attack", 
        usage: {
            act: "%USER FLIES AT %TARGET",
            crit: "%TARGET IS TORN APART",
            hit: "%TARGET BLEEDS SLUDGY CORRU",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'utilize spinning dead metal blades to clumsily attack';'create lasting injuries'",
            onHit: `'[STAT::amt] [STATUS::puncture]'`,
            onCrit: ()=> `'wound vital cystic component for [STATUS::open_wound]'${env?.rpg?.is2D ? ";'KB::2'" : ''}`,
        },
        stats: {
            accuracy: 0.5,
            crit: 0.15,
            amt: 1,
            status: {
                puncture: {
                    name: 'puncture',
                    length: 1
                },
				open_wound: {
                    name: 'open_wound',
                    length: 2
                }
            }
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'stab',
                    rate: 1.5
                },
				critSfx: {
                    name: 'stab',
                    rate: 1
                },
                critStatus: this.stats.status.open_wound,
                hitStatus: this.stats.status.puncture,
            })
        }
    },
	
	env.ACTIONS.aim_fullauto = {
        slug: "aim_fullauto",
        name: "Focus Fire",
        type: 'target',
        anim: "wobble",
		verb: "fire at",
        usage: {
            act: "%USER OPENS FIRE ON %TARGET",
        },
        details: {
            flavor: "'utilize automatic rifle';'rapid inaccurate attacks on singular target'",
            onUse: `'HIT target 6 times'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable]'`
        },
        stats: {
            accuracy: .33,
            crit: 0.33,
            amt: 1,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup_aim")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot

            if(target) for (let i = 0; i < 6; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
                let animDelay = baseDelay + anim.duration;

				setTimeout(()=>anim.exec(this, user, target), baseDelay)
				setTimeout(()=>{
					env.GENERIC_ACTIONS.singleTarget({
						action: this, 
						user, 
						target,
						hitSfx: { name: "shot2", volume: 0.5 },
						critSfx: { name: "shot6" },
						missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
						critStatus: {
							name: 'vulnerable',
							length: 1
						}
					})

					animElement.classList.add('scramble')
					setTimeout(()=>animElement.classList.remove('scramble'), 100)
				}, animDelay)
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.2) * 7)
        }
    },
	
	env.ACTIONS.unfocused_shot_357 = {
        slug: "unfocused_shot_357",
        name: "Unfocused Shot",
        verb: "shoot",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER FIRES AT %TARGET",
            crit: "%TARGET TAKES A BIG HIT",
            hit: "%TARGET IS STRUCK",
            miss: "%USER MISSES"
        },
        details: {
            flavor: "'fire without intense aim';'could hit';'a gamble'",
            onHit: `'[STAT::amt]'`,
        },
        stats: {
            accuracy: .5,
            crit: 0.5,
            amt: 2,
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'shot',
                    rate: 1
                },
                critSfx: {
                    name: 'shot',
                    rate: 1.25
                },
                missSfx: { name: "shot2", rate: 0.9 },
            })
        }
    },
	
	env.ACTIONS.focused_shot_357 = {
        slug: "focused_shot_357",
        name: "Focused Shot",
        verb: "shoot",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER FIRES AT %TARGET",
            crit: "%TARGET IS TORN APART",
            hit: "%TARGET TAKES A BIG HIT",
            miss: "%USER MISSES"
        },
        details: {
            flavor: "'well-placed revolver shot';'immense physical trauma'",
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable] [STATUS::stun]'`,
        },
        stats: {
            accuracy: 0.9,
            crit: 0.3,
            amt: 4,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 3
                },
                stun: {
                    name: 'stun',
                    length: 1
                },
                critical_flaw: {
                    name: 'critical_flaw',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
            removeStatus(user, "windup_aim")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'shot',
                    rate: 1.25
                },
                critSfx: {
                    name: 'shot',
                    rate: 1.5
                },
                missSfx: { name: "shot2", rate: 0.9 },

                critExec: ({target})=>{
                    addStatus({target, status: "vulnerable", length: 3}) 
                    addStatus({target, status: "stun", length: 1}) 
                }
            })
        }
    },
	
	env.ACTIONS.special_grenade = {
        slug: "special_grenade",
        name: "Extractor",
        type: 'special+target',
        desc: "'throw delayed bright kavruka';'present target a choice of outcome'",
        anim: "wobble",
		
        help: "CHOOSE::100% -2HP ::OR:: 50% -2HP (SELF:: -1HP), 50%C x2 +2T:PUNCTURE +1T:STUN (SELF:: -1HP)",
        usage: {
            act: "%USER THROWS A GRENADE AT %TARGET",
            crit: "%TARGET EXPLODES",
            hit: "%TARGET TAKES A SOLID HIT",
            miss: "%USER MISSES"
        },
        accuracy: 1,
        crit: 0,
		details: {
            onUse: "'throw delayed bright kavruka';'present target a choice of outcome'",
            conditional: "<em>HIT 1</em>::'HIT::[STAT::hit1ACC] CRIT::[STAT::hit2CRIT]% [STAT::hit1HP]'\n<em>HIT 2</em>::'HIT::AUTOHIT CRIT::0% -0HP';'-[STATUS::focused], -[STATUS::evasion], -[STATUS::empowered] -[STATUS::hyperfocus_flat] -[STATUS::evasion_mega]'"
        },

        stats: {
            hit1HP: 2,
            hit1ACC: 100,
            hit2HP: 1,
            hit2ACC: 50,
            hit2CRIT: 30,

            status: {
                stun: { name: 'stun', length: 1 },
                vulnerable: { name: 'vulnerable', length: 2 },
				focused: { name: 'focused', showReference: true },
				evasion: { name: 'evasion', showReference: true },
				empowered: { name: 'empowered', showReference: true },
				hyperfocus_flat: { name: 'hyperfocus_flat', showReference: true },
				evasion_mega: { name: 'evasion_mega', showReference: true },
            },
        },
        exec: function(user, target) {
			let action = this

			//summon a div that lets the player click guaranteed or chance
			actionChoice({
				user: user,
				action: action,
				choiceText: `${user.name} throws a grenade at ${target.name}!`,
				options: [
					{text: "Stay and fight", definition: "NOTE::'100% -2HP, 30%C x2 +1T:STUN +2T:VULNERABLE'"},
					{text: "Abandon position", definition: "NOTE::'AUTOHIT -FOCUSED, -EVASION, -EMPOWERED, -TUNNEL VISION, -UNNATURAL SPEED'"},
				],
				choiceCallback: (c) => {
					//reap the consequences
						
					var hit
					switch(c) {
						case "c0":
							hit = combatHit(target, {amt: 2, acc: 1, crit: 0.3, origin: user});
							break;
						case "c1":
							hit = play("miss", 0.5)
								removeStatus(target, "focused")
								removeStatus(target, "evasion")
								removeStatus(target, "empowered")
								removeStatus(target, "hyperfocus_flat")
								removeStatus(target, "evasion_mega")
								actionMessage(user, "%TARGET RUNS AWAY", target)
							break
					}

					actionMessage(user, action, target, hit)
					switch(hit) {
						case "crit":                                
							playCombatCrit("shot2", 0.6)
							addStatus({target: target, origin: user, status: "stun", length: 1})
							addStatus({target: target, origin: user, status: "vulnerable", length: 2, noReact: true})
							removeStatus(target, "windup")
							break
						case true:
							reactDialogue(target, 'receive_hit')
							play("shot", 0.75)
							break;
						case false:
							reactDialogue(target, 'evade')
							play("shot2", 0.75)
							break;
					}

					setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE);
				}
			})
		}
    },
	
	env.ACTIONS.special_fullauto_ar2 = {
        slug: "special_fullauto_ar2",
        name: "Full Auto::AR2",
        type: 'special',
        anim: "wobble",
        usage: {
            act: "%USER OPENS FIRE",
        },
        details: {
            flavor: "'utilize automatic pulse rifle';'rapid inaccurate attacks'",
            onUse: `'HIT random foes 4 times'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable]'`
        },
        stats: {
            accuracy: .25,
            crit: 0.25,
            amt: 2,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            let targetTeam
            switch(user.team.name) {
                case "ally": targetTeam = env.rpg.enemyTeam; break;
                case "enemy": targetTeam = env.rpg.allyTeam; break;
            }

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot
            let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

            if(validTargets.length) for (let i = 0; i < 4; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
                let animDelay = baseDelay + anim.duration;
                if(validTargets) {
                    let target = validTargets.sample()
                    
                    setTimeout(()=>anim.exec(this, user, target), baseDelay)
                    setTimeout(()=>{
                        env.GENERIC_ACTIONS.singleTarget({
                            action: this, 
                            user, 
                            target,
                            hitSfx: { name: "shot2", rate: 1, volume: 0.5 },
                            critSfx: { name: "shot6", rate: 1 },
                            missSfx: { name: "shot2", rate: 1.25, volume: 0.5 },
                            critStatus: {
                                name: 'vulnerable',
                                length: 2
                            }
                        })

                        animElement.classList.add('scramble')
                        setTimeout(()=>animElement.classList.remove('scramble'), 100)
                    }, animDelay)
                }
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.2) * 5)
        }
    },
	
	env.ACTIONS.aim_fullauto_ar2 = {
        slug: "aim_fullauto_ar2",
        name: "Focus Fire::AR2",
        type: 'target',
        anim: "wobble",
		verb: "fire at",
        usage: {
            act: "%USER OPENS FIRE ON %TARGET",
        },
        details: {
            flavor: "'utilize automatic pulse rifle';'rapid inaccurate attacks on singular target'",
            onUse: `'HIT target 4 times'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable]'`
        },
        stats: {
            accuracy: .25,
            crit: 0.25,
            amt: 2,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup_aim")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot

            if(target) for (let i = 0; i < 4; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
                let animDelay = baseDelay + anim.duration;

				setTimeout(()=>anim.exec(this, user, target), baseDelay)
				setTimeout(()=>{
					env.GENERIC_ACTIONS.singleTarget({
						action: this, 
						user, 
						target,
						hitSfx: { name: "shot2", volume: 0.5 },
						critSfx: { name: "shot6" },
						missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
						critStatus: {
							name: 'vulnerable',
							length: 2
						}
					})

					animElement.classList.add('scramble')
					setTimeout(()=>animElement.classList.remove('scramble'), 100)
				}, animDelay)
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.2) * 5)
        }
    },
	
	env.ACTIONS.fullauto_shotgun_cmb = {
        slug: "fullauto_shotgun_cmb",
        name: "Shotgun",
        type: 'target',
        anim: "wobble",
		verb: "blast",
        usage: {
            act: "%USER BLASTS %TARGET",
        },
        details: {
            flavor: "'utilize shotgun';'rapid attacks on single target'",
            onUse: `'HIT target 6 times''`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable]'`
        },
        stats: {
            accuracy: .2,
            crit: 0.2,
            amt: 1,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot

            if(target) for (let i = 0; i < 6; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.05) * i)
                let animDelay = baseDelay + anim.duration;

				setTimeout(()=>anim.exec(this, user, target), baseDelay)
				setTimeout(()=>{
					env.GENERIC_ACTIONS.singleTarget({
						action: this, 
						user, 
						target,
						hitSfx: { name: "shot2", volume: 0.5 },
						critSfx: { name: "shot6" },
						missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
						critStatus: {
							name: 'vulnerable',
							length: 1
						}
					})

					animElement.classList.add('scramble')
					setTimeout(()=>animElement.classList.remove('scramble'), 100)
				}, animDelay)
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.05) * 7)
        }
    },
	
	env.ACTIONS.aim_fullauto_shotgun = {
        slug: "aim_fullauto_shotgun",
        name: "Double Barrel",
        type: 'target',
        anim: "wobble",
		verb: "blast",
        usage: {
            act: "%USER BLASTS %TARGET",
        },
        details: {
            flavor: "'overextend shotgun';'rapid attacks on single target'",
            onUse: `'HIT target 12 times''`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable]'`
        },
        stats: {
            accuracy: .2,
            crit: 0.2,
            amt: 1,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup_aim")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot

            if(target) for (let i = 0; i < 12; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.05) * i)
                let animDelay = baseDelay + anim.duration;

				setTimeout(()=>anim.exec(this, user, target), baseDelay)
				setTimeout(()=>{
					env.GENERIC_ACTIONS.singleTarget({
						action: this, 
						user, 
						target,
						hitSfx: { name: "shot2", volume: 0.5 },
						critSfx: { name: "shot6" },
						missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
						critStatus: {
							name: 'vulnerable',
							length: 1
						}
					})

					animElement.classList.add('scramble')
					setTimeout(()=>animElement.classList.remove('scramble'), 100)
				}, animDelay)
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.05) * 13)
        }
    },
	
	env.ACTIONS.limited_shieldscanner_summon = {
		slug: "limited_shieldscanner_summon",
		name: "Deploy Scanner",
		type: 'special+summon+nomimic',
		anim: "heal",
		details: {
			conditional: `<em>SUMMON::</em>'summon scanner'`,
			onUse: `'remove this action'`
		},
		itemAction: true, //we have to lie here so that imps can't use this action
		noRepeat: true,
		exec: function(user, target) {
			actionMessage(user, "%USER TOSSES A STRANGE DEAD METAL CYST", target, 'none', 2000);
			play('talkcroak', 1, 0.75);
			if(user.team.name.includes("enemy")) {
				midCombatActorAdd(env.rpg.enemyTeam, 'cmb_shieldscanner', 'left')
			} else {
				midCombatActorAdd(env.rpg.allyTeam, 'cmb_shieldscanner', 'left')
			}
			user.actions = user.actions.filter(action => action !== "limited_shieldscanner_summon")
			setTimeout(()=>advanceTurn(user), 1000)
		}
	},
	
	env.ACTIONS.deploy_mine = {
        slug: "deploy_mine",
        name: "Lay Mine",
        type: 'target+support+autohit',
        anim: "heal",
        usage: {
            act: "%USER DEPLOYS A MINE",
            hit: "%TARGET FEELS PROTECTED",
        },
        details: {
            onHit: `'[STATUS::landmine_cmb]'`,
        },
        stats: {
            autohit: true,
            canCrit: false,
            amt: 0,
            status: {
                landmine_cmb: {
                    name: 'landmine_cmb',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
			removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'talkcroak',
                    rate: 1.5
                },
                hitStatus: {
                    name: 'landmine_cmb',
                    length: 1
                },
            })
        }
    },
	
	env.ACTIONS.ar2_orb = {
        slug: "ar2_orb",
        name: "Energy Orb",
        type: 'target',
        anim: "skitter",
        usage: {
            act: "%USER FIRES A BALL OF LIGHT",
            hit: "%TARGET IS STRUCK",
			crit: "%TARGET DISINTEGRATES",
			miss: "%TARGET EVADES"
        },
        details: {
            onHit: `'[STAT::amt] [STATUS::vulnerable]'`,
			onCrit: `'[STATUS::stun]'`,
        },
        stats: {
            accuracy: 0.8,
            crit: 0.3,
            amt: 4,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },
                stun: {
                    name: 'stun',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
			removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'dull',
                    rate: 1.25
                },
                hitStatus: {
                    name: 'vulnerable',
                    length: 2
                },
				critSfx: {
                    name: 'dull',
                    rate: 0.75
                },
                critStatus: {
                    name: 'stun',
                    length: 1
                },
            })
        }
    },
	
	env.ACTIONS.smg_grenade = {
        slug: "smg_grenade",
        name: "SMG Grenade",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER FIRES A WEIRD CYST AT %TARGET",
            hit: "%TARGET EXPLODES",
			crit: "%TARGET'S TEAM EXPLODES",
			miss: "%TARGET EVADES"
        },
        details: {
            onHit: `'[STAT::amt] [STATUS::vulnerable]'`,
			onCrit: `'additional [STAT::amt] [STATUS::vulnerable] to all foes'`,
        },
        stats: {
            accuracy: 0.8,
            crit: 0.3,
            amt: 3,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },
                stun: {
                    name: 'stun',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
			removeStatus(user, "windup_aim")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'shot',
                    rate: 1
                },
                hitStatus: {
                    name: 'vulnerable',
                    length: 2
                },
				critSfx: {
                    name: 'shot',
                    rate: 0.75
                },
                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i)=>{
                        combatHit(actor, {amt: 3, crit: 0, autohit: true, origin: user});
                        addStatus({target: actor, status: "vulnerable", length: 2}); 
                        play("shot", 0.75)
                    }
                })
            })
        }
    },
	
	env.ACTIONS.limited_sentry_summon = {
		slug: "limited_sentry_summon",
		name: "Deploy Sentry",
		type: 'special+summon+nomimic',
		anim: "heal",
		details: {
			conditional: `<em>SUMMON::</em>'summon sentry'`,
			onUse: `'remove this action'`
		},
		itemAction: true, //we have to lie here so that imps can't use this action
		noRepeat: true,
		exec: function(user, target) {
			actionMessage(user, "%USER SETS DOWN A STRANGE DEAD METAL MONOLITH", target, 'none', 2000);
			play('talkcroak', 1, 0.75);
			if(user.team.name.includes("enemy")) {
				midCombatActorAdd(env.rpg.enemyTeam, 'cmb_sentry', 'left')
			} else {
				midCombatActorAdd(env.rpg.allyTeam, 'cmb_sentry', 'left')
			}
			user.actions = user.actions.filter(action => action !== "limited_sentry_summon")
			setTimeout(()=>advanceTurn(user), 1000)
		}
	},
	
	env.ACTIONS.special_fullauto_sentry = {
        slug: "special_fullauto_sentry",
        name: "Full Auto::SENTRY",
        type: 'special',
        anim: "wobble",
        usage: {
            act: "%USER OPENS FIRE",
        },
        details: {
            flavor: "'utilize automatic pulse rifle';'rapid inaccurate attacks'",
            onUse: `'HIT random foes 6 times'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable]'`
        },
        stats: {
            accuracy: .25,
            crit: 0.25,
            amt: 2,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            let targetTeam
            switch(user.team.name) {
                case "ally": targetTeam = env.rpg.enemyTeam; break;
                case "enemy": targetTeam = env.rpg.allyTeam; break;
            }

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot
            let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

            if(validTargets.length) for (let i = 0; i < 6; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
                let animDelay = baseDelay + anim.duration;
                if(validTargets) {
                    let target = validTargets.sample()
                    
                    setTimeout(()=>anim.exec(this, user, target), baseDelay)
                    setTimeout(()=>{
                        env.GENERIC_ACTIONS.singleTarget({
                            action: this, 
                            user, 
                            target,
                            hitSfx: { name: "shot2", rate: 1, volume: 0.5 },
                            critSfx: { name: "shot6", rate: 1 },
                            missSfx: { name: "shot2", rate: 1.25, volume: 0.5 },
                            critStatus: {
                                name: 'vulnerable',
                                length: 2
                            }
                        })

                        animElement.classList.add('scramble')
                        setTimeout(()=>animElement.classList.remove('scramble'), 100)
                    }, animDelay)
                }
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.2) * 7)
        }
    },
	
	env.ACTIONS.aim_fullauto_hunter = {
        slug: "aim_fullauto_hunter",
        name: "Focus Fire::HUNTER",
        type: 'target',
        anim: "wobble",
		verb: "fire at",
        usage: {
            act: "%USER OPENS FIRE ON %TARGET",
        },
        details: {
            flavor: "'utilize internal flechette rifle';'rapid inaccurate attacks on singular target'",
            onUse: `'HIT target 6 times'`,
            onHit: `'[STAT::amt] [STATUS::puncture]'`,
            onCrit:`'[STATUS::puncture]'`
        },
        stats: {
            accuracy: .33,
            crit: 0.33,
            amt: 1,
            status: {
                puncture: {
                    name: 'puncture',
                    length: 2
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup_aim")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot

            if(target) for (let i = 0; i < 6; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
                let animDelay = baseDelay + anim.duration;

				setTimeout(()=>anim.exec(this, user, target), baseDelay)
				setTimeout(()=>{
					env.GENERIC_ACTIONS.singleTarget({
						action: this, 
						user, 
						target,
						hitSfx: { name: "stab", rate: 1.5, volume: 0.5 },
						critSfx: { name: "stab" },
						missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
						critStatus: {
							name: 'puncture',
							length: 2
						},
						hitStatus: {
							name: 'puncture',
							length: 2
						}
					})

					animElement.classList.add('scramble')
					setTimeout(()=>animElement.classList.remove('scramble'), 100)
				}, animDelay)
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.2) * 7)
        }
    },
	
	env.ACTIONS.hunter_smash = {
        slug: "hunter_smash",
        name: "Wild Strike",
        type: 'target',
        desc: "'focused, deadly attack upon one target';'immense physical trauma'",
        anim: "basic-attack",
        help: "100% -4HP, 40% X2 +1T:STUN",
        usage: {
            act: "%USER CHARGES %TARGET",
            crit: "%TARGET IS LEFT REELING",
            hit: "%TARGET IS BRUTALLY STABBED",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'focused, deadly attack upon one target';'immense physical trauma'",
            onHit: `'[STAT::amt] [STATUS::puncture] [STATUS::open_wound]'`,
            onCrit: `'[STATUS::stun] [STATUS::puncture] [STATUS::open_wound]'`,
        },
        stats: {
			accuracy: 1,
            crit: 0.4,
            amt: 3,
            status: {
                stun: {
                    name: 'stun',
                    length: 1
                },
				puncture: {
                    name: 'puncture',
                    length: 3
                },
				open_wound: {
                    name: 'open_wound',
                    length: 2
                }
            },
        },
        exec: function(user, target) {
            removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'stab',
                    rate: 0.7
                },
				critSfx: {
					name: 'stab',
					rate: 0.4
				},
                hitExec: ({target})=> {
                    addStatus({target, status: "puncture", length: 3});
					addStatus({target, status: "open_wound", length: 2, noReact: true});
                },
                critExec: ({target})=>{
					addStatus({target, status: "puncture", length: 3, noReact: true});
					addStatus({target, status: "open_wound", length: 2, noReact: true});
                    addStatus({target, status: "stun", length: 1}); 
                }
            })
        }
    },
	
	env.ACTIONS.focused_shot_cmb = {
        slug: "focused_shot_cmb",
        name: "Focused Shot",
        verb: "shoot",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER FIRES AT %TARGET",
            crit: "%TARGET IS TORN APART",
            hit: "%TARGET TAKES A BIG HIT",
            miss: "%USER MISSES"
        },
        details: {
            flavor: "'slow moving high-caliber shot';'immense physical trauma'",
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable] [STATUS::stun] [STATUS::critical_flaw]'`,
        },
        stats: {
            accuracy: 0.7,
            crit: 0.4,
            amt: 6,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 3
                },
                stun: {
                    name: 'stun',
                    length: 1
                },
                critical_flaw: {
                    name: 'critical_flaw',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
            removeStatus(user, "windup_aim")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'shot',
                    rate: 1.25
                },
                critSfx: {
                    name: 'shot',
                    rate: 1.5
                },
                missSfx: { name: "shot2", rate: 0.9 },

                critExec: ({target})=>{
                    addStatus({target, status: "vulnerable", length: 3}) 
                    addStatus({target, status: "stun", length: 1}) 
                    addStatus({target, status: "critical_flaw", length: 1})
                }
            })
        }
    },
	
	env.ACTIONS.hold_aim_cmb = {
        slug: "hold_aim_cmb",
        name: "Lead Aim",
        type: 'autohit',
        anim: "",
		avoidChaining: true,
        usage: {
            act: "%USER WAITS FOR THE RIGHT MOMENT..."
        },
        details: {
            onUse: `'[STATUS::windup_aim] [STATUS::evasion] [STATUS::focused]'`,
            flavor: "'hold prepared attack';'look for opportunity'"
        },
        stats: {
            status: {
                evasion: {
                    name: 'evasion',
                    length: 1
                },
                windup_aim: {
                    name: 'windup_aim',
                    length: 1
                },
                focused: {
                    name: 'focused',
                    length: 1
                },
            },
        }, 
        noRepeat: true,
        exec: function(user, target) {
            play("talkgal", 0.5)
            addStatus({target: user, status: "windup_aim", length: 1}); 
            addStatus({target: user, status: "evasion", length: 1, noReact: true}); 
            addStatus({target: user, status: "focused", length: 1, noReact: true});
            return 'nothing';
        }
    },
	
	env.ACTIONS.limited_defensestation_summon = {
		slug: "limited_defensestation_summon",
		name: "Deploy Defense Station",
		type: 'special+summon+nomimic',
		anim: "heal",
		details: {
			conditional: `<em>SUMMON::</em>'summon defense station'`,
			onUse: `'remove this action'`
		},
		itemAction: true, //we have to lie here so that imps can't use this action
		noRepeat: true,
		exec: function(user, target) {
			actionMessage(user, "%USER SETS DOWN A GLOWING DEAD METAL MONOLITH", target, 'none', 2000);
			play('talkcroak', 1, 0.75);
			if(user.team.name.includes("enemy")) {
				midCombatActorAdd(env.rpg.enemyTeam, 'cmb_defensestation', 'left')
			} else {
				midCombatActorAdd(env.rpg.allyTeam, 'cmb_defensestation', 'left')
			}
			user.actions = user.actions.filter(action => action !== "limited_defensestation_summon")
			setTimeout(()=>advanceTurn(user), 1000)
		}
	},
	
	env.ACTIONS.focused_shot_missile_cmb = {
        slug: "focused_shot_missile_cmb",
        name: "RPG",
        verb: "launch",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER FIRES AT %TARGET",
            crit: "%TARGET'S TEAM EXPLODES",
            hit: "%TARGET EXPLODES",
            miss: "%USER MISSES"
        },
        details: {
            flavor: "'utilize bright missile launcher';'immense physical trauma'",
            onHit: `'[STAT::amt] [STATUS::vulnerable] [STATUS::stun]'`,
            onCrit:`'HIT all foes for [STAT::amt] [STATUS::vulnerable]';'additional hits trigger on-hit effects'`,
        },
        stats: {
            accuracy: 1,
            crit: 0.4,
            amt: 3,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                },
                stun: {
                    name: 'stun',
                    length: 1
                },
                critical_flaw: {
                    name: 'critical_flaw',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
			removeStatus(user, "windup_aim")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'shot1',
                    rate: 0.75
                },
                critSfx: {
                    name: 'shot',
                    rate: 0.5
                },
                missSfx: { name: "shot5", rate: 0.75 },

                hitExec: ({target})=>{
                    addStatus({target, status: "vulnerable", length: 2}) 
					addStatus({target, status: "stun", length: 1}) 
                },
				critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i)=>{
                        combatHit(actor, {amt: 3, crit: 0, accuracy: 1, origin: user});
                        addStatus({target: actor, status: "vulnerable", length: 1}); 
                        play("shot", 0.5)
                    }
                })
            })
        }
    },
	
	env.ACTIONS.special_grenade_poison = {
        slug: "special_grenade_poison",
        name: "Toxic Extractor",
        type: 'special+target',
        desc: "'throw delayed bright kavruka';'present target a choice of outcome'",
        anim: "wobble",
		
        help: "CHOOSE::100% -2HP ::OR:: 50% -2HP (SELF:: -1HP), 50%C x2 +2T:PUNCTURE +1T:STUN (SELF:: -1HP)",
        usage: {
            act: "%USER THROWS A GRENADE AT %TARGET",
            crit: "%TARGET'S TEAM IS COVERED IN CAUSTIC SMOKE",
            hit: "%TARGET IS POISONED",
            miss: "%USER MISSES"
        },
        accuracy: 1,
        crit: 0,
		details: {
            onUse: "'throw delayed bright kavruka';'present target a choice of outcome'",
            conditional: "<em>HIT 1</em>::'HIT::[STAT::hit1ACC]% [STAT::hit1HP] [STATUS::poison] CRIT::[STAT::hit2CRIT]% [STAT::hit1HP] additional [STATUS::poison] to all foes'\n<em>HIT 2</em>::'HIT::AUTOHIT CRIT::0% -0HP';'-[STATUS::focused], -[STATUS::evasion], -[STATUS::empowered] -[STATUS::hyperfocus_flat] -[STATUS::evasion_mega]'"
        },

        stats: {
            hit1HP: 1,
            hit1ACC: 100,
            hit2HP: 1,
            hit2ACC: 50,
            hit2CRIT: 30,

            status: {
                stun: { name: 'stun', length: 1 },
                poison: { name: 'poison', length: 3 },
				focused: { name: 'focused', showReference: true },
				evasion: { name: 'evasion', showReference: true },
				empowered: { name: 'empowered', showReference: true },
				hyperfocus_flat: { name: 'hyperfocus_flat', showReference: true },
				evasion_mega: { name: 'evasion_mega', showReference: true },
            },
        },
        exec: function(user, target) {
			let action = this

			//summon a div that lets the player click guaranteed or chance
			actionChoice({
				user: user,
				action: action,
				choiceText: `${user.name} throws a grenade at ${target.name}!`,
				options: [
					{text: "Stay and fight", definition: "NOTE::'100% -1HP +3T:NEUROTOXIN, 30%C x2 +3T:NEUROTOXIN TO ALL FOES'"},
					{text: "Abandon position", definition: "NOTE::'AUTOHIT -FOCUSED, -EVASION, -EMPOWERED, -TUNNEL VISION, -UNNATURAL SPEED'"},
				],
				choiceCallback: (c) => {
					//reap the consequences
						
					var hit
					switch(c) {
						case "c0":
							hit = combatHit(target, {amt: 1, acc: 1, crit: 0.3, origin: user});
							break;
						case "c1":
							hit = play("miss", 0.5)
								removeStatus(target, "focused")
								removeStatus(target, "evasion")
								removeStatus(target, "empowered")
								removeStatus(target, "hyperfocus_flat")
								removeStatus(target, "evasion_mega")
								actionMessage(user, "%TARGET RUNS AWAY", target)
							break
					}

					actionMessage(user, action, target, hit)
					switch(hit) {
						case "crit":                                
							playCombatCrit("shot2", 0.6)
							setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE)
							return env.GENERIC_ACTIONS.teamWave({
								team: user.enemyTeam,
								exec: (actor, i)=>{
									//combatHit(actor, {amt: 1, crit: 0, autohit: true, origin: user});
									addStatus({target: actor, status: "poison", length: 3}); 
									play("fear", 0.75)
								}
							})
							break
						case true:
							reactDialogue(target, 'receive_hit')
							addStatus({target: target, origin: user, status: "poison", length: 3, noReact: true})
							play("shot", 0.75)
							break;
						case false:
							reactDialogue(target, 'evade')
							play("shot2", 0.75)
							break;
					}

					setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE);
				}
			})
		}
    },
	
	env.ACTIONS.special_fullauto_flechette = {
        slug: "special_fullauto_flechette",
        name: "Full Auto::SYNTH",
        type: 'special',
        anim: "wobble",
		verb: "fire at",
        usage: {
            act: "%USER OPENS FIRE",
        },
        details: {
            flavor: "'utilize flechette rifle';'rapid inaccurate attacks'",
            onUse: `'HIT random foes 3 times'`,
            onHit: `'[STAT::amt] [STATUS::puncture]'`,
            onCrit:`'[STATUS::puncture]'`
        },
        stats: {
            accuracy: .33,
            crit: 0.33,
            amt: 1,
            status: {
                puncture: {
                    name: 'puncture',
                    length: 2
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup_aim")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')
		
			let targetTeam
            switch(user.team.name) {
                case "ally": targetTeam = env.rpg.enemyTeam; break;
                case "enemy": targetTeam = env.rpg.allyTeam; break;
            }

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot
            let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

            if(validTargets.length) for (let i = 0; i < 3; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.3) * i)
                let animDelay = baseDelay + anim.duration;
				if(validTargets) {
                    let target = validTargets.sample()

					setTimeout(()=>anim.exec(this, user, target), baseDelay)
					setTimeout(()=>{
						env.GENERIC_ACTIONS.singleTarget({
							action: this, 
							user, 
							target,
							hitSfx: { name: "stab", rate: 1.5, volume: 0.5 },
							critSfx: { name: "stab" },
							missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
							critStatus: {
								name: 'puncture',
								length: 2
							},
							hitStatus: {
								name: 'puncture',
								length: 2
							}
						})

						animElement.classList.add('scramble')
						setTimeout(()=>animElement.classList.remove('scramble'), 100)
					}, animDelay)
				}
			}

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.3) * 4)
        }
    },
	
	env.ACTIONS.aim_fullauto_flechette = {
        slug: "aim_fullauto_flechette",
        name: "Focus Fire::SYNTH",
        type: 'target',
        anim: "wobble",
		verb: "fire at",
        usage: {
            act: "%USER OPENS FIRE ON %TARGET",
        },
        details: {
            flavor: "'utilize internal flechette rifle';'rapid inaccurate attacks on singular target'",
            onUse: `'HIT target 3 times'`,
            onHit: `'[STAT::amt] [STATUS::puncture]'`,
            onCrit:`'[STATUS::puncture]'`
        },
        stats: {
            accuracy: .33,
            crit: 0.33,
            amt: 1,
            status: {
                puncture: {
                    name: 'puncture',
                    length: 2
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup_aim")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot

            if(target) for (let i = 0; i < 3; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.3) * i)
                let animDelay = baseDelay + anim.duration;

				setTimeout(()=>anim.exec(this, user, target), baseDelay)
				setTimeout(()=>{
					env.GENERIC_ACTIONS.singleTarget({
						action: this, 
						user, 
						target,
						hitSfx: { name: "stab", rate: 1.5, volume: 0.5 },
						critSfx: { name: "stab" },
						missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
						critStatus: {
							name: 'puncture',
							length: 2
						},
						hitStatus: {
							name: 'puncture',
							length: 2
						}
					})

					animElement.classList.add('scramble')
					setTimeout(()=>animElement.classList.remove('scramble'), 100)
				}, animDelay)
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.3) * 4)
        }
    },
	
	env.ACTIONS.special_fullauto_flechette_strong = {
        slug: "special_fullauto_flechette_strong",
        name: "Full Auto::SYNTH ELITE",
        type: 'special',
        anim: "wobble",
		verb: "fire at",
        usage: {
            act: "%USER OPENS FIRE",
        },
        details: {
            flavor: "'utilize flechette rifle';'rapid inaccurate attacks'",
            onUse: `'HIT random foes 6 times'`,
            onHit: `'[STAT::amt] [STATUS::puncture]'`,
            onCrit:`'[STATUS::puncture]'`
        },
        stats: {
            accuracy: .33,
            crit: 0.33,
            amt: 1,
            status: {
                puncture: {
                    name: 'puncture',
                    length: 2
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup_aim")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')
		
			let targetTeam
            switch(user.team.name) {
                case "ally": targetTeam = env.rpg.enemyTeam; break;
                case "enemy": targetTeam = env.rpg.allyTeam; break;
            }

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot
            let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

            if(validTargets.length) for (let i = 0; i < 6; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.3) * i)
                let animDelay = baseDelay + anim.duration;
				if(validTargets) {
                    let target = validTargets.sample()

					setTimeout(()=>anim.exec(this, user, target), baseDelay)
					setTimeout(()=>{
						env.GENERIC_ACTIONS.singleTarget({
							action: this, 
							user, 
							target,
							hitSfx: { name: "stab", rate: 1.5, volume: 0.5 },
							critSfx: { name: "stab" },
							missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
							critStatus: {
								name: 'puncture',
								length: 2
							},
							hitStatus: {
								name: 'puncture',
								length: 2
							}
						})

						animElement.classList.add('scramble')
						setTimeout(()=>animElement.classList.remove('scramble'), 100)
					}, animDelay)
				}
			}

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.3) * 7)
        }
    },
	
	env.ACTIONS.aim_fullauto_flechette_strong = {
        slug: "aim_fullauto_flechette_strong",
        name: "Focus Fire::SYNTH ELITE",
        type: 'target',
        anim: "wobble",
		verb: "fire at",
        usage: {
            act: "%USER OPENS FIRE ON %TARGET",
        },
        details: {
            flavor: "'utilize internal flechette rifle';'rapid inaccurate attacks on singular target'",
            onUse: `'HIT target 6 times'`,
            onHit: `'[STAT::amt] [STATUS::puncture]'`,
            onCrit:`'[STATUS::puncture]'`
        },
        stats: {
            accuracy: .33,
            crit: 0.33,
            amt: 1,
            status: {
                puncture: {
                    name: 'puncture',
                    length: 2
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup_aim")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot

            if(target) for (let i = 0; i < 6; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.3) * i)
                let animDelay = baseDelay + anim.duration;

				setTimeout(()=>anim.exec(this, user, target), baseDelay)
				setTimeout(()=>{
					env.GENERIC_ACTIONS.singleTarget({
						action: this, 
						user, 
						target,
						hitSfx: { name: "stab", rate: 1.5, volume: 0.5 },
						critSfx: { name: "stab" },
						missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
						critStatus: {
							name: 'puncture',
							length: 2
						},
						hitStatus: {
							name: 'puncture',
							length: 2
						}
					})

					animElement.classList.add('scramble')
					setTimeout(()=>animElement.classList.remove('scramble'), 100)
				}, animDelay)
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.3) * 7)
        }
    },
	
	env.ACTIONS.special_grenade_teleport = {
        slug: "special_grenade_teleport",
        name: "Infiltrator",
        type: 'special+target',
        desc: "'throw delayed bright kavruka';'present target a choice of outcome'",
        anim: "wobble",
		
        help: "CHOOSE::100% -2HP ::OR:: 50% -2HP (SELF:: -1HP), 50%C x2 +2T:PUNCTURE +1T:STUN (SELF:: -1HP)",
        usage: {
            act: "%USER THROWS A GRENADE AT %TARGET",
            crit: "%TARGET IS TELEFRAGGED",
            hit: "%USER TELEPORTS TO A BETTER POSITION",
            miss: "%USER MISSES"
        },
        accuracy: 1,
        crit: 0,
		details: {
            onUse: "'throw delayed bright kavruka';'present target a choice of outcome'",
            conditional: "<em>HIT 1</em>::'HIT::[STAT::hit1ACC] [STAT::hit1HP] to target, [STATUS::userfocused] [STATUS::userevasion] [STATUS::userempowered] to user CRIT::[STAT::hit2CRIT]% [STAT::hit1HP]'\n<em>HIT 2</em>::'HIT::AUTOHIT CRIT::0% -0HP';'-[STATUS::focused], -[STATUS::evasion], -[STATUS::empowered] -[STATUS::hyperfocus_flat] -[STATUS::evasion_mega]'"
        },

        stats: {
            hit1HP: 2,
            hit1ACC: 100,
            hit2HP: 1,
            hit2ACC: 50,
            hit2CRIT: 30,

            status: {
                stun: { name: 'stun', length: 1 },
                vulnerable: { name: 'vulnerable', length: 2 },
				focused: { name: 'focused', showReference: true },
				evasion: { name: 'evasion', showReference: true },
				empowered: { name: 'empowered', showReference: true },
				userfocused: { name: 'focused', length: 2 },
				userevasion: { name: 'evasion', length: 2 },
				userempowered: { name: 'empowered', length: 2 },
				hyperfocus_flat: { name: 'hyperfocus_flat', showReference: true },
				evasion_mega: { name: 'evasion_mega', showReference: true },
            },
        },
        exec: function(user, target) {
			let action = this

			//summon a div that lets the player click guaranteed or chance
			actionChoice({
				user: user,
				action: action,
				choiceText: `${user.name} throws a grenade at ${target.name}!`,
				options: [
					{text: "Stay and fight", definition: "NOTE::'100% -2HP, +2T:FOCUSED +2T:EVASION +2T:EMPOWERED TO USER, 30%C x2 +1T:STUN +2T:VULNERABLE'"},
					{text: "Abandon position", definition: "NOTE::'AUTOHIT -FOCUSED, -EVASION, -EMPOWERED, -TUNNEL VISION, -UNNATURAL SPEED'"},
				],
				choiceCallback: (c) => {
					//reap the consequences
						
					var hit
					switch(c) {
						case "c0":
							hit = combatHit(target, {amt: 2, acc: 1, crit: 0.3, origin: user});
							break;
						case "c1":
							hit = play("miss", 0.5)
								removeStatus(target, "focused")
								removeStatus(target, "evasion")
								removeStatus(target, "empowered")
								removeStatus(target, "hyperfocus_flat")
								removeStatus(target, "evasion_mega")
								actionMessage(user, "%TARGET RUNS AWAY", target)
							break
					}

					actionMessage(user, action, target, hit)
					switch(hit) {
						case "crit":                                
							playCombatCrit("dull", 0.6)
							addStatus({target: target, origin: user, status: "stun", length: 1})
							addStatus({target: target, origin: user, status: "vulnerable", length: 2, noReact: true})
							removeStatus(target, "windup")
							break
						case true:
							reactDialogue(target, 'receive_hit')
							addStatus({target: user, origin: user, status: "focused", length: 2})
							addStatus({target: user, origin: user, status: "evasion", length: 2})
							addStatus({target: user, origin: user, status: "empowered", length: 2})
							play("dull", 1)
							break;
						case false:
							reactDialogue(target, 'evade')
							play("dull", 1.25)
							break;
					}

					setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE);
				}
			})
		}
    },
	
	env.ACTIONS.limited_combatdrone_summon = {
		slug: "limited_combatdrone_summon",
		name: "Deploy Battle Drone",
		type: 'special+summon+nomimic',
		anim: "heal",
		details: {
			conditional: `<em>SUMMON::</em>'summon battle drone'`,
			onUse: `'remove this action'`
		},
		itemAction: true, //we have to lie here so that imps can't use this action
		noRepeat: true,
		exec: function(user, target) {
			actionMessage(user, "%USER SETS DOWN A FLYING DEAD METAL MONOLITH", target, 'none', 2000);
			play('talkcroak', 1, 0.75);
			if(user.team.name.includes("enemy")) {
				midCombatActorAdd(env.rpg.enemyTeam, 'cmb_combatdrone', 'left')
			} else {
				midCombatActorAdd(env.rpg.allyTeam, 'cmb_combatdrone', 'left')
			}
			user.actions = user.actions.filter(action => action !== "limited_combatdrone_summon")
			setTimeout(()=>advanceTurn(user), 1000)
		}
	},
	
	env.ACTIONS.aim_fullauto_drone = {
        slug: "aim_fullauto_drone",
        name: "Focus Fire::DRONE",
        type: 'target',
        anim: "wobble",
        usage: {
            act: "%USER OPENS FIRE ON %TARGET",
        },
        details: {
            flavor: "'utilize four automatic pulse rifles';'assault on singular target'",
            onUse: `'HIT target 24 times'`,
            onHit: `'[STAT::amt]'`,
        },
        stats: {
            accuracy: .25,
            crit: 0.25,
            amt: 1,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup_aim")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            let targetTeam
            switch(user.team.name) {
                case "ally": targetTeam = env.rpg.enemyTeam; break;
                case "enemy": targetTeam = env.rpg.allyTeam; break;
            }

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot

            if(target) for (let i = 0; i < 24; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.08) * i)
                let animDelay = baseDelay + anim.duration;
                    
				setTimeout(()=>anim.exec(this, user, target), baseDelay)
				setTimeout(()=>{
					env.GENERIC_ACTIONS.singleTarget({
						action: this, 
						user, 
						target,
						hitSfx: { name: "shot2", rate: 1.25, volume: 0.4 },
						critSfx: { name: "shot6", rate: 1.25, volume: 0.75 },
						missSfx: { name: "shot2", rate: 1.5, volume: 0.4 },
						/*critStatus: {
							name: 'vulnerable',
							length: 2 // god could you fucking imagine
						}*/
					})

					animElement.classList.add('scramble')
					setTimeout(()=>animElement.classList.remove('scramble'), 100)
				}, animDelay)
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.08) * 25)
        }
    },
	
	env.ACTIONS.special_fullauto_drone = { // rewriting this entirely so it actually works correctly
        slug: "special_fullauto_drone",
        name: "Full Auto::DRONE",
        type: 'special',
        anim: "wobble",
        usage: {
            act: "%USER OPENS FIRE",
        },
        details: {
            flavor: "'utilize four automatic pulse rifles';'accuracy by volume of fire'",
            onUse: `'HIT random foes 24 times'`,
            onHit: `'[STAT::amt]'`,
        },
        stats: {
            accuracy: .25,
            crit: 0.25,
            amt: 1,
        },
        exec: function(user, target, beingUsedAsync) {
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            let targetTeam
            switch(user.team.name) {
                case "ally": targetTeam = env.rpg.enemyTeam; break;
                case "enemy": targetTeam = env.rpg.allyTeam; break;
            }

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot
            let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

            if(validTargets.length) for (let i = 0; i < 24; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.08) * i)
                let animDelay = baseDelay + anim.duration;
                if(validTargets) {
                    let target = validTargets.sample()
                    
                    setTimeout(()=>anim.exec(this, user, target), baseDelay)
                    setTimeout(()=>{
                        env.GENERIC_ACTIONS.singleTarget({
                            action: this, 
                            user, 
                            target,
                            hitSfx: { name: "shot2", rate: 1.25, volume: 0.33 },
                            critSfx: { name: "shot6", rate: 1.25, volume: 0.75 },
                            missSfx: { name: "shot2", rate: 1.5, volume: 0.33 },
                        })

                        animElement.classList.add('scramble')
                        setTimeout(()=>animElement.classList.remove('scramble'), 100)
                    }, animDelay)
                }
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.08) * 25)
        }
    },
	
	env.ACTIONS.special_semiauto_mega = {
        slug: "special_semiauto_mega",
        name: "Semi Auto::AKIMBO",
        type: 'special',
        anim: "wobble",
        usage: {
            act: "%USER OPENS FIRE",
        },
        details: {
            flavor: "'utilize low-caliber pistols';'rapid inaccurate attacks'",
            onUse: `'HIT random foes 8 times'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable]'`
        },
        stats: {
            accuracy: .25,
            crit: 0.25,
            amt: 1,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            let targetTeam
            switch(user.team.name) {
                case "ally": targetTeam = env.rpg.enemyTeam; break;
                case "enemy": targetTeam = env.rpg.allyTeam; break;
            }

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot
            let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

            if(validTargets.length) for (let i = 0; i < 8; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
                let animDelay = baseDelay + anim.duration;
                if(validTargets) {
                    let target = validTargets.sample()
                    
                    setTimeout(()=>anim.exec(this, user, target), baseDelay)
                    setTimeout(()=>{
                        env.GENERIC_ACTIONS.singleTarget({
                            action: this, 
                            user, 
                            target,
                            hitSfx: { name: "shot2", rate: 1.25, volume: 0.5 },
                            critSfx: { name: "shot6", rate: 1.25 },
                            missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
                            critStatus: {
                                name: 'vulnerable',
                                length: 1
                            }
                        })

                        animElement.classList.add('scramble')
                        setTimeout(()=>animElement.classList.remove('scramble'), 100)
                    }, animDelay)
                }
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.2) * 9)
        }
    },
	
	env.ACTIONS.special_grenade_fear = {
        slug: "special_grenade_fear",
        name: "Fear Extractor",
        type: 'special+target',
        desc: "'throw delayed bright kavruka';'present target a choice of outcome'",
        anim: "wobble",
		
        help: "CHOOSE::100% -2HP ::OR:: 50% -2HP (SELF:: -1HP), 50%C x2 +2T:PUNCTURE +1T:STUN (SELF:: -1HP)",
        usage: {
            act: "%USER THROWS A GRENADE AT %TARGET",
            crit: "%TARGET'S TEAM GOES BLIND",
            hit: "%TARGET COWERS IN FEAR",
            miss: "%USER MISSES"
        },
        accuracy: 1,
        crit: 0,
		details: {
            onUse: "'throw delayed bright kavruka';'present target a choice of outcome'",
            conditional: "<em>HIT 1</em>::'HIT::[STAT::hit1ACC] [STAT::hit1HP] [STATUS::fear] [STATUS::blindness] CRIT::[STAT::hit2CRIT]% [STAT::hit1HP] additional [STATUS::fear] [STATUS::blindness] to all foes'\n<em>HIT 2</em>::'HIT::AUTOHIT CRIT::0% -0HP';'-[STATUS::focused], -[STATUS::evasion], -[STATUS::empowered] -[STATUS::hyperfocus_flat] -[STATUS::evasion_mega]'"
        },

        stats: {
            hit1HP: 1,
            hit1ACC: 100,
            hit2HP: 1,
            hit2ACC: 50,
            hit2CRIT: 30,

            status: {
                stun: { name: 'stun', length: 1 },
                fear: { name: 'fear', length: 3 },
				blindness: { name: 'blindness', length: 1 },
				focused: { name: 'focused', showReference: true },
				evasion: { name: 'evasion', showReference: true },
				empowered: { name: 'empowered', showReference: true },
				hyperfocus_flat: { name: 'hyperfocus_flat', showReference: true },
				evasion_mega: { name: 'evasion_mega', showReference: true },
            },
        },
        exec: function(user, target) {
			let action = this

			//summon a div that lets the player click guaranteed or chance
			actionChoice({
				user: user,
				action: action,
				choiceText: `${user.name} throws a grenade at ${target.name}!`,
				options: [
					{text: "Stay and fight", definition: "NOTE::'100% -1HP +3T:FEAR +BLINDNESS, 30%C x2 +3T:FEAR +BLINDESS TO ALL FOES'"},
					{text: "Abandon position", definition: "NOTE::'AUTOHIT -FOCUSED, -EVASION, -EMPOWERED, -TUNNEL VISION, -UNNATURAL SPEED'"},
				],
				choiceCallback: (c) => {
					//reap the consequences
						
					var hit
					switch(c) {
						case "c0":
							hit = combatHit(target, {amt: 1, acc: 1, crit: 0.3, origin: user});
							break;
						case "c1":
							hit = play("miss", 0.5)
								removeStatus(target, "focused")
								removeStatus(target, "evasion")
								removeStatus(target, "empowered")
								removeStatus(target, "hyperfocus_flat")
								removeStatus(target, "evasion_mega")
								actionMessage(user, "%TARGET RUNS AWAY", target)
							break
					}

					actionMessage(user, action, target, hit)
					switch(hit) {
						case "crit":                                
							playCombatCrit("talkfairy", 0.5)
							setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE)
							return env.GENERIC_ACTIONS.teamWave({
								team: user.enemyTeam,
								exec: (actor, i)=>{
									//combatHit(actor, {amt: 1, crit: 0, autohit: true, origin: user});
									addStatus({target: actor, status: "fear", length: 3}); 
									addStatus({target: target, origin: user, status: "blindness", length: 1})
									play("fear", 0.75)
								}
							})
							break
						case true:
							reactDialogue(target, 'receive_fear')
							addStatus({target: target, origin: user, status: "fear", length: 3})
							addStatus({target: target, origin: user, status: "blindness", length: 1})
							play("talkfairy", 0.75)
							break;
						case false:
							reactDialogue(target, 'evade')
							play("shot2", 0.75)
							break;
					}

					setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE);
				}
			})
		}
    },
	
	env.ACTIONS.special_fullauto_incendiary = {
        slug: "special_fullauto_incendiary",
        name: "Full Auto::INCENDIARY",
        type: 'special',
        anim: "wobble",
		verb: "fire at",
        usage: {
            act: "%USER OPENS FIRE",
        },
        details: {
            flavor: "'utilize incendiary rifle';'rapid inaccurate attacks'",
            onUse: `'HIT random foes 6 times'`,
            onHit: `'[STAT::amt] [STATUS::burning]'`,
            onCrit:`'[STATUS::burning]'`
        },
        stats: {
            accuracy: .33,
            crit: 0.33,
            amt: 1,
            status: {
                burning: { // note to self::name this chemical fire as a pale halls reference
                    name: 'burning',
                    length: 1
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup_aim")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')
		
			let targetTeam
            switch(user.team.name) {
                case "ally": targetTeam = env.rpg.enemyTeam; break;
                case "enemy": targetTeam = env.rpg.allyTeam; break;
            }

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot
            let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

            if(validTargets.length) for (let i = 0; i < 6; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.3) * i)
                let animDelay = baseDelay + anim.duration;
				if(validTargets) {
                    let target = validTargets.sample()

					setTimeout(()=>anim.exec(this, user, target), baseDelay)
					setTimeout(()=>{
						env.GENERIC_ACTIONS.singleTarget({
							action: this, 
							user, 
							target,
							hitSfx: { name: "shot", rate: 1.25, volume: 0.5 },
							critSfx: { name: "stab", rate: 0.65 },
							missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
							critStatus: {
								name: 'burning',
								length: 1
							},
							hitStatus: {
								name: 'burning',
								length: 1
							}
						})

						animElement.classList.add('scramble')
						setTimeout(()=>animElement.classList.remove('scramble'), 100)
					}, animDelay)
				}
			}

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.3) * 7)
        }
    },
	
	env.ACTIONS.special_grenade_incendiary = {
        slug: "special_grenade_incendiary",
        name: "Incendiary Extractor",
        type: 'special+target',
        desc: "'throw delayed bright kavruka';'present target a choice of outcome'",
        anim: "wobble",
		
        help: "CHOOSE::100% -2HP ::OR:: 50% -2HP (SELF:: -1HP), 50%C x2 +2T:PUNCTURE +1T:STUN (SELF:: -1HP)",
        usage: {
            act: "%USER THROWS A GRENADE AT %TARGET",
            crit: "%TARGET'S TEAM GOES UP IN FLAMES",
            hit: "%TARGET IS SET ABLAZE",
            miss: "%USER MISSES"
        },
        accuracy: 1,
        crit: 0,
		details: {
            onUse: "'throw delayed bright kavruka';'present target a choice of outcome'",
            conditional: "<em>HIT 1</em>::'HIT::[STAT::hit1ACC] [STAT::hit1HP] [STATUS::burning] CRIT::[STAT::hit2CRIT]% [STAT::hit1HP] additional [STATUS::burning] to all foes'\n<em>HIT 2</em>::'HIT::AUTOHIT CRIT::0% -0HP';'-[STATUS::focused], -[STATUS::evasion], -[STATUS::empowered] -[STATUS::hyperfocus_flat] -[STATUS::evasion_mega]'"
        },

        stats: {
            hit1HP: 1,
            hit1ACC: 100,
            hit2HP: 1,
            hit2ACC: 50,
            hit2CRIT: 30,

            status: {
                stun: { name: 'stun', length: 1 },
                burning: { name: 'burning', length: 2 },
				blindness: { name: 'blindness', length: 1 },
				focused: { name: 'focused', showReference: true },
				evasion: { name: 'evasion', showReference: true },
				empowered: { name: 'empowered', showReference: true },
				hyperfocus_flat: { name: 'hyperfocus_flat', showReference: true },
				evasion_mega: { name: 'evasion_mega', showReference: true },
            },
        },
        exec: function(user, target) {
			let action = this

			//summon a div that lets the player click guaranteed or chance
			actionChoice({
				user: user,
				action: action,
				choiceText: `${user.name} throws a grenade at ${target.name}!`,
				options: [
					{text: "Stay and fight", definition: "NOTE::'100% -1HP +3T:CHEMICAL FIRE, 30%C x2 +3T:CHEMICAL FIRE TO ALL FOES'"},
					{text: "Abandon position", definition: "NOTE::'AUTOHIT -FOCUSED, -EVASION, -EMPOWERED, -TUNNEL VISION, -UNNATURAL SPEED'"},
				],
				choiceCallback: (c) => {
					//reap the consequences
						
					var hit
					switch(c) {
						case "c0":
							hit = combatHit(target, {amt: 1, acc: 1, crit: 0.3, origin: user});
							break;
						case "c1":
							hit = play("miss", 0.5)
								removeStatus(target, "focused")
								removeStatus(target, "evasion")
								removeStatus(target, "empowered")
								removeStatus(target, "hyperfocus_flat")
								removeStatus(target, "evasion_mega")
								actionMessage(user, "%TARGET RUNS AWAY", target)
							break
					}

					actionMessage(user, action, target, hit)
					switch(hit) {
						case "crit":                                
							playCombatCrit("shot", 0.5)
							setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE)
							return env.GENERIC_ACTIONS.teamWave({
								team: user.enemyTeam,
								exec: (actor, i)=>{
									//combatHit(actor, {amt: 1, crit: 0, autohit: true, origin: user});
									addStatus({target: actor, status: "burning", length: 3}); 
									//addStatus({target: target, origin: user, status: "blindness", length: 1})
									play("shot", 0.75)
								}
							})
							break
						case true:
							reactDialogue(target, 'receive_fear')
							addStatus({target: target, origin: user, status: "burning", length: 3})
							//addStatus({target: target, origin: user, status: "blindness", length: 1})
							play("shot", 0.75)
							break;
						case false:
							reactDialogue(target, 'evade')
							play("shot2", 0.75)
							break;
					}

					setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE);
				}
			})
		}
    },
	
	env.ACTIONS.aim_fullauto_incendiary = {
        slug: "aim_fullauto_incendiary",
        name: "Focus Fire::INCENDIARY",
        type: 'target',
        anim: "wobble",
		verb: "fire at",
        usage: {
            act: "%USER OPENS FIRE ON %TARGET",
        },
        details: {
            flavor: "'utilize incendiary rifle';'rapid inaccurate attacks on singular target'",
            onUse: `'HIT target 6 times'`,
            onHit: `'[STAT::amt] [STATUS::burning]'`,
            onCrit:`'[STATUS::burning]'`
        },
        stats: {
            accuracy: .33,
            crit: 0.33,
            amt: 1,
            status: {
                burning: { // note to self::name this chemical fire as a pale halls reference
                    name: 'burning',
                    length: 1
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup_aim")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot

            if(target) for (let i = 0; i < 6; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.3) * i)
                let animDelay = baseDelay + anim.duration;

				setTimeout(()=>anim.exec(this, user, target), baseDelay)
				setTimeout(()=>{
					env.GENERIC_ACTIONS.singleTarget({
						action: this, 
						user, 
						target,
						hitSfx: { name: "shot", rate: 1.25, volume: 0.5 },
						critSfx: { name: "stab", rate: 0.65 },
						missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
						critStatus: {
							name: 'burning',
							length: 1
						},
						hitStatus: {
							name: 'burning',
							length: 1
						}
					})

					animElement.classList.add('scramble')
					setTimeout(()=>animElement.classList.remove('scramble'), 100)
				}, animDelay)
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.3) * 7)
        }
    },
	
	env.ACTIONS.aim_fullauto_minigun = {
        slug: "aim_fullauto_minigun",
        name: "Focus Fire::MINIGUN",
        type: 'target',
		
        anim: "wobble",
        usage: {
            act: "%USER OPENS FIRE ON %TARGET",
        },
        details: {
            flavor: "'utilize automatic pulse rifle';'assault on singular target'",
            onUse: `'HIT target 48 times'`,
            onHit: `'[STAT::amt]'`,
        },
        stats: {
            accuracy: .20,
            crit: 0.20,
            amt: 1,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup_aim")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot

            if(target) for (let i = 0; i < 48; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.05) * i)
                let animDelay = baseDelay + anim.duration;
                if(target) {
                    setTimeout(()=>anim.exec(this, user, target), baseDelay)
                    setTimeout(()=>{
                        env.GENERIC_ACTIONS.singleTarget({
                            action: this, 
                            user, 
                            target,
                            hitSfx: { name: "shot2", rate: 1.25, volume: 0.4 },
                            critSfx: { name: "shot6", rate: 1.25, volume: 0.75 },
                            missSfx: { name: "shot2", rate: 1.5, volume: 0.4 },
                            /*critStatus: {
                                name: 'vulnerable',
                                length: 2 // god could you fucking imagine
                            }*/
                        })

                        animElement.classList.add('scramble')
                        setTimeout(()=>animElement.classList.remove('scramble'), 100)
                    }, animDelay)
                }
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.05) * 49)
        }
    },
	
	env.ACTIONS.special_fullauto_chopper = {
        slug: "special_fullauto_chopper",
        name: "Full Auto::WINDER",
        type: 'special',
        anim: "wobble",
        usage: {
            act: "%USER OPENS FIRE",
        },
        details: {
            flavor: "'utilize mounted pulse rifle';'rapid inaccurate attacks'",
            onUse: `'HIT random foes 48 times'`,
            onHit: `'[STAT::amt]'`,
        },
        stats: {
            accuracy: .20,
            crit: 0.20,
            amt: 1,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            let targetTeam
            switch(user.team.name) {
                case "ally": targetTeam = env.rpg.enemyTeam; break;
                case "enemy": targetTeam = env.rpg.allyTeam; break;
            }

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot
            let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

            if(validTargets.length) for (let i = 0; i < 48; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.05) * i)
                let animDelay = baseDelay + anim.duration;
                if(validTargets) {
                    let target = validTargets.sample()
                    
                    setTimeout(()=>anim.exec(this, user, target), baseDelay)
                    setTimeout(()=>{
                        env.GENERIC_ACTIONS.singleTarget({
                            action: this, 
                            user, 
                            target,
                            hitSfx: { name: "shot2", volume: 0.5 },
                            critSfx: { name: "shot6" },
                            missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
                            /*critStatus: {
                                name: 'vulnerable',
                                length: 1
                            }*/
                        })

                        animElement.classList.add('scramble')
                        setTimeout(()=>animElement.classList.remove('scramble'), 100)
                    }, animDelay)
                }
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.05) * 49)
        }
    },
	
	env.ACTIONS.lastresort_bombingrun = { //stealing this directly from the funny exogolem mod
		slug: "lastresort_bombingrun",
		name: "Bombing Run",
		type: 'special',
		desc: "'weaponize dullnode array';'rapid inaccurate attacks';'likely to cause successive detonations'",
		anim: "wobble",
		help: "-WINDUP, x8 RANDOM ENEMY::33% -1HP 50%C x2 + (FOES::100% -1HP +1T:PUNCTURE +1T:VULNERABLE)",
		usage: {
			act: "%USER BOMBS THE BATTLEFIELD",
		},
		details: {
            flavor: "'last resort';'utilize all remaining munitions'",
            onUse: `'HIT random foes 8 times'`,
            onHit: `'[STAT::amt]'`,
			onCrit: `'additional [STAT::amt] to all foes'`
        },
        stats: {
            accuracy: .33,
            crit: 0.33,
            amt: 1,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                },
            },
        },
		exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup")
			let initialRate = env.bgm.rate()

			if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
			play('shot', 1)

			let targetTeam
			switch(user.team.name) {
				case "ally": targetTeam = env.rpg.enemyTeam; break;
				case "enemy": targetTeam = env.rpg.allyTeam; break;
			}

			let anim = env.COMBAT_ANIMS.shoot
			let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

			if(validTargets.length) for (let i = 0; i < 8; i++) {
				let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
				let animDelay = baseDelay + anim.duration;
				if(validTargets) {
					let target = validTargets.sample()
					
					setTimeout(()=>anim.exec(this, user, target), baseDelay)
					setTimeout(()=>{
						env.GENERIC_ACTIONS.singleTarget({
							action: this, 
							user, 
							target,
							hitSfx: { name: "hit", rate: 2},
							critSfx: { name: "shot6", rate: 0.75},
							missSfx: { name: "shot2", rate: 1.5, volume: 1  },
							critExec: ()=> env.GENERIC_ACTIONS.teamWave({
								team: user.enemyTeam,
								exec: (actor, i)=>{
									combatHit(actor, {amt: 1, crit: 0, acc: 1, origin: user});
									play("shot", 1)
								}
							})
						})
					}, animDelay)
				}
			}

			setTimeout(()=>{                
				if(!beingUsedAsync) advanceTurn(user)
				if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
			}, (env.ADVANCE_RATE * 0.2) * 9)
		}
	},
	
	env.ACTIONS.warp_cannon_gunship = {
        slug: "warp_cannon_gunship",
        name: "Warp Cannon",
        verb: "blast",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER LETS LOOSE THE WARP CANNON",
            hit: "%TARGET IS ANNIHILATED",
			crit: "%TARGET DISINTEGRATES",
			miss: "%TARGET RUNS AWAY",
        },
        details: {
            flavor: "'utilize particle cannon';'massive damage';'telegraphed from a great distance'",
            onHit: `'[STAT::amt]'`,
        },
        stats: {
            accuracy: 0.5,
            crit: 0.1,
            amt: 15,
            status: {
                stun: {
                    name: "stun",
                    length: 3
                }
            }
        },
        itemAction: true,
        exec: function(user, target) {
			removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'dull',
                    rate: 0.5
                },
				critSfx: {
					name: 'shot',
					rate: 0.5
				}
            })
        }
    },
	
	env.ACTIONS.aim_fullauto_gunship = {
        slug: "aim_fullauto_gunship",
        name: "Focus Fire::SKYSHIELD",
        type: 'target',
        anim: "wobble",
		verb: "fire at",
        usage: {
            act: "%USER OPENS FIRE ON %TARGET",
        },
        details: {
            flavor: "'utilize automatic pulse rifle';'rapid inaccurate attacks on singular target'",
            onUse: `'HIT target 16 times'`,
            onHit: `'[STAT::amt]'`,
        },
        stats: {
            accuracy: .33,
            crit: 0.33,
            amt: 1,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup_aim")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot

            if(target) for (let i = 0; i < 16; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.1) * i)
                let animDelay = baseDelay + anim.duration;

				setTimeout(()=>anim.exec(this, user, target), baseDelay)
				setTimeout(()=>{
					env.GENERIC_ACTIONS.singleTarget({
						action: this, 
						user, 
						target,
						hitSfx: { name: "shot2", volume: 0.5 },
						critSfx: { name: "shot6" },
						missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
						/*critStatus: {
							name: 'vulnerable',
							length: 2
						}*/
					})

					animElement.classList.add('scramble')
					setTimeout(()=>animElement.classList.remove('scramble'), 100)
				}, animDelay)
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.1) * 17)
        }
    },
	
	env.ACTIONS.aim_fullauto_strider = {
        slug: "aim_fullauto_strider",
        name: "Focus Fire::CAUTERIZER",
        type: 'target',
        anim: "wobble",
		verb: "fire at",
        usage: {
            act: "%USER OPENS FIRE ON %TARGET",
        },
        details: {
            flavor: "'utilize heavy automatic pulse rifle';'rapid inaccurate attacks on singular target'",
            onUse: `'HIT target 12 times'`,
            onHit: `'[STAT::amt]'`,
			conditional: `'accuracy increases over time'`,
        },
        stats: {
            accuracy: .1,
            crit: 0.1,
            amt: 3,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup_aim")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()
			let acc = this.stats.accuracy

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot

            if(target) for (let i = 0; i < 12; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
                let animDelay = baseDelay + anim.duration;

				setTimeout(()=>anim.exec(this, user, target), baseDelay)
				setTimeout(()=>{
					this.stats.accuracy = acc + (0.05 * i)
					env.GENERIC_ACTIONS.singleTarget({
						action: this, 
						user, 
						target,
						hitSfx: { name: "shot2", volume: 0.5 },
						critSfx: { name: "shot6" },
						missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
						/*critStatus: {
							name: 'vulnerable',
							length: 2
						}*/
					})

					animElement.classList.add('scramble')
					setTimeout(()=>animElement.classList.remove('scramble'), 100)
				}, animDelay)
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
				this.stats.accuracy = 0.1
            }, (env.ADVANCE_RATE * 0.2) * 13)
        }
    },
	
	env.ACTIONS.aim_fullauto_strider_mega = {
        slug: "aim_fullauto_strider_mega",
        name: "Focus Fire::CAUTERIZER ENRAGED",
        type: 'target',
        anim: "wobble",
		verb: "fire at",
        usage: {
            act: "%USER OPENS FIRE ON %TARGET",
        },
        details: {
            flavor: "'utilize heavy automatic pulse rifle';'rapid inaccurate attacks on singular target'",
            onUse: `'HIT target 24 times'`,
            onHit: `'[STAT::amt]'`,
			conditional: `'accuracy increases over time'`,
        },
        stats: {
            accuracy: .1,
            crit: 0.1,
            amt: 3,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup_aim")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()
			let acc = this.stats.accuracy

            //animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            //damage self on use if you aren't bstrd
            //if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot

            if(target) for (let i = 0; i < 24; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.1) * i)
                let animDelay = baseDelay + anim.duration;

				setTimeout(()=>anim.exec(this, user, target), baseDelay)
				setTimeout(()=>{
					this.stats.accuracy = acc + (0.05 * i)
					env.GENERIC_ACTIONS.singleTarget({
						action: this, 
						user, 
						target,
						hitSfx: { name: "shot2", volume: 0.5 },
						critSfx: { name: "shot6" },
						missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
						/*critStatus: {
							name: 'vulnerable',
							length: 2
						}*/
					})

					animElement.classList.add('scramble')
					setTimeout(()=>animElement.classList.remove('scramble'), 100)
				}, animDelay)
            }

            setTimeout(()=>{
                //animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
				this.stats.accuracy = 0.1
            }, (env.ADVANCE_RATE * 0.1) * 25)
        }
    },
	
	env.ACTIONS.warp_cannon_strider = {
        slug: "warp_cannon_strider",
        name: "Warp Cannon",
        verb: "blast",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER LETS LOOSE THE WARP CANNON",
            hit: "%TARGET IS ANNIHILATED",
			crit: "%TARGET DISINTEGRATES",
			miss: "%TARGET RUNS AWAY",
        },
        details: {
            flavor: "'utilize particle cannon';'massive damage';'telegraphed from a great distance'",
            onHit: `'[STAT::amt]'`,
        },
        stats: {
            accuracy: 0.7,
            crit: 0.1,
            amt: 30,
            status: {
                stun: {
                    name: "stun",
                    length: 3
                }
            }
        },
        itemAction: true,
        exec: function(user, target) {
			removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'dull',
                    rate: 0.5
                },
				critSfx: {
					name: 'shot',
					rate: 0.5
				}
            })
        }
    },
	
	env.ACTIONS.special_headcrab_summon = {
        slug: "special_headcrab_summon",
        name: "Deploy Biotics",
        type: 'special+summon',
        anim: "heal",
		availableCrabs: ['cmb_headcrab', 'cmb_headcrab_fast', 'cmb_headcrab_poison'],
        details: {
            flavor: `'disperse held allies'`,
            conditional: `<em>SUMMON::</em>'summon 2 headcrabs'`
        },
		usage: {
            act: "A PAIR OF HEADCRABS EMERGE FROM %USER"
        },
        noRepeat: true,
        exec: function(user, target) {
			let leftCrab = this.availableCrabs.sample()
			let rightCrab = this.availableCrabs.sample()
            play('dull', 0.8, 1);
			if(user.team.name == "enemy") {
                midCombatActorAdd(env.rpg.enemyTeam, leftCrab, 'left')
                midCombatActorAdd(env.rpg.enemyTeam, rightCrab, 'right')
			}
			else if(user.team.name == "ally") {
				midCombatActorAdd(env.rpg.allyTeam, leftCrab, 'left')
                midCombatActorAdd(env.rpg.allyTeam, rightCrab, 'right')
			}

            setTimeout(()=>advanceTurn(user), 1000)
        }
    },
	
	env.ACTIONS.headcrab_parasitize = {
        slug: "headcrab_parasitize",
        name: "Parasitize",
        type: 'target',
        desc: "'swipe blindly at target';'chance for persistent wound'",
        anim: "basic-attack",
        help: "70% -1HP, 20%C x2 +1T:PUNCTURE -REGEN",
		availableZombies: ["cmb_zombie", "cmb_zombie", "cmb_zombie", "cmb_zombine", "cmb_zombine", "cmb_zombine_elite"],
        usage: {
            act: "%USER LEAPS AT %TARGET",
            crit: "%TARGET IS PARASITIZED",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET DUCKS OUT OF THE WAY"
        },
		details: {
            flavor: "'blind leap at target';'attempt to attach self to brainstem'",
            onHit: `'[STAT::amt]'`,
			onCrit: `'replace user with stronger actor'`,
        },
        stats: {
            accuracy: .7,
			crit: 0.1,
            amt: 1,
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                critExec: ()=> {
					let nextZombie = this.availableZombies.sample()
					if(user.team.name == "enemy") {
						midCombatActorAdd(env.rpg.enemyTeam, nextZombie, 'right')
					}
					else if(user.team.name == "ally") {
						midCombatActorAdd(env.rpg.allyTeam, nextZombie, 'right')
					}
					midCombatActorRemove(user)
				}
            })
        }
    },
	
	env.ACTIONS.headcrab_parasitize_fast = {
        slug: "headcrab_parasitize_fast",
        name: "Parasitize",
        type: 'target',
        desc: "'swipe blindly at target';'chance for persistent wound'",
        anim: "basic-attack",
        help: "70% -1HP, 20%C x2 +1T:PUNCTURE -REGEN",
		availableZombies: ["cmb_zombie_fast"],
        usage: {
            act: "%USER LEAPS AT %TARGET",
            crit: "%TARGET IS PARASITIZED",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET DUCKS OUT OF THE WAY"
        },
		details: {
            flavor: "'blind leap at target';'attempt to attach self to brainstem'",
            onHit: `'[STAT::amt] [STATUS::puncture]'`,
			onCrit: `'replace user with stronger actor'`,
        },
        stats: {
            accuracy: .7,
			crit: 0.1,
            amt: 1,
			status: {
                puncture: {
                    name: 'puncture',
                    length: 2
                }
            }
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
				hitSfx: {
					name: 'stab',
					rate: 1
				},
				hitStatus: this.stats.status.puncture, // this should work
                critExec: ()=> {
					let nextZombie = this.availableZombies.sample()
					if(user.team.name == "enemy") {
						midCombatActorAdd(env.rpg.enemyTeam, nextZombie, 'right')
					}
					else if(user.team.name == "ally") {
						midCombatActorAdd(env.rpg.allyTeam, nextZombie, 'right')
					}
					midCombatActorRemove(user)
				}
            })
        }
    },
	
	env.ACTIONS.headcrab_parasitize_poison = {
        slug: "headcrab_parasitize_poison",
        name: "Parasitize",
        type: 'target',
        desc: "'swipe blindly at target';'chance for persistent wound'",
        anim: "basic-attack",
        help: "70% -1HP, 20%C x2 +1T:PUNCTURE -REGEN",
		availableZombies: ["cmb_zombie_poison", "cmb_zombie_poison", "cmb_zombie_poison", "cmb_zombine_poison", "cmb_zombine_poison", "cmb_zombine_poison_elite"],
        usage: {
            act: "%USER LEAPS AT %TARGET",
            crit: "%TARGET IS PARASITIZED",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET DUCKS OUT OF THE WAY"
        },
		details: {
            flavor: "'blind leap at target';'attempt to attach self to brainstem'",
            onHit: `'[STAT::amt] [STATUS::poison]'`,
			onCrit: `'replace user with stronger actor'`,
        },
        stats: {
            accuracy: .9,
			crit: 0.2,
            amt: 1,
			status: {
                poison: {
                    name: 'poison',
                    length: 2
                }
            }
        },
        exec: function(user, target) {
			removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
				hitSfx: {
					name: 'stab',
					rate: 0.75
				},
				hitStatus: this.stats.status.poison, // this should work
                critExec: ()=> {
					let nextZombie = this.availableZombies.sample()
					if(user.team.name == "enemy") {
						midCombatActorAdd(env.rpg.enemyTeam, nextZombie, 'right')
					}
					else if(user.team.name == "ally") {
						midCombatActorAdd(env.rpg.allyTeam, nextZombie, 'right')
					}
					midCombatActorRemove(user)
				}
            })
        }
    },
	
	env.ACTIONS.special_poisonheadcrab_summon = {
        slug: "special_poisonheadcrab_summon",
        name: "Throw Them",
        type: 'target',
        desc: "'swipe blindly at target';'chance for persistent wound'",
        anim: "basic-attack",
        help: "70% -1HP, 20%C x2 +1T:PUNCTURE -REGEN",
        usage: {
            act: "%USER LEAPS AT %TARGET",
            crit: "%TARGET IS PARASITIZED",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET DUCKS OUT OF THE WAY"
        },
		details: {
            flavor: "'disperse held allies'",
            onHit: `'[STAT::amt] [STATUS::poison]'`,
			onCrit: `'additional [STATUS::poison]'`,
			conditional: `<em>SUMMON::</em>'summon additional poison headcrab'`,
        },
        stats: {
            accuracy: .9,
			crit: 0.2,
            amt: 1,
			status: {
                poison: {
                    name: 'poison',
                    length: 2
                }
            }
        },
        exec: function(user, target) {
			removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
				hitSfx: {
					name: 'stab',
					rate: 0.75
				},
				critSfx: {
					name: 'stab',
					rate: 0.5
				},
				hitStatus: this.stats.status.poison, // this should work
				critStatus: this.stats.status.poison,
                genExec: ()=> {
					if(user.team.name == "enemy") {
						midCombatActorAdd(env.rpg.enemyTeam, 'cmb_headcrab_poison', 'right')
					}
					else if(user.team.name == "ally") {
						midCombatActorAdd(env.rpg.allyTeam, 'cmb_headcrab_poison', 'right')
					}
				}
            })
        }
    },
	
	env.ACTIONS.special_grenade_kamikaze = {
        slug: "special_grenade_kamikaze",
        name: "Pull Pin",
        type: 'autohit',
        anim: "",
        usage: {
            act: "%USER PREPARES A GRENADE..."
        },
        details: {
            flavor: `'prepare a devastating attack';'charge forward without worry'`,
            onUse: `'[STATUS::vulnerable] to user'`
        },
        stats: {
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },            
            }
        },
        
        exec: function(user, target) {
            play('fear', 0.75);
            addStatus({target: user, status: "vulnerable", length: 2}); 
			user.actions = ["grenade_kamikaze"]
            return 'nothing';
        }
    },
	
	env.ACTIONS.grenade_kamikaze = {
        slug: "grenade_kamikaze",
        name: "Kamikaze",
        type: 'target',
        desc: "'detonate to instantly destroy target';'reap consequences'",
        anim: "basic-attack",
        help: "AUTOHIT -10HP, DESTROY SELF\nONCE PER COMBAT",
        usage: {
            act: "%USER EXPLODES NEAR %TARGET",
            hit: "%TARGET IS DESTROYED",
        },
		details: {
            flavor: `'reap consequences'`,
            onHit: `'[STAT::amt]';'destroy self'`
        },
		stats: {
			accuracy: 1,
			amt: 20,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },            
            }
        },
        exec: function(user, target) {
            user.hp = 0
            user.detonated = true
            updateStats({actor: user})
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'shot',
                    rate: 0.66
                },
            })
        },
        disableIf: (actor)=>{ if(actor.detonated) return "ONCE PER COMBAT" },
    },
	
	env.ACTIONS.special_antlion_summon = {
        slug: "special_antlion_summon",
        name: "Restrict Exogens",
        type: 'special+summon',
        anim: "heal",
		availableAnts: ['cmb_antlion', 'cmb_antlion', 'cmb_antlion', 'cmb_antlion', 'cmb_antlion', 'cmb_antlion_worker', 'cmb_antlion_worker', 'cmb_antlion_worker', 'cmb_antlion_guard', 'cmb_antlion_guard_cave'],
        details: {
            flavor: `'disperse held allies'`,
            conditional: `<em>SUMMON::</em>'summon 2 antlions'`
        },
		usage: {
            act: "A PAIR OF ANTLIONS EMERGE FROM THE SOIL"
        },
        noRepeat: true,
        exec: function(user, target) {
			let leftAnt = this.availableAnts.sample()
			let rightAnt = this.availableAnts.sample()
            play('shot2', 0.5, 1);
			if(user.team.name == "enemy") {
                midCombatActorAdd(env.rpg.enemyTeam, leftAnt, 'left')
                midCombatActorAdd(env.rpg.enemyTeam, rightAnt, 'right')
			}
			else if(user.team.name == "ally") {
				midCombatActorAdd(env.rpg.allyTeam, leftAnt, 'left')
                midCombatActorAdd(env.rpg.allyTeam, rightAnt, 'right')
			}

            setTimeout(()=>advanceTurn(user), 1000)
        }
    },
	
	env.ACTIONS.worker_attack = {
        slug: "worker_attack",
        name: "Spit Acid",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER SPRINTS AT %TARGET",
            crit: "%TARGET'S TEAM IS COATED IN ACID",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET EVADES"
        },
        details: {
            onHit: `'[STAT::amt] [STATUS::poison]'`,
            onCrit:`'[STATUS::poison] to all foes'`,
        },
        stats: {
            accuracy: .8,
            crit: 0.1,
            amt: 2,
            status: {
                poison: {
                    name: 'poison',
                    length: 2
                }
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
				hitStatus: this.stats.status.poison,
				hitSfx: {
					name: 'stab',
					rate: 0.75
				},
				critSfx: {
					name: 'stab',
					rate: 0.5
				},
                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i)=>{
                        addStatus({target: actor, origin: user, status: "poison", origin: user, length: 2}); 
                        play('stab', 0.75);
                    }
                })
            })
        }
    },
	
	env.ACTIONS.antlion_smash = {
        slug: "antlion_smash",
        name: "Guarding Strike",
        type: 'target',
        desc: "'focused, deadly attack upon one target';'immense physical trauma'",
        anim: "basic-attack",
        help: "100% -4HP, 40% X2 +1T:STUN",
        usage: {
            act: "%USER CHARGES %TARGET",
            crit: "%TARGET IS LEFT REELING",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'focused, deadly attack upon one target';'immense physical trauma'",
            onHit: `'[STAT::amt]'`,
            onCrit: `'[STATUS::stun]'`,
        },
        stats: {
			accuracy: 0.8,
            crit: 0.2,
            amt: 6,
            status: {
                stun: {
                    name: 'stun',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
            removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'hit',
                    rate: 0.8
                },
                critStatus: {
                    name: 'stun',
                    length: 1
                }
            })
        }
    },
	
	env.ACTIONS.antlion_smash_toxin = {
        slug: "antlion_smash_toxin",
        name: "Toxic Strike",
        type: 'target',
        desc: "'focused, deadly attack upon one target';'immense physical trauma'",
        anim: "basic-attack",
        help: "100% -4HP, 40% X2 +1T:STUN",
        usage: {
            act: "%USER CHARGES %TARGET",
            crit: "%TARGET IS LEFT REELING",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'focused, deadly attack upon one target';'immense physical trauma'",
            onHit: `'[STAT::amt] [STATUS::poison]'`,
            onCrit: `'[STATUS::stun] [STATUS::poison]'`,
        },
        stats: {
			accuracy: 0.8,
            crit: 0.2,
            amt: 6,
            status: {
                stun: {
                    name: 'stun',
                    length: 1
                },
				poison: {
                    name: 'poison',
                    length: 3
                },
				open_wound: {
                    name: 'open_wound',
                    length: 2
                }
            },
        },
        exec: function(user, target) {
            removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'hit',
                    rate: 0.8
                },
                hitExec: ({target})=> {
                    addStatus({target, status: "poison", length: 3});
                },
                critExec: ({target})=>{
					addStatus({target, status: "poison", length: 3, noReact: true});
                    addStatus({target, status: "stun", length: 1}); 
                }
            })
        }
    },
	
	env.ACTIONS.mad_claw_mega = { // a quick detour
        slug: "mad_claw_mega",
        name: "Metacognition",
        verb: "claw at",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER ATTACKS %TARGET",
            crit: "A FRIGHTENING BLOW, BUT FROM WHOM?",
            hit: "%TARGET IS STRUCK, BUT BY WHAT?",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'grasp the nature of this place';'afflict target with incoherence'",
            onHit: `'[STAT::amt]';'inflict one of following';'[STATUS::destabilized]';'[STATUS::fear]';'[STATUS::stun]'`,
			onCrit: `'inflict one of following';'[STATUS::destabilized]';'[STATUS::fear]';'[STATUS::stun]'`,
        },
        stats: {
            accuracy: .9,
            crit: 0.4,
            amt: 3,
            status: {
                destabilized: {
                    name: 'destabilized',
                    length: 2
                },
                fear: {
                    name: 'fear',
                    length: 2
                },
                stun: {
                    name: 'stun',
                    length: 1
                },
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'dull',
                    rate: 1
                },
                hitExec: ({target})=> {
                    let rand = Math.random()
                    if(rand < 0.2) {
                        addStatus({target, origin: user, status: "destabilized", origin: user, length: 2}); 
                        
                    } else if(rand < 0.4) {
                        addStatus({target, origin: user, status: "fear", origin: user, length: 2}); 

                    } else {
                        addStatus({target, origin: user, status: "stun", origin: user, length: 1}); 
                    }
                },
				critExec: ({target})=> {
                    let rand1 = Math.random()
                    if(rand1 < 0.2) {
                        addStatus({target, origin: user, status: "destabilized", origin: user, length: 2}); 
                        
                    } else if(rand1 < 0.4) {
                        addStatus({target, origin: user, status: "fear", origin: user, length: 2}); 

                    } else {
                        addStatus({target, origin: user, status: "stun", origin: user, length: 1}); 
                    }
                }
            })
        }
    }, 
	
	env.ACTIONS.special_inversion_noadvance = {
        slug: "special_inversion_noadvance",
        name: "Inversion",
        type: 'special',
        anim: "wobble",
        usage: {
            act: "%USER PUSHES AGAINST THEIR REALITY"
        },
        details: {
            flavor: "'grasp the nature of this place';'recognize and exploit framing device'",
            onUse:`'[STATUS::incoherent]';'invert all statuses currently in play'`
        },
        stats: {
            status: {
                incoherent: {
                    name: 'incoherent',
                    length: 1
                },
            },
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkfairy", 1.5)
            addStatus({target: user, status: "incoherent", length: 1, noReact: true})
            let action = this
            
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'talkfairy',
                            rate: 0.75
                        },
                        genExec: ({target}) => {
                            invertStatuses(actor)
                        }
                    })
                },
                advanceAfterExec: false, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.special_incoherent_combinesummon = { // NOTE TO SELF::i coded this while Real Sleepy, so CHECK FOR BUGS AND SYNTAX ERRORS BEFORE TESTING IT !!!!!!!!!!!!!!!!!!
        slug: "special_incoherent_combinesummon",
        name: "Superportal",
        type: 'special+summon',
        anim: "",
		availableSummonsCop: ["cmb_cop_pawn", "cmb_cop_pawn", "cmb_cop_pawn", "cmb_cop_pawn", "cmb_cop_knight", "cmb_cop_bishop", "cmb_cop_bishop_support", "cmb_cop_rook", "cmb_cop_queen", "cmb_cop_king", "cmb_cop_king_target"],
        availableSummonsSoldier: ["cmb_soldier_pawn", "cmb_soldier_pawn", "cmb_soldier_pawn", "cmb_soldier_knight", "cmb_soldier_bishop", "cmb_soldier_bishop_support", "cmb_soldier_rook", "cmb_soldier_rook_prospekt", "cmb_soldier_queen", "cmb_soldier_queen_shotgun", "cmb_soldier_king", "cmb_soldier_king_support"],
		availableSummonsSpecial: ["cmb_special_pawn", "cmb_special_pawn_shotgun", "cmb_special_knight", "cmb_soldier_king_support", "cmb_special_bishop", "cmb_special_bishop_shotgun", "cmb_special_bishop_support", "cmb_special_bishop_support_shotgun", "cmb_special_rook", "cmb_special_rook_elite", "cmb_special_queen", "cmb_special_queen_smg", "cmb_special_queen_assassin", "cmb_special_king", "cmb_special_king_veteran", "cmb_special_king_veteran_ar2", "cmb_special_king_veteran_shotgun", "cmb_special_king_juggernaut"],
		availableSummonsBoss: ["cmb_cop_queen", "cmb_cop_king", "cmb_cop_king_target", "cmb_soldier_queen", "cmb_soldier_queen_shotgun", "cmb_soldier_king", "cmb_soldier_king_support", "cmb_special_queen", "cmb_special_queen_smg", "cmb_special_queen_assassin", "cmb_special_king", "cmb_special_king_veteran", "cmb_special_king_veteran_ar2", "cmb_special_king_veteran_shotgun", "cmb_special_king_juggernaut", "cmb_hunterchopper", "cmb_gunship", "cmb_strider", "cmb_canister", "cmb_thumper", "cmb_canister", "cmb_thumper"],
		details: {
            flavor: `'collect additional allies from offworld'`,
            conditional: `<em>SUMMON::</em>'summon 6 soldiers (max:6)'`
        },
		usage: {
            act: "%USER INVADES THE BATTLEFIELD"
        },

        noRepeat: true,
        exec: function(user, target) {
			let nextAvailableSummons = this.availableSummonsCop // easy ish enemies
			if(user.hp < user.maxhp * 0.75 && user.hp > user.maxhp * 0.5) {
				nextAvailableSummons = this.availableSummonsSoldier // "oh shit there's actually a threat, get the real soldiers in here"
			} else if(user.hp < user.maxhp * 0.5 && user.hp > user.maxhp * 0.25) {
				nextAvailableSummons = this.availableSummonsSpecial // upping the ante (and the appeasment damage :3)
			} else if(user.hp < user.maxhp * 0.25) {
				nextAvailableSummons = this.availableSummonsBoss // pulling out all da stops !!!!
			}
			let summon1 = nextAvailableSummons.sample() // are all six of these necessary ?
			let summon2 = nextAvailableSummons.sample() // probably not, no...
			let summon3 = nextAvailableSummons.sample() // but i don't know how else to do this :P
			let summon4 = nextAvailableSummons.sample() // so it shall remain this way
			let summon5 = nextAvailableSummons.sample()
			let summon6 = nextAvailableSummons.sample()

            play('dull', 0.5, 1);
			midCombatActorAdd(env.rpg.enemyTeam, summon1, 'left')
			midCombatActorAdd(env.rpg.enemyTeam, summon2, 'left')
			midCombatActorAdd(env.rpg.enemyTeam, summon3, 'left')
			midCombatActorAdd(env.rpg.enemyTeam, summon4, 'right')
			midCombatActorAdd(env.rpg.enemyTeam, summon5, 'right')
			midCombatActorAdd(env.rpg.enemyTeam, summon6, 'right')

            setTimeout(()=>advanceTurn(user), 1000)
        },
        disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('cmb_')).length >= 2) return "TOO MANY ALLIES" }
    },

		// funny firing squad actions
	env.ACTIONS.special_fullauto_heavy = {
        slug: "special_fullauto_heavy",
        name: "Full Auto",
        type: 'special',
        anim: "wobble",
        usage: {
            act: "%USER OPENS FIRE",
        },
        details: {
            flavor: "'utilize heavy automatic rifle';'rapid inaccurate attacks'",
            onUse: `'HIT random foes 6 times'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable_mega]'`
        },
        stats: {
            accuracy: .33,
            crit: 0.33,
            amt: 2,
            status: {
                vulnerable_mega: {
                    name: 'vulnerable_mega',
                    length: 1
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1', 0.75)

            let targetTeam
            switch(user.team.name) {
                case "ally": targetTeam = env.rpg.enemyTeam; break;
                case "enemy": targetTeam = env.rpg.allyTeam; break;
            }

            //damage self on use if you aren't bstrd
            if(!["Rifle Golem"].includes(user.name)) combatHit(user, {amt: 2, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot
            let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

            if(validTargets.length) for (let i = 0; i < 6; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
                let animDelay = baseDelay + anim.duration;
                if(validTargets) {
                    let target = validTargets.sample()
                    
                    setTimeout(()=>anim.exec(this, user, target), baseDelay)
                    setTimeout(()=>{
                        env.GENERIC_ACTIONS.singleTarget({
                            action: this, 
                            user, 
                            target,
                            hitSfx: { name: "shot2" },
                            critSfx: { name: "shot", rate: 0.75 },
                            missSfx: { name: "shot2", volume: 0.5 },
                            critStatus: {
                                name: 'vulnerable_mega',
                                length: 1
                            }
                        })

                        animElement.classList.add('scramble')
                        setTimeout(()=>animElement.classList.remove('scramble'), 100)
                    }, animDelay)
                }
            }

            setTimeout(()=>{
                animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.2) * 7)
        }
    },
	
	env.ACTIONS.fullauto_shotgun_mega = {
        slug: "fullauto_shotgun_mega",
        name: "Super Boomstick",
        type: 'target',
        anim: "wobble",
		verb: "blast",
        usage: {
            act: "%USER BLASTS %TARGET",
        },
        details: {
            flavor: "'utilize double barrelled shotgun';'rapid attacks on single target'",
            onUse: `'HIT target 20 times'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable]'`
        },
        stats: {
            accuracy: .15,
            crit: 0.15,
            amt: 1,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            //damage self on use if you aren't bstrd
            if(!["Shotgun Golem"].includes(user.name)) combatHit(user, {amt: 2, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot
			if(target) for (let i = 0; i < 20; i++) {
				let baseDelay = ((env.ADVANCE_RATE * 0.016) * i)
				let animDelay = baseDelay + anim.duration;

				setTimeout(()=>anim.exec(this, user, target), baseDelay)
				setTimeout(()=>{
					env.GENERIC_ACTIONS.singleTarget({
						action: this, 
						user, 
						target,
						hitSfx: { name: "shot2", volume: 0.5 },
						critSfx: { name: "shot6" },
						missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
						critStatus: {
							name: 'vulnerable',
							length: 1
						},
						genExec: () => {
							animElement.classList.add('scramble')
							if(!user.hasBlammed) {
								animElement.classList.add('gunblam')
								user.hasBlammed = true
							}
						}
					})
				}, animDelay)
			}

			setTimeout(()=>{
				animElement.classList.remove('aiming')
				animElement.classList.remove('gunblam')
				animElement.classList.remove('scramble')
				user.hasBlammed = false
				if(!beingUsedAsync) advanceTurn(user)
				if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
			}, (env.ADVANCE_RATE * 0.2) * 4)
        }
    },
	
	env.ACTIONS.special_fullauto_grenade = {
        slug: "special_fullauto_grenade",
        name: "Launch Grenades",
        type: 'special',
        anim: "wobble",
        usage: {
            act: "%USER OPENS FIRE",
        },
        details: {
            flavor: "'utilize rotary grenade launcher';'rapid inaccurate attacks'",
            onUse: `'HIT random foes 6 times'`,
            onHit: `'[STAT::amt]'`,
            onCrit: ()=> `'HIT all foes for [STAT::amt] [STATUS::vulnerable]';${page.name == "frame" ? `;'additional hits trigger on-hit effects'` : ``}`,
        },
        stats: {
            accuracy: .33,
            crit: 0.33,
            amt: 1,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1', 0.75)

            let targetTeam
            switch(user.team.name) {
                case "ally": targetTeam = env.rpg.enemyTeam; break;
                case "enemy": targetTeam = env.rpg.allyTeam; break;
            }

            let anim = env.COMBAT_ANIMS.shoot
            let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")

            if(validTargets.length) for (let i = 0; i < 6; i++) {
				//damage self on use if you aren't bstrd
				if(!["Grenade Golem"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})
                let baseDelay = ((env.ADVANCE_RATE * 0.3) * i)
                let animDelay = baseDelay + anim.duration;
                if(validTargets) {
                    let target = validTargets.sample()
                    
                    setTimeout(()=>anim.exec(this, user, target), baseDelay)
                    setTimeout(()=>{
                        env.GENERIC_ACTIONS.singleTarget({
                            action: this, 
                            user, 
                            target,
                            hitSfx: { name: "shot2", rate: 0.75 },
                            critSfx: { name: "stab", rate: 1.75 },
                            missSfx: { name: "shot2", rate: 1, volume: 0.5 },
                            critExec: ()=> env.GENERIC_ACTIONS.teamWave({
								team: user.enemyTeam,
								exec: (actor, i)=>{
									combatHit(actor, {amt: 1, crit: 0, accuracy: 0.33, origin: user});
									addStatus({target: actor, status: "vulnerable", length: 1}); 
									play("shot", 1.25)
								}
							})
                        })

                        animElement.classList.add('scramble')
                        setTimeout(()=>animElement.classList.remove('scramble'), 100)
                    }, animDelay)
                }
            }

            setTimeout(()=>{
                animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.3) * 7)
        }
    },
	
	env.ACTIONS.daze_lastresort_mega = {
        slug: "daze_lastresort_mega",
        name: "Bash",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER SWINGS AT %TARGET",
            crit: "%TARGET IS LEFT REELING",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'last resort attack';'swing weapon'",
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::stun]'`,
        },
        stats: {
            accuracy: .5,
            crit: 0.5,
            amt: 3,
            status: {
                stun: {
                    name: 'stun',
                    length: 1
                },
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                critStatus: {
                    name: 'stun',
                    length: 1
                }
            })
        },
        disableIf: (actor) => {
            if(actor.team.name == "ally") return false;
            //disable if you aren't the last standing
            return actor.team.members.some(member => ((member != actor) && (member.state != "dead")) )
        }
    },
	
	env.ACTIONS.windup_amr = {
        slug: "windup_amr",
        name: "Raise Weapon",
        type: 'autohit',
        anim: "",
        usage: {
            act: "%USER BRACES THEMSELVES..."
        },
        details: {
            onUse: `'[STATUS::windup]'`
        },
        stats: {
            status: {
                windup: {
                    name: 'windup',
                    length: 1
                },            
            }
        },
        exec: function(user, target) {
			let animElement = user.sprite || user.box
            play('talklaugh', 0.5);
			animElement.classList.add('aiming')
            addStatus({target: user, status: "windup", length: 1}); 
            return 'nothing';
        }
    },
	
	env.ACTIONS.hold_aim_amr = {
        slug: "hold_aim_amr",
        name: "Take Aim",
        type: 'autohit',
        anim: "",
        usage: {
            act: "%USER WAITS FOR THE RIGHT MOMENT..."
        },
        details: {
			flavor: "'prepare a devastating attack';'look for opportunity'",
            onUse: `'[STATUS::windup] [STATUS::evasion]'`,
        },
        stats: {
            status: {
                evasion: {
                    name: 'evasion',
                    length: 2
                },
                windup: {
                    name: 'windup',
                    length: 1
                },
                focused: {
                    name: 'focused',
                    length: 1
                },
            },
        }, 
        noRepeat: true,
        exec: function(user, target) {
            play("talkgel", 0.5)
            addStatus({target: user, status: "windup", length: 1}); 
            addStatus({target: user, status: "evasion", length: 2, noReact: true}); 
            return 'nothing';
        }
    },
	
	env.ACTIONS.focused_shot_amr = {
        slug: "focused_shot_amr",
        name: "Hyperfocused Shot",
        verb: "shoot",
        type: 'target',
        anim: "skitter",
        usage: {
            act: "%USER FIRES AT %TARGET",
            crit: "%TARGET IS ANNIHILATED",
            hit: "%TARGET TAKES A MASSIVE HIT",
            miss: "%USER MISSES"
        },
        details: {
            flavor: "'utilize excessive force';'incalculable physical trauma'",
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::stun] [STATUS::vulnerable_mega] [STATUS::fatal_flaw]'`,
        },
        stats: {
            accuracy: 1,
            crit: 0.2,
            amt: 15,
            status: {
                vulnerable_mega: {
                    name: 'vulnerable_mega',
                    length: 4
                },
                stun: {
                    name: 'stun',
                    length: 2
                },
                fatal_flaw: {
                    name: 'fatal_flaw',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
			let animElement = user.sprite || user.box
            removeStatus(user, "windup")
			removeStatus(user, "evasion")
			removeStatus(user, "evasion_mega")
			animElement.classList.add('scramble')
			animElement.classList.add('gunblam')
			setTimeout(()=>animElement.classList.remove('gunblam'), 200)
			setTimeout(()=>animElement.classList.remove('scramble'), 200)
			setTimeout(()=>animElement.classList.remove('aiming'), 700)
			//damage self on use if you aren't bstrd
			if(!["AMR Golem"].includes(user.name)) combatHit(user, {amt: 10, crit: 0, autohit: true, origin: user})
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'shot',
                    rate: 0.6
                },
                critSfx: {
                    name: 'shot',
                    rate: 0.85
                },
                missSfx: { name: "shot2", rate: 0.4 },
                critExec: ({target})=>{
                    addStatus({target, status: "vulnerable_mega", length: 4}) 
                    addStatus({target, status: "stun", length: 2}) 
                    addStatus({target, status: "fatal_flaw", length: 1})
                }
            })
        },
		disableIf: (actor)=>{ if(!hasStatus(actor,"evasion") && !hasStatus(actor,"evasion_mega")) return "REQUIRES EVASION/UNNATURAL SPEED" }
    },
	
	env.ACTIONS.windup_bfg = {
        slug: "windup_bfg",
        name: "Preparation",
        type: 'autohit',
        anim: "",
        usage: {
            act: "%USER PREPARES AN ATTACK..."
        },
        details: {
            flavor: `'prepare a devastating attack'`,
            onUse: `'[STATUS::windup]'`
        },
        stats: {
            status: {
                windup: {
                    name: 'windup',
                    length: 1
                },            
            }
        },
        exec: function(user, target) {
			let animElement = user.sprite || user.box
            play('talklaugh', 0.5);
			animElement.classList.add('aiming')
            addStatus({target: user, status: "windup", length: 1}); 
            return 'nothing';
        }
    },
	
	env.ACTIONS.bfg_shot = {
        slug: "bfg_shot",
        name: "BFG9000",
        verb: "BFG",
        type: 'target',
        anim: "skitter",
        usage: {
            act: "%USER BLASTS %TARGET",
            crit: "%TARGET IS ANNIHILATED",
            hit: "%TARGET IS SEARED",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: `'utilize extremely powerful energy weapon';'meaning of the acronym is unclear'`,
            onHit: `'[STAT::amt] [STATUS::stun]'`,
			onCrit: () => `'HIT all foes for [STAT::amt] [STATUS::vulnerable]'${page.name == "frame" ? `;'additional hits trigger on-hit effects'` : ``}`,
        },
        stats: { 
            accuracy: 0.9, 
            crit: 0.1,
            amt: 8,
			selfHP: 4,
            status: {
                stun: {
                    name: 'stun',
                    length: 1
                },
				vulnerable: {
                    name: 'vulnerable',
                    length: 2
                }
            }
        },
        exec: function(user, target) {
			let animElement = user.sprite || user.box
			//damage self on use if you aren't bstrd
			if(!["BFG Golem"].includes(user.name)) combatHit(user, {amt: 4, crit: 0, autohit: true, origin: user})
            removeStatus(user, "windup")
			animElement.classList.add('scramble')
			animElement.classList.add('gunblam')
			setTimeout(()=>animElement.classList.remove('gunblam'), 200)
			setTimeout(()=>animElement.classList.remove('scramble'), 200)
			setTimeout(()=>animElement.classList.remove('aiming'), 700)
			let action = this;
            return env.GENERIC_ACTIONS.singleTarget({
                action, 
                user, 
                target,
                hitSfx: {
                    name: 'dull',
                    rate: 0.5
                },
                critSfx: {
                    name: 'shot2',
                    rate: 0.4
                },
				missSfx: {
                    name: 'dull',
                    rate: 0.4
                },
                hitExec: ({target}) => {
                    addStatus({target, status: "stun", length: 1});
                },
				critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i)=>{
                        combatHit(actor, {amt: 4, crit: 0, autohit: true, origin: user});
                        addStatus({target: actor, status: "vulnerable", length: 2}); 
                        play("dull", 0.6)
                    }
                })
            })
        }
    },
	
	env.ACTIONS.special_intrusive_rematch = {
        slug: "special_intrusive_rematch",
        name: "Intrude",
        type: 'special+nomimic',
        anim: "",
        autohit: true,
        details: {
            flavor: "'Ã¢Â«Â§Ã¢ÂªÂ¶Ã£Â¥Â¥Ã£Â³'",
            onUse: `'DDO UB LLE  E OR  NOTH I  NN  N G  GG'`,
        },
        usage: {
            act: "A MYSTERIOUS GAMBLE IS MADE"
        },
        noRepeat: true,
        possibleSpawns: ["intrusive_blockershelf", "intrusive_bstrd", "intrusive_maintcloak", "intrusive_statusfreak"],
        possiblePassives: ["lightning_veilktouch", "light_humorist", "heart_adaptive", "metal_drone", "chaos_discombobulate", "lightning_storm", "heart_mutual", "malware_drill", "malware_rot", "weak_point", "weak_point"],
        exec: function(user, target, beingUsedAsync) {
            if(!user.chancePanel) throw 'ok intrusive spawned wrong';
            if(user.hp <= user.maxhp * 0.33) addStatus({target: user, origin: user, status: "rage", origin: user, length: 1}); 
            let action = this

            user.chancePanel.classList.add("active")
            user.chancePanel.classList.remove("hidden")
            user.chancePanel.spin(true)
            play("talkfairy", 0.25)
            let result

            setTimeout(()=>{
                result = user.chancePanel.stopAndResult()
                playCombatCrit("crit", 0.75)
            }, 2000)

            setTimeout(()=>{
                switch(result) {
                    case 6: // life up - gives 10HP and 5 turns of antidote to everyone
                        user.chancePanel.result.innerHTML = "NO HELP :=) HEHE"
                        env.GENERIC_ACTIONS.teamWave({
                            arbitraryActorList: env.rpg.turnOrder,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: -10,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talklaugh',
                                        rate: 0.5
                                    },
                                    hitStatus: {
                                        name: 'antidote',
                                        length: 5
                                    },
									genExec: ()=> {
										combatHit(actor, {amt: -10, origin: user, autohit: true, beneficial: true}); //for reasons unclear to me, life up can't heal on its own so we have to do this shenaniganry
									}
                                })
                            },
                            advanceAfterExec: true, beingUsedAsync, user,
                        })
                    break

                    case 2: // main up - everyone gets focus
                        user.chancePanel.result.innerHTML = "NO HELP :=) HEHE"
                        env.GENERIC_ACTIONS.teamWave({
                            arbitraryActorList: env.rpg.turnOrder,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: 0,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talklaugh',
                                        rate: 0.5
                                    },
                                    hitStatus: {
                                        name: 'focused',
                                        length: 3
                                    },
                                    genExec: ({target}) => {
                                        if(target.team.name == "ally") { 
											addStatus({target, status: "empowered", length: 2, noReact: true})
											addStatus({target, status: "surge", length: 1, noReact: true})
										}
                                    }
                                })
                            },
                            advanceAfterExec: true, beingUsedAsync, user,
                        })
                    break

                    case 3: // spawns enemies
                    case 1: // unlucky
                        user.chancePanel.result.innerHTML = "NO HELP :=) HEHE"
                        playCombatCrit("dull", 0.5)
                        if(user.team.members.length < 13) {
                            if(user.lastSide) {
                                midCombatActorAdd(env.rpg.enemyTeam, this.possibleSpawns.sample(), 'left')
                                user.lastSide = 0
                            } else {
                                midCombatActorAdd(env.rpg.enemyTeam, this.possibleSpawns.sample(), 'right')
                                user.lastSide = 1
                            }
                        } else {
                            useAction(user, env.ACTIONS.special_mass_denature, user, {triggerActionUseEvent: false, beingUsedAsync: true})
                        }
                        //make sure everyone is ethereal, despawn any early deaths
                        for (const teammate of user.team.members) {
                            if(teammate == user) continue;
                            if(!hasStatus(teammate, "ethereal") && teammate.state == "dead") { midCombatActorRemove(teammate) }
                            else if(!hasStatus(teammate, "ethereal")) addStatus({target: teammate, status: "ethereal", length: 1, noReact: true}) 
                        }
                        setTimeout(()=>advanceTurn(user), 1000)
                    break

                    case 5: // bombs - spawns a bastard bomb factory
                        user.chancePanel.result.innerHTML = "NO HELP :=) HEHE"
                        playCombatCrit("dull", 0.5)
                        if(user.team.members.length < 13) {
                            midCombatActorAdd(env.rpg.enemyTeam, "intrusive_factory", 'right')
                        } else {
                            useAction(user, env.ACTIONS.special_mass_denature, user, {triggerActionUseEvent: false, beingUsedAsync: true})
                        }
                        for (const teammate of user.team.members) {
                            if(teammate == user) continue;
                            if(!hasStatus(teammate, "ethereal") && teammate.state == "dead") { midCombatActorRemove(teammate) }
                            else if(!hasStatus(teammate, "ethereal")) addStatus({target: teammate, status: "ethereal", length: 1, noReact: true}) 
                        }
                        setTimeout(()=>advanceTurn(user), 1000)
                    break

                    case 4: // change - gives everyone a special passive that's overridden by each change roll
                        user.chancePanel.result.innerHTML = "NO HELP :=) HEHE"
                        env.GENERIC_ACTIONS.teamWave({
                            arbitraryActorList: env.rpg.turnOrder,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: 0,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talkfairy',
                                        rate: 0.5
                                    },
                                    genExec: ({target}) => {
                                        let currentStatuses = target.statusEffects.map(status => status.slug)
                                        let possiblePassives = this.possiblePassives.filter(statusName => !currentStatuses.includes(statusName))
                                        console.log("in with", target, possiblePassives)
                                        //special ones can happen on certain creatures
                                        if(
                                            !target.slug.includes("intrusive") ||
                                            target.slug == "intrusive_maintcloak"
                                        ) {
											possiblePassives.push("intrusive_maladaptive")
											possiblePassives.push("metal_autonomous")
										}
                                        if(
                                            !target.slug.includes("intrusive") ||
                                            target.slug == "intrusive_maintcloak" ||
                                            target.slug == "intrusive_statusfreak"
                                        ) {
											possiblePassives.push("active_support")
											possiblePassives.push("hands_penance")
										}
                                        if(
                                            !target.slug.includes("intrusive") ||
                                            target.slug == "intrusive_maintcloak" ||
                                            target.slug == "intrusive_statusfreak"
                                        ) {
											possiblePassives.push("impatient")
											possiblePassives.push("chaos_locknload")
										}
                                        // remove passive beforehand if one exists
                                        if(target.intrusivePassive) { removeStatus(target, target.intrusivePassive, {forceRemoveStatus: true}) }
                                        target.intrusivePassive = possiblePassives.sample()
                                        addStatus({target, status: target.intrusivePassive, length: 1, noReact: true})                                        
                                    }
                                })
                            },
                            advanceAfterExec: true, beingUsedAsync, user,
                        })
                    break
                }
            }, 3000)

            setTimeout(()=>user.chancePanel.classList.remove("active"), 6000)
        }
    },
	
	env.ACTIONS.special_trusiveshelf_annihilation = {
        slug: "special_trusiveshelf_annihilation",
        name: "Annihilation",
        type: 'special+nomimic',
        anim: "wobble",
        choiceAnim: "special_choice-movefriend",
        choiceAnimDuration: 200,
        usage: {
            act: "THE THOUGHTSPACE SHIFTS AROUND %TARGET",
        },
        details: {
            onUse: `'present target foe a choice of outcome'`,
            conditional: `<em>HIT 1</em>::'HIT::[STAT::hit1ACC]% CRIT::[STAT::hit2CRIT]% [STAT::hit1HP]';'[STATUS::stun] [STATUS::open_wound] [STATUS::vulnerable] [STATUS::critical_flaw] on CRIT'\n<em>HIT 2</em>::'[STATUS::redirection] to all allies'`
        },
        stats: {
            hit1HP: 4,
            hit1ACC: 100,
            hit2HP: 2,
            hit2ACC: 50,
            hit2CRIT: 40,
            status: {
                stun: {
                    name: 'stun',
                    length: 1
                },
                open_wound: {
                    name: 'open_wound',
                    length: 2
                },
                vulnerable: {
                    name: 'vulnerable',
                    length: 3
                },
                critical_flaw: {
                    name: 'critical_flaw',
                    length: 1
                },
				redirection: {
                    name: 'redirection',
                    length: 2
                },
            },
        },
        noRepeat: true,
        exec: function(user, target) {
            user.sprite.classList.add('special_choice-movefriend')
            let action = this
            //summon a div that lets the player click guaranteed or chance
            actionChoice({
                user: user,
                action: action,
                choiceText: `The thoughtspace twists around ${target.name}...`,
                options: [
                    {text: "Withstand the attack", definition: "NOTE::'100% -4HP 40%C x2 +1T:STUN +2T:OPEN WOUND +3T:VULNERABLE +CRITICAL FLAW'"},
                    {text: "Run away", definition: "NOTE::'ALLIES::+2T:REDIRECTION (TO USER)'"},
                ],
                choiceCallback: (c) => {
                    //reap the consequences
                    user.sprite.classList.add(action.anim)

                    var hit
                    switch(c) {
                        case "c0":
                            hit = useAction(user, env.ACTIONS.intrusive_smash, target, {triggerActionUseEvent: true, beingUsedAsync: true, reason: "???"}) // this should be fine
                            break;
                        case "c1":
                            hit = useAction(user, env.ACTIONS.special_guard_all, target, {triggerActionUseEvent: true, beingUsedAsync: true, reason: "???"})
                            break
                    }

                    setTimeout(()=> user.sprite.classList.remove(action.anim), 600);
                    setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE);
                }
            })
        }
    },
	
	env.ACTIONS.special_fullauto_intrusive = {
        slug: "special_fullauto_intrusive",
        name: "Unnatural Auto",
        type: 'special',
        anim: "wobble",
        usage: {
            act: "%USER OPENS FIRE",
        },
        details: {
            flavor: "'utilize dual automatic rifles';'rapid inaccurate attacks'",
            onUse: `'HIT random foes 12 times'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable] [STATUS::open_wound] [STATUS::critical_flaw]'`
        },
        stats: {
            accuracy: .33,
            crit: 0.33,
            amt: 1,
            status: {
                open_wound: {
                    name: 'open_wound',
                    length: 1
                },
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                },
                critical_flaw: {
                    name: 'critical_flaw',
                    length: 1
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup")
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.25)
            play('click1')

            let targetTeam
            switch(user.team.name) {
                case "ally": targetTeam = env.rpg.enemyTeam; break;
                case "enemy": targetTeam = env.rpg.allyTeam; break;
            }

            //damage self on use if you aren't bstrd
            if(!["???"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot
            let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")
			animElement.classList.add('scramble')
			setTimeout(()=>animElement.classList.remove('scramble'), 1200)

            if(validTargets.length) for (let i = 0; i < 12; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.1) * i)
                let animDelay = baseDelay + anim.duration;
                if(validTargets) {
                    let target = validTargets.sample()

                    setTimeout(()=>anim.exec(this, user, target), baseDelay)
                    setTimeout(()=>{
                        env.GENERIC_ACTIONS.singleTarget({
                            action: this, 
                            user, 
                            target,
                            hitSfx: { name: "shot2", volume: 0.5 },
                            critSfx: { name: "shot6", rate: 0.75 },
                            missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
                            critExec: ({target})=> {
								addStatus({target, origin: user, status: "open_wound", length: 1, noReact: true})
								addStatus({target, origin: user, status: "vulnerable", length: 1, noReact: true})
								addStatus({target, origin: user, status: "critical_flaw", length: 1, noReact: true})
							}
                        })
                    }, animDelay)
                }
            }

            setTimeout(()=>{
                animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.2) * 7)
        }
    },
	
	env.ACTIONS.special_unnatural_barrier = {
        slug: "special_unnatural_barrier",
        name: "Unnatural Cover",
        type: 'special',
        anim: "cloak-barrier",
        animDuration: 4000,
        autohit: true,
        usage: {
            act: "%USER SHIELDS THEIR ALLIES"
        },
        details: {
            flavor: "'broadly apply ablative protection';'upgraded barrier rapidly mends wounds and improves striking power while active'",
            onUse: `'[STAT::amtBP] [STATUS::unnatural_repairs] to nearby allies'`,
        },
        stats: {
            crit: 0,
            amtBP: 2,
            amt: 2,
            status: { 
                unnatural_repairs: {
                    name: 'unnatural_repairs', 
                    length: 1
                },
            } 
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this

            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        beneficial: true,
                        type: 'barrier',
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'mend',
                            rate: 0.75
                        },
                        hitStatus: {
                            name: 'unnatural_repairs',
                            length: 1
                        },
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.special_bomblet_summon = {
		slug: "special_bomblet_summon",
		name: "Mass Produce",
		type: 'special+summon+nomimic',
		anim: "heal",
		details: {
			flavor: "'manufacture additional allies from within self'",
			conditional: "<em>SUMMON::</em>'summon 1 ??? (max:???)'"
		},
		exec: function(user, target) {
			removeStatus(user, "windup")
			play('dull', 0.7, 1);
			midCombatActorAdd(env.rpg.enemyTeam, "intrusive_bomblet", 'right')
			setTimeout(()=>advanceTurn(user), 1000)
		},
		disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('intrusive_bomblet')).length > actor.team.members.filter(m=>m.slug.includes('intrusive_factory')).length * 6) return "TOO MANY BOMBS" } // 
	},
	
	env.ACTIONS.reconstruct_mega = {
		slug: "reconstruct_mega",
		name: "Reimagine",
		type: 'summon+target',
		anim: "basic-attack",
		possibleSpawns: ["angelGreater_pawn", "angelGreater_knight", "angel_Greaterbishop", "angelGreater_rook", "angelGreater_queen", "angelGreater_king"],
		usage: {
			act: "%USER REACHES TOWARDS %TARGET",
			crit: "%TARGET IS MADE ANEW",
			hit: "%TARGET REVOLTS",
			miss: "%TARGET RESISTS CONTROL"
		},
		details: {
            flavor: "'attempt to directly rewrite target to assist user in combat'",
            onHit: "'[STAT::amt]';'inflict one of following';'[STATUS::destabilized]';'[STATUS::open_wound]';'[STATUS::weakened]'",
            onCrit: "'summon greater angelic ally (max:4)';'additionally inflict one of following';'[STATUS::destabilized]';'[STATUS::open_wound]';'[STATUS::weakened]'",
        },
        stats: {
            accuracy: 0.7,
            crit: 0.15,
            amt: 4,
            status: {
                weakened: { name: 'weakened', length: 4 },
				open_wound: { name: 'open_wound', length: 4 },
				destabilized: { name: 'destabilized', length: 4 },
            },
        },
		exec: function(user, target) {
			removeStatus(user, "winderup")
			//let fated = user.statusEffects.find(status => status.slug == "fated_spine")
			return env.GENERIC_ACTIONS.singleTarget({
				action: this,
				user,
				target,
				hitSfx: { name: "stab", rate: 0.5 },
				critSfx: { name: "scarydoia", rate: 0.4 },
				hitExec: ({target})=> {
                    let rand = Math.random()
                    if(rand < 0.3) {
                        addStatus({target, origin: user, status: "destabilized", origin: user, length: 4}); 
                    } else if(rand < 0.6) {
                        addStatus({target, origin: user, status: "open_wound", origin: user, length: 4}); 
                    } else {
                        addStatus({target, origin: user, status: "weakened", origin: user, length: 4}); 
                    }
                },
				critExec: ({target}) => {
					let rand1 = Math.random()
                    if(rand1 < 0.3) {
                        addStatus({target, origin: user, status: "destabilized", origin: user, length: 4}); 
                    } else if(rand1 < 0.6) {
                        addStatus({target, origin: user, status: "open_wound", origin: user, length: 4}); 
                    } else {
                        addStatus({target, origin: user, status: "weakened", origin: user, length: 4}); 
                    }
					let newAllySlug = this.possibleSpawns.sample()
					user.lastSide = !user.lastSide
					if(user.team.members.filter(m=>m.slug.includes('angelGreater_')).length < 4) {
						midCombatActorAdd(env.rpg.allyTeam, newAllySlug, user.lastSide ? "left" : "right")
					}
				}
			})
		}
	},
	
	env.ACTIONS.enforce_support = {
        slug: "enforce_support",
        name: "Defensive Frenzy",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER STABS %TARGET",
            crit: "%USER JUST KEEPS GOING",
            hit: "%TARGET BLEEDS SLUDGY CORRU",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'relentless assault with positioning appendages';'may inspire additional smashing'",
            onHit: `'[STAT::amt] [STATUS::puncture] [STATUS::open_wound]'`,
            onCrit:`'use this action again';'[STATUS::regen] [STATUS::carapace] to nearby allies'`,
        },
        stats: {
            accuracy: .9,
            crit: 0.15,
            amt: 1,
            status: {
                puncture: {
                    name: 'puncture',
                    length: 1
                },
                open_wound: {
                    name: 'open_wound',
                    length: 1
                },
				regen: {
                    name: 'regen',
                    length: 1
                },
                carapace: {
                    name: 'carapace',
                    length: 1
                }
            },
        },
        accuracy: 0.9,
        crit: 0.15,
        amt: 1,
        exec: function(user, target) {
            let action = this
            return env.GENERIC_ACTIONS.singleTarget({
                action, 
                user, 
                target,
                hitSfx: {
                    name: 'hit',
                    rate: 0.7
                },
                critSfx: {
                    name: 'hit',
                    rate: 1.5
                },
                hitExec: ({target}) => {
                    addStatus({target, status: "puncture", length: 1});
                    addStatus({target, status: "open_wound", length: 1});
                },
                critExec: ({target})=> {
                    if(target.hp > 0 && target.state != "lastStand") {
                        env.setTimeout(()=>{
                            useAction(user, this, target, {beingUsedAsync: true, reason: "enforcement"})
                        }, 400)
                    }
					env.GENERIC_ACTIONS.teamWave({
						team: user.team,
						exec: (actor, i)=>{
							addStatus({target: actor, origin: user, status: "regen", length: this.stats.status.regen.length})
							addStatus({target: actor, origin: user, status: "carapace", length: this.stats.status.carapace.length});
							play('mend', 1, 0.5)
						}
					})
                }
            })
        }
    },
	
	env.ACTIONS.blink_guard = {
        slug: "blink_guard",
        name: "Intervene",
        type: 'support+target+autohit',
        anim: "heal",
        usage: {
            act: "%USER TELEPORTS IN FRONT OF %TARGET",
            hit: "%TARGET IS SHIELDED BY %USER"
        },
        details: {
            flavor: "'stand in the way of target';'intercept and dodge incoming attacks'",
            onUse: `'[STATUS::evasion_mega]';'[STATUS::redirection] to target'`,
        },
        stats: {
            status: {
                evasion_mega: {
                    name: 'evasion_mega',
                    length: 2
                },
                redirection: {
                    name: 'redirection',
                    length: 2
                },
            },
        },
        autohit: true,
        beneficial: true,
        exec: function(user, target) {
            reactDialogue(user, `give_redirection`)
            return env.GENERIC_ACTIONS.singleTarget({
                beneficial: true,
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'guard',
                    rate: 1
                },
                hitStatus: {
                    name: 'redirection',
                    length: 2
                },
                genExec: ({}) => {
                    addStatus({target: user, status: "evasion_mega", length: 2});
                },
            })
        },
    },
	
	env.ACTIONS.special_rule_angel = {
        slug: "special_rule_angel",
        name: "Continuous Reinforcement",
        type: 'special',
        anim: "",
        usage: {
            act: "%USER SHIFTS THE BALANCE"
        },
        details: {
            flavor: "'utilize status control to defend team';'afflict opponents with vulnerability and inaccuracy'",
            conditional: "<em>SELF::</em>[STATUS::windup]\n<em>ALLIES::</em>[STAT::amtBP] [STATUS::chitinous]\n<em>FOES::</em>[STAT::amt] [STATUS::vulnerable] [STATUS::cursed]",
        },
        stats: {
            accuracy: 1,
            crit: 0,
            amt: 2,
            amtBP: 2,
            status: {
                windup: {
                    name: 'windup',
                    length: 1
                },
                chitinous: {
                    name: 'chitinous',
                    length: 1
                },
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },
                cursed: {
                    name: 'cursed',
                    length: 2
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
            let allyTeam = user.team.name
            let enemyTeam = user.enemyTeam.name
            if(user.sprite) user.sprite.classList.add("basic-attack") 

            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                extraDelay: 200,
                endCallback: () => {
                    if(user.sprite) user.sprite.classList.remove("basic-attack")
                    readoutAdd({
                        message: `${user.name} stays wound up!`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: true,
                        forceMini: true,
                        sfx: false
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
                exec: (actor, i) => {
                    if(actor.slug == user.slug) return;

                    switch(actor.team.name) {
                        case allyTeam:
                            env.GENERIC_ACTIONS.singleTarget({
                                beneficial: true,
                                type: 'barrier',
                                action, 
                                user, 
                                target: actor,
                                canCrit: false,
                                hitSfx: {
                                    name: 'mend',
                                    rate: 2
                                },
                                hitStatus: {
                                    name: 'chitinous',
                                    length: 1
                                },
                            })
                        break

                        case enemyTeam:
                            env.GENERIC_ACTIONS.singleTarget({
                                action: this, 
                                user, 
                                target: actor,
                                hitSfx: {
                                    name: 'talksignal',
                                    rate: 1
                                },
                                canCrit: false,
                                hitExec: (target) => {
                                    addStatus({origin: user, target: actor, status: "vulnerable", length: 2}); 
                                    addStatus({origin: user, target: actor, status: "cursed", length: 2}); 
                                }
                            })                            
                        break
                    }
                }
            })
        }
    },
	
	env.ACTIONS.special_judgement_angel = {
        slug: "special_judgement_angel",
        name: "Continuous Suppression",
        type: 'special',
        anim: "",
        details: {
            flavor: "'utilize thoughtspace influence to empower massive strike'",
            onUse: `'[STATUS::windup]';'HIT all foes'`,
            onHit: `'[STAT::amt]'`,
            onCrit: `'[STATUS::stun] [STATUS::fear]'`
        },
        usage: {
            act: "%USER DRAWS THE THOUGHTSPACE AS A WEAPON"
        },
        stats: {
            accuracy: 1,
            crit: 0.3,
            amt: 3,
            status: {
                windup: {
                    name: 'windup',
                    length: 2
                },
                stun: {
                    name: 'stun',
                    length: 1
                },
                fear: {
                    name: 'fear',
                    length: 2
                }, 
            }
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
            if(user.sprite) user.sprite.classList.add("basic-attack")

            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                extraDelay: 400,
                endCallback: () => {
                    if(user.sprite) user.sprite.classList.remove("basic-attack")
                    readoutAdd({
                            message: `${user.name} stays wound up!`, 
                            name: "sourceless", 
                            type: "sourceless combat minordetail", 
                            show: true,
                            forceMini: true,
                            sfx: false
                        })
                    },
                exec: (actor, i) => {
                    if(actor.slug == user.slug) return
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'dull',
                            rate: 1
                        },
                        hitExec: ({target})=>{
                            addStatus({target, origin: user, status: "stun", length: 1})
                            addStatus({target, origin: user, status: "fear", length: 2})
                        }                
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.special_corruskivi_all = {
        slug: "special_corruskivi_all",
        name: "Continuous Siphon",
        type: 'special',
        anim: "basic-attack",
        usage: {
            act: "%USER CLAWS AT THEIR FOES",
        },
        details: {
            flavor: `'attack with repair tool';'siphon vital corru'`,
			onUse: "'HIT all foes'",
            onHit: `'[STAT::amt]'`,
            onCrit: `'heal nearby allies for [STAT::healHP] [STATUS::regen]'`,
        },
        stats: {
            accuracy: 1, 
            crit: 0.3,
            amt: 1,
            healHP: -1,
            status: {
                regen: {
                    name: 'regen',
                    length: 1
                }
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup")
			let action = this
			return env.GENERIC_ACTIONS.teamWave({
				team: user.enemyTeam,
				exec: (actor, i)=>{
					env.GENERIC_ACTIONS.singleTarget({
						action, 
						user, 
						target,
						hitSfx: {
							name: 'stab',
							rate: 1.5
						},
						critExec: ()=> {
							env.GENERIC_ACTIONS.teamWave({
								team: user.team,
								exec: (actor, i)=>{
									combatHit(actor, {amt: -1, origin: user, autohit: true, beneficial: true});
									addStatus({target: actor, origin: user, status: "regen", length: this.stats.status.regen.length});
									play('mend')
								}
							})
						}
				   })
				}
			})
        }
    },
	
	env.ACTIONS.special_parasite_all = {
        slug: "special_parasite_all",
        name: "Continuous Parasitism",
        type: 'special',
        anim: "basic-attack",
        usage: {
            act: "%USER GRASPS AT THEIR FOES",
        },
        details: {
            flavor: `'attack with modified repair tool';'tap vital corru of foes to sustain allies`,
			onUse: "'HIT all foes'",
            onHit: `'[STAT::amt] [STATUS::siphon]'`,
            onCrit: `'infest opposing team with [STATUS::siphon]'`,
        },
        stats: {
            accuracy: 1, 
            crit: 0.4,
            amt: 2,
            healHP: -1,
            status: {
                regen: {
                    name: 'regen',
                    length: 2
                }
            },
        },
        exec: function(user, target, beingUsedAsync) {
			removeStatus(user, "windup")
			let action = this
			return env.GENERIC_ACTIONS.teamWave({
				team: user.enemyTeam,
				exec: (actor, i)=>{
					env.GENERIC_ACTIONS.singleTarget({
						action: this, 
						user, 
						target,
						hitSfx: {
							name: 'stab',
							rate: 0.75
						},
						hitExec: ({target}) => {
							addStatus({
								target, 
								origin: user, 
								status: this.stats.status.siphon.name, 
								length: this.stats.status.siphon.length
							})
						},
						critExec: () => env.GENERIC_ACTIONS.teamWave({
							team: user.enemyTeam,
							exec: (actor, i) => {
								addStatus({
									target: actor, 
									origin: user, 
									status: this.stats.status.siphon.name, 
									length: this.stats.status.siphon.length
								})
								play('status', 0.75)
							}
						})
					})
				}
			})
        }
    },
	
	env.ACTIONS.calculated_distraction = {
        slug: "calculated_distraction",
        name: "Calculated Distraction",
        verb: "distract",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER FEINTS AND CHARGES %TARGET",
            crit: "%USER'S ALLIES ARE INSPIRED",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET DODGES"
        },
        details: {
            flavor: `'heavy strike with clever feint';'may create distraction'`,
            onHit: `'[STAT::amt]'`,
            onCrit: `'[STATUS::evasion] to nearby allies'`,
            conditional: `<em>VS VULNERABLE::</em>'additional [STAT::amt]'`
        },
        stats: {
            accuracy: 1, 
            crit: 0.4,
            amt: 4,
            status: {
                evasion: {
                    name: 'evasion',
                    length: 3
                },
                vulnerable: { // just for detail reference
                    name: 'vulnerable',
                }
            },
        },
        
        exec: function(user, target) {
            let specialAmt = this.stats.amt + (hasStatus(target, 'vulnerable') ? 4 : 0)
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                specialAmt,
				hitSfx: { name: "hit", rate: 0.8},
                critExec: ()=> {           
                    let targets = user.team.members  
                    if(env?.rpg?.is2D) {
                        // in 2d, this is AOE evasion
                        targets = env.rpg.grid.getAoETargets({
                            tile: user?.piece?.tile, 
                            actor: user,
                            actingOn: "allies",
                            aoeData: {
                                size: this.stats.extraAOE.evasionAura.size,
                                shape: this.stats.extraAOE.evasionAura.shape
                            }
                        })
                    }
                    env.GENERIC_ACTIONS.teamWave({
                        arbitraryActorList: targets,
                        exec: (actor, i)=>{
                            addStatus({target: actor, origin: user, status: "evasion", origin: user, length: 3, noReact: true}); 
                            play('mend', 0.5);
                        }
                    })
                }
            })
        }
    },
	
	env.ACTIONS.special_combo_barrier = {
        slug: "special_combo_barrier",
        name: "Combination Cover",
        type: 'special',
        anim: "cloak-barrier",
        animDuration: 4000,
        autohit: true,
		availableStatuses: ["repairs", "hardened", "chitinous", "cloaked"],
        usage: {
            act: "%USER SHIELDS THEIR ALLIES"
        },
        details: {
            flavor: "'broadly apply ablative protection';'upgraded applicators provide two types of protection per use'",
            onUse: `'[STAT::amtBP] [STATUS::repairs] to nearby allies'`,
        },
        stats: {
            crit: 0,
            amtBP: 2,
            amt: 2,
            status: { 
                repairs: {
                    name: 'repairs', 
                    length: 1
                },
				hardened: {
                    name: 'hardened', 
                    length: 1
                },
				chitinous: {
                    name: 'chitinous', 
                    length: 1
                },
				cloaked: {
                    name: 'cloaked', 
                    length: 1
                }
            } 
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this

            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        beneficial: true,
                        type: 'barrier',
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'mend',
                            rate: 2
                        },
                        hitExec: ({target})=> {
							let status1 = this.availableStatuses.sample()
							let status2 = this.availableStatuses.sample()
							addStatus({target: actor, status: status1, length: 1, noReact: true});
							addStatus({target: actor, status: status2, length: 1, noReact: true});
						},
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.blink_guard_all = {
        slug: "blink_guard_all",
        name: "Martyr",
        type: 'special',
        anim: "heal",
        usage: {
            act: "%USER STANDS BEFORE THEIR FOES"
        },
        details: {
            flavor: "'intercept all attacks on allies';'prepare to take great damage'",
            onUse: `'[STATUS::evasion_mega]';'[STATUS::redirection] to all allies'`,
        },
        stats: {
            status: {
                redirection: {
                    name: 'redirection',
                    length: 2
                },
                evasion_mega: {
                    name: 'evasion_mega',
                    length: 3
                }
            },
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            reactDialogue(user, `give_redirection`)
            addStatus({target: user, status: "evasion_mega", length: 3, noReact: true}); 
            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
                    if(actor.slug == user.slug) return
                    addStatus({target: actor, origin: user, status: "redirection", length: 2}); 
                    play('guard', 2, 0.75);
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.special_rule_angelGreater = {
        slug: "special_rule_angelGreater",
        name: "Greater Reinforcement",
        type: 'special',
        anim: "",
        usage: {
            act: "%USER UPENDS THE BALANCE"
        },
        details: {
            flavor: "'utilize status control to defend team';'afflict opponents with vulnerability and inaccuracy'",
            conditional: "<em>SELF::</em>[STATUS::windup]\n<em>ALLIES::</em>[STAT::amtBP] [STATUS::repairs] [STATUS::empowered]\n<em>FOES::</em>[STAT::amt] [STATUS::vulnerable] [STATUS::critical_flaw]",
        },
        stats: {
            accuracy: 1,
            crit: 0,
            amt: 3,
            amtBP: 3,
            status: {
                winderup: {
                    name: 'winderup',
                    length: 1
                },
                chitinous: {
                    name: 'chitinous',
                    length: 1
                },
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },
                cursed: {
                    name: 'cursed',
                    length: 2
                },
				weakened: {
                    name: 'cursed',
                    length: 2
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
            let allyTeam = user.team.name
            let enemyTeam = user.enemyTeam.name
            if(user.sprite) user.sprite.classList.add("basic-attack") 

            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                extraDelay: 200,
                endCallback: () => {
                    if(user.sprite) user.sprite.classList.remove("basic-attack")
                    readoutAdd({
                        message: `${user.name} stays wound up!`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: true,
                        forceMini: true,
                        sfx: false
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
                exec: (actor, i) => {
                    if(actor.slug == user.slug) return;

                    switch(actor.team.name) {
                        case allyTeam:
                            env.GENERIC_ACTIONS.singleTarget({
                                beneficial: true,
                                type: 'barrier',
                                action, 
                                user, 
                                target: actor,
                                canCrit: false,
                                hitSfx: {
                                    name: 'mend',
                                    rate: 1.5
                                },
                                hitExec: (target) => {
                                    addStatus({origin: user, target: actor, status: "chitinous", length: 2}); 
                                    addStatus({origin: user, target: actor, status: "cloaked", length: 2}); 
                                }
                            })
                        break

                        case enemyTeam:
                            env.GENERIC_ACTIONS.singleTarget({
                                action: this, 
                                user, 
                                target: actor,
                                hitSfx: {
                                    name: 'talksignal',
                                    rate: 0.75
                                },
                                canCrit: false,
                                hitExec: (target) => {
                                    addStatus({origin: user, target: actor, status: "vulnerable", length: 2}); 
                                    addStatus({origin: user, target: actor, status: "cursed", length: 2}); 
									addStatus({origin: user, target: actor, status: "weakened", length: 2}); 
                                }
                            })
                        break
                    }
                }
            })
        }
    },
	
	env.ACTIONS.special_judgement_angelGreater = {
        slug: "special_judgement_angelGreater",
        name: "Greater Suppression",
        type: 'special',
        anim: "",
        details: {
            flavor: "'utilize thoughtspace influence to empower massive strike'",
            onUse: `'[STATUS::winderup]';'HIT all foes'`,
            onHit: `'[STAT::amt]'`,
            onCrit: `'[STATUS::stun] [STATUS::fear] [STATUS::open_wound]'`
        },
        usage: {
            act: "%USER DRAWS THE THOUGHTSPACE AS A WEAPON"
        },
        stats: {
            accuracy: 1,
            crit: 0.4,
            amt: 4,
            status: {
                winderup: {
                    name: 'winderup',
                    length: 1
                },
                stun: {
                    name: 'stun',
                    length: 1
                },
                fear: {
                    name: 'fear',
                    length: 2
                }, 
				open_wound: {
                    name: 'open_wound',
                    length: 2
                }, 
            }
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
            if(user.sprite) user.sprite.classList.add("basic-attack")

            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                extraDelay: 400,
                endCallback: () => {
                    if(user.sprite) user.sprite.classList.remove("basic-attack")
                    readoutAdd({
                            message: `${user.name} stays wound up!`, 
                            name: "sourceless", 
                            type: "sourceless combat minordetail", 
                            show: true,
                            forceMini: true,
                            sfx: false
                        })
                    },
                exec: (actor, i) => {
                    if(actor.slug == user.slug) return
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'dull',
                            rate: 1
                        },
                        hitExec: ({target})=>{
                            addStatus({target, origin: user, status: "stun", length: 1})
                            addStatus({target, origin: user, status: "fear", length: 2})
							addStatus({target, origin: user, status: "open_wound", length: 2})
                        }                
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.special_dullfriendsummon = {
        slug: "special_dullfriendsummon",
        name: "Dull Contrivance",
        type: 'special+summon',
        anim: "heal",
        details: {
            flavor: `'collect additional allies from elsewhere'`,
            conditional: `<em>SUMMON::</em>'summon 2 dull golems (max:7)'`
        },
		usage: {
            act: "USER CONJURES DULLFRIENDS VIA THE DULL"
        },
        noRepeat: true,
        exec: function(user, target) {
            play('dull', 0.5, 1);
            
            //try to center the dude
            if(user.team.members.length == 8) {
                let uI = user.team.members.findIndex(a => a.slug == user.slug)
                if(uI < 5) midCombatActorAdd(env.rpg.enemyTeam, 'dull_golem', 'left')
                else if(uI >= 5) midCombatActorAdd(env.rpg.enemyTeam, 'dull_golem', 'right')
            } else {
                midCombatActorAdd(env.rpg.enemyTeam, 'dull_golem', 'left')
                midCombatActorAdd(env.rpg.enemyTeam, 'dull_golem', 'right')
            }

            setTimeout(()=>advanceTurn(user), 1000)
        },
        disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('dull_golem')).length > 6) return "TOO MANY ALLIES" }
    },
	
	env.ACTIONS.special_dullfriendbuff = {
        slug: "special_dullfriendbuff",
        name: "Dull Ceremony",
        type: 'special',
        desc: "'",
        help: "ALLIES::+1T:DESTABILIZED, +1T:FOCUSED",
        anim: "basic-attack",
        usage: {
            act: "%USER FLOODS THE THOUGHTSPACE WITH DULL LIGHT"
        },
        details: {
            flavor: `'destabilize allies via dull exposure';'attain direct control and energize attacks'`,
            onUse: `'[STATUS::destabilized] [STATUS::surge] to all allies'`,
        },
        stats: {
            autohit: true,
            status: {
                destabilized: {name: "destabilized", length: 1},
                surge: {name: "surge", length: 1},
            }
        },
        exec: function(user, target, beingUsedAsync) {
            playCombatCrit('dull', 0.5, 1);
            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
                    addStatus({target: actor, origin: user, status: "destabilized", length: 1, noReact: true}); 
                    addStatus({target: actor, origin: user, status: "surge", length: 1, noReact: true}); 
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        },
        disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('dull_golem')).length <= 6) return "NOT ENOUGH ALLIES" }
    },

	// dull actions
env.ACTIONS.ik_attack_weak = {
    slug: "ik_attack_weak",
    name: "Dull Blade",
    type: 'target',
    anim: "basic-attack",
    usage: {
        act: "%USER SWINGS AT %TARGET",
        crit: "%TARGET IS IRRADIATED",
        hit: "%TARGET IS HIT",
        miss: "%TARGET EVADES"
    },
	details: {
            flavor: "'utilize dull-enhanced cutting blade';'obliterate destabilized foes'",
			onHit: `'[STAT::amt]'`,
            onCrit: `'[STATUS::vulnerable]'`,
            conditional: `<em>VS DESTABILIZED::</em>'additional [STAT::amt]';'+[STAT::hitBonus]HIT';'+[STAT::critBonus]CRIT';''[STATUS::weakened] on HIT'';'[STATUS::stun] on CRIT'`,
        },
	stats: {
		accuracy: 0.8,
		crit: 0.2,
		critBonus: 0.3,
		hitBonus: 0.1,
		amt: 2,
		status: {
			vulnerable: {
				name: 'vulnerable',
				length: 2
			},
			weakened: {
				name: 'weakened',
				length: 2
			},
			stun: {
				name: 'stun',
				length: 1
			},
		}
	},
    exec: function(user, target) {
        let amt = this.stats.amt
		let crit = this.stats.crit
		let acc = this.stats.accuracy

        if(hasStatus(target, "destabilized")) {
            amt = this.stats.amt + 2
			crit = this.stats.crit + 0.3
			acc = this.stats.accuracy + 0.1
        }
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'dull',
                rate: 1.0
            },
            critSfx: {
                name: 'dull',
                rate: 0.6
            },
			critStatus: {
				name: 'vulnerable',
				length: 2
			},
			hitExec: ()=>{
				if(hasStatus(target, "destabilized")) {
					addStatus({target, origin: user, status: "weakened", length: 2, noReact: true}); 
				}
			},
			critExec: ()=>{
				if(hasStatus(target, "destabilized")) {
					addStatus({target, origin: user, status: "stun", length: 1, noReact: true}); 
				}
			}
        })
    }
}

env.ACTIONS.dullflare_weak = {
    slug: "dullflare_weak",
    name: "Dull Salvo",
    type: 'special',
    anim: "basic-attack",
	details: {
		flavor: "'utilize dull pulse weapon';'leave targets open to greater attacks'",
		onUse: "'ATTACK all foes'",
		onHit: `'[STAT::amt]'`,
		onCrit: `'inflict one of following';'[STATUS::vulnerable]';'[STATUS::destabilized]';'[STATUS::weakened]'`,
	},
	stats: {
		accuracy: 0.5,
		crit: 0.15,
		amt: 1,
		status: {
			vulnerable: {
				name: 'vulnerable',
				length: 2
			},
			destabilized: {
				name: 'destabilized',
				length: 2
			},
			weakened: {
				name: 'weakened',
				length: 1
			},
		}
	},
    usage: {
        act: "%USER FIRES RAPID DULL PULSES"
    },
    exec: function(user, target, beingUsedAsync) {
        let action = this
        env.GENERIC_ACTIONS.teamWave({
            team: user.enemyTeam,
            exec: (actor, i) => {
                let anim = env.COMBAT_ANIMS.flare
                let baseDelay = ((env.ADVANCE_RATE * 0.066) * i)
                let animDelay = baseDelay + anim.duration;
                    
                setTimeout(()=>anim.exec(action, user, actor), baseDelay)
                setTimeout(function(){
                    env.GENERIC_ACTIONS.singleTarget({
                        beneficial: true,
                        action: action, 
                        user, 
                        target: actor,
                        hitSfx: { name: 'dull', rate: 2.0 },
                        critSfx: { name: 'shot6', rate: 1.25 },
                        critExec: ({target})=> {
							let rand = Math.random()
							if(rand < 0.3) {
								addStatus({target, origin: user, status: "destabilized", origin: user, length: 2}); 
								
							} else if(rand < 0.6) {
								addStatus({target, origin: user, status: "vulnerable", origin: user, length: 2}); 

							} else {
								addStatus({target, origin: user, status: "weakened", origin: user, length: 1}); 
							}
						}
                    })
                }, animDelay);
            },
            advanceAfterExec: true, beingUsedAsync, user,
        })
    }
}

env.ACTIONS.ik_attack_player = {
    slug: "ik_attack_player",
    name: "Veilksplitter",
    verb: "veilksplit",
    type: 'target',
    anim: "basic-attack",
    usage: {
        act: "%USER BLASTS %TARGET",
        crit: "%TARGET IS ANNIHILATED",
        hit: "%TARGET IS SEARED",
        miss: "%TARGET EVADES"
    },
	details: {
		flavor: "'utilize dull-enabled cutting beam';'immense physical trauma'",
		onHit: `'[STAT::amt] [STATUS::stun]'`,
		onCrit: `[STATUS::stun], [STATUS::vulnerable], [STATUS::puncture], [STATUS::open_wound], [STATUS::weakened]`,
		conditional: "<em>VS DESTABILIZED::</em>'additional [STAT::amt]';'+[STAT::critBonus]CRIT'",
	},
	stats: { 
		autohit: true, 
		crit: 0.05,
		amt: 4,
		bonusCrit: 0.1,
		status: {
			stun: {
				name: 'stun',
				length: 1
			},
			vulnerable: {
				name: 'vulnerable',
				length: 3
			},
			puncture: {
				name: 'puncture',
				length: 3
			},
			open_wound: {
				name: 'open_wound',
				length: 3
			},
			weakened: {
				name: 'weakened',
				length: 3
			},
		}
	},
    exec: function(user, target) {
        let amt = this.amt
		let crit = this.crit

        if(hasStatus(target, "destabilized")) {
            amt = this.amt + 4
			crit = this.crit + 0.1
        }
        removeStatus(user, "windup")
        return env.GENERIC_ACTIONS.singleTarget({
            action: this, 
            user, 
            target,
            hitSfx: {
                name: 'dull',
                rate: 0.5,
            },
            critSfx: {
                name: 'stab',
                rate: 0.4,
            },
            genExec: ({target}) => {
                addStatus({target, status: "stun", length: 1});
            },
            critExec: ({target}) => {
                addStatus({target, status: "stun", length: 1});
                addStatus({target, status: "vulnerable", length: 3});
                addStatus({target, status: "puncture", length: 3});
                addStatus({target, status: "open_wound", length: 3});
                addStatus({target, status: "weakened", length: 3});
            },
        })
    }
}

env.ACTIONS.dullflare_player = {
    slug: "dullflare_player",
    name: "Dull Flare",
    type: 'special',
    desc: "'wide directional release of rapidly decaying dull light';'deconstructs foes'",
    help: "FOES::AUTOHIT -3HP 10%C x2 + ONE OF (+3T:VULNERABLE, +2T:OPEN WOUND, +1T:STUN)",
    anim: "basic-attack",
	details: {
		flavor: "'utilize dull pulse weapon';'leave targets open to greater attacks'",
		onUse: "'HIT all foes'",
		onHit: `'[STAT::amt]'`,
		onCrit: `'inflict one of following';'[STATUS::vulnerable]';'[STATUS::open_wound]';'[STATUS::stun]'`,
	},
	stats: {
		autohit: true,
		crit: 0.1,
		amt: 3,
		status: {
			vulnerable: {
				name: 'vulnerable',
				length: 3
			},
			open_wound: {
				name: 'open_wound',
				length: 2
			},
			stun: {
				name: 'stun',
				length: 1
			},
		}
	},
    usage: {
        act: "%USER TEARS OPEN THE DULL"
    },
    exec: function(user, target, beingUsedAsync) {
        removeStatus(user, "windup")
        let action = this
        env.GENERIC_ACTIONS.teamWave({
            team: user.enemyTeam,
            exec: (actor, i) => {
                let anim = env.COMBAT_ANIMS.flare
                let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
                let animDelay = baseDelay + anim.duration;
                    
                setTimeout(()=>anim.exec(action, user, actor), baseDelay)
                setTimeout(function(){
                    env.GENERIC_ACTIONS.singleTarget({
                        beneficial: true,
                        action: action, 
                        user, 
                        target: actor,
                        hitSfx: { name: 'dull', rate: 1.5 },
                        critSfx: { name: 'shot6', rate: 0.75 },
                        critExec: ({target})=> {
							let rand = Math.random()
							if(rand < 0.4) {
								addStatus({target, origin: user, status: "vulnerable", origin: user, length: 3}); 
								
							} else if(rand < 0.7) {
								addStatus({target, origin: user, status: "open_wound", origin: user, length: 2}); 

							} else {
								addStatus({target, origin: user, status: "stun", origin: user, length: 1}); 
							}
						}
                    })
                }, animDelay);
            },
            advanceAfterExec: true, beingUsedAsync, user,
        })
    }
}

env.ACTIONS.special_player_dullsummon = {
    slug: "special_player_dullsummon",
    name: "Dull Portal",
    type: 'special+summon+nomimic',
    desc: "'collect additional allies from elsewhere'",
    help: "SUMMON::2 DULL CONTAINER (MAX: 6 SUMMONS)",
    anim: "heal",
	itemAction: true, //we have to lie here so that imps can't use this action
	details: {
		flavor: "'collect additional allies from elsewhere'",
		conditional: "<em>SUMMON::</em>'summon 2 warped containers (max:6 containers)'"
	},
    exec: function(user, target) {
		if(user.team.members.filter(m=>m.slug.includes('dull_')).length > 6) {
			useAction(user, env.ACTIONS['special_player_dullbuff'], user, {beingUsedAsync: true, reason: "overload"})
		} else {
			actionMessage(user, "%USER CONJURES CONTAINERS VIA THE DULL", target, 'none', 2000);
			play('dull', 0.8, 1);
			
			if(user.team.members.filter(m=>m.slug.includes('falsecritta')).length > 0) {
					{
					midCombatEnemyAdd('dull_container', 'left')
					midCombatEnemyAdd('dull_container', 'right')
				}

				setTimeout(()=>advanceTurn(user), 1000)
			}
			else
			//try to center the dude
			if(user.team.members.length == 8) {
				let uI = user.team.members.findIndex(a => a.slug == user.slug)
				if(uI < 7) midCombatAllyAdd('player_dull_container', 'left')
				else if(uI >= 7) midCombatAllyAdd('player_dull_container', 'right')
			} else {
				midCombatAllyAdd('player_dull_container', 'left')
				midCombatAllyAdd('player_dull_container', 'right')
			}

			setTimeout(()=>advanceTurn(user), 1000)
		}
    },
    disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('dull_')).length > 6) return "TOO MANY ALLIES" }
}

env.ACTIONS.special_player_dullbuff = {
    slug: "special_player_dullbuff",
    name: "Dull Overload",
    type: 'special',
    anim: "basic-attack",
	details: {
		flavor: "'destabilize allies via dull exposure';'attain direct control and focus attack'",
		onUse: "'[STATUS::destabilized] [STATUS::focused] to all allies'",
	},
	stats: {
		autohit: true,
		status: {
			destabilized: {name: "destabilized", length: 1},
			focused: {name: "focused", length: 1},
		}
	},
    usage: {
        act: "%USER FLOODS THEIR ALLIES WITH DULL RADIATION"
    },
    exec: function(user, target, beingUsedAsync) {
        play('dull', 0.75, 1);
        env.GENERIC_ACTIONS.teamWave({
            team: user.team,
            exec: (actor, i) => {
                addStatus({target: actor, origin: user, status: "destabilized", length: 1, noReact: true}); 
                addStatus({target: actor, origin: user, status: "focused", length: 1, noReact: true}); 
            },
            advanceAfterExec: true, beingUsedAsync, user
        })
    },
    disableIf: (actor) => {
		if(actor.team.members.filter(m=>m.slug.includes('dull_')).length < 6) return "REQUIRES MORE ALLIES"
		if(hasStatus(actor,"fear")) return "PROHIBITED BY FEAR" 
	}
}

env.ACTIONS.special_player_dullbuff_aug = {
    slug: "special_player_dullbuff_aug",
    name: "Dull Overload",
    type: 'special',
    desc: "'destabilize allies via dull exposure';'attain direct control and focus attack'",
    help: "ALLIES::+1T:DESTABILIZED, +1T:FOCUSED",
    anim: "basic-attack",
	details: {
		flavor: "'destabilize allies via dull exposure';'attain direct control and focus attack'",
		onUse: "'[STATUS::destabilized] [STATUS::focused] [STATUS::surge] to all allies'",
	},
	stats: {
		autohit: true,
		status: {
			destabilized: {name: "destabilized", length: 1},
			focused: {name: "focused", length: 1},
			surge: {name: "surge", length: 1},
		}
	},
    usage: {
        act: "%USER FLOODS THEIR ALLIES WITH DULL RADIATION"
    },
    exec: function(user, target, beingUsedAsync) {
        play('dull', 0.75, 1);
        env.GENERIC_ACTIONS.teamWave({
            team: user.team,
            exec: (actor, i) => {
                addStatus({target: actor, origin: user, status: "destabilized", length: 1, noReact: true}); 
                addStatus({target: actor, origin: user, status: "focused", length: 1, noReact: true}); 
            },
            advanceAfterExec: true, beingUsedAsync, user,
        })
    },
    disableIf: (actor) => {
		if(actor.team.members.filter(m=>m.slug.includes('dull_')).length < 12) return "REQUIRES MORE ALLIES"
		if(hasStatus(actor,"fear")) return "PROHIBITED BY FEAR" 
	}
}

env.ACTIONS.special_player_dullsummon_low = {
    slug: "special_player_dullsummon_low",
    name: "Dull Portal::LOW",
    type: 'special+summon+nomimic',
    desc: "'collect additional allies from elsewhere';'expose self to dull radiation'",
    help: "SUMMON::4 DULL CONTAINERS (MAX: 12 SUMMONS)\nSELF::+2T:DESTABILIZED +1T:VULNERABLE",
    anim: "heal",
    accuracy: 1,
    crit: 0,
	itemAction: true, //we have to lie here so that imps can't use this action
    exec: function(user, target) {
		if(user.team.members.filter(m=>m.slug.includes('dull_')).length > 12) {
			useAction(user, env.ACTIONS['special_player_dullbuff_aug'], user, {beingUsedAsync: true, reason: "overload"})
		} else {
			actionMessage(user, "%USER CONJURES A SWARM OF CONTAINERS VIA THE DULL", target, 'none', 2000);
			play('dull', 0.8, 1);
			addStatus({target: user, status: "destabilized", length: 2});
			addStatus({target: user, status: "vulnerable", length: 1});
			
			//try to center the dude
			if(user.team.members.length == 14) {
				let uI = user.team.members.findIndex(a => a.slug == user.slug)
				if(uI < 3) midCombatAllyAdd('player_dull_container', 'left')
				else if(uI >= 3) midCombatAllyAdd('player_dull_container', 'right')
			} else {
				midCombatAllyAdd('player_dull_container', 'left')
				midCombatAllyAdd('player_dull_container', 'left')
				midCombatAllyAdd('player_dull_container', 'right')
				midCombatAllyAdd('player_dull_container', 'right')
			}

			setTimeout(()=>advanceTurn(user), 1000)
		}
    },
    disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('dull_')).length > 12) return "TOO MANY ALLIES" }
}

env.ACTIONS.special_player_dullsummon_medium = {
    slug: "special_player_dullsummon_medium",
    name: "Dull Portal::MEDIUM",
    type: 'special+summon+nomimic',
    desc: "'collect additional allies from elsewhere';'expose self to dull radiation'",
    help: "SUMMON::2 COLLAPSE FOES AS WARPED ALLIES (MAX: 12 SUMMONS)\nSELF::+3T:DESTABILIZED +2T:VULNERABLE +1T:WEAKENED",
    anim: "heal",
    accuracy: 1,
    crit: 0,
	itemAction: true, //we have to lie here so that imps can't use this action
    exec: function(user, target) {
		if(user.team.members.filter(m=>m.slug.includes('dull_')).length > 12) {
			useAction(user, env.ACTIONS['special_player_dullbuff_aug'], user, {beingUsedAsync: true, reason: "overload"})
		} else {
			actionMessage(user, "%USER CONJURES WARPED ALLIES VIA THE DULL", target, 'none', 2000);
			play('dull', 0.7, 1);
			addStatus({target: user, status: "destabilized", length: 3});
			addStatus({target: user, status: "vulnerable", length: 2});
			addStatus({target: user, status: "weakened", length: 1});

			let collapse_peasant = ['player_dull_container','player_dull_attendant','player_dull_veilklight','player_dull_attendant']
			let collapse_royal = ['player_dull_maintcloak','player_dull_maintcloak','player_dull_maintcloak','player_dull_archival_golem','player_dull_archival_golem']
			
			var newAllySlug = collapse_peasant.sample()
			var newAllySlug1 = collapse_royal.sample()

			//try to center the dude
			if(user.team.members.length == 14) {
				let uI = user.team.members.findIndex(a => a.slug == user.slug)
				if(uI < 3) midCombatAllyAdd('player_dull_attendant', 'left')
				else if(uI >= 3) midCombatAllyAdd('player_dull_attendant', 'right')
			} else {
				let rand = Math.random()
				if (rand < 0.75) {
					midCombatAllyAdd(newAllySlug,'left')
				} 
				else if (rand >= 0.25) {
					midCombatAllyAdd(newAllySlug1,'left')	
				}
				let rand1 = Math.random()
				if (rand1 < 0.75) {
					midCombatAllyAdd(newAllySlug,'right')
				} 
				else if (rand1 >= 0.25) {
					midCombatAllyAdd(newAllySlug1,'right')
				}
			}
			setTimeout(()=>advanceTurn(user), 1000)
		}
    },
    disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('dull_')).length > 12) return "TOO MANY ALLIES" }
}

env.ACTIONS.special_player_dullsummon_high = {
    slug: "special_player_dullsummon_high",
    name: "Dull Portal::HIGH",
    type: 'special+summon+nomimic',
    desc: "'collect additional allies from elsewhere';'expose self to dull radiation'",
    help: "SUMMON::1 GOLEM MAINTANENCE FOE AS A WARPED ALLY (MAX: 12 SUMMONS)\nSELF::+4T:DESTABILIZED +3T:VULNERABLE +2T:WEAKENED +1T:OPEN WOUND",
    anim: "heal",
    accuracy: 1,
    crit: 0,
	itemAction: true, //we have to lie here so that imps can't use this action
    exec: function(user, target) {
		if(user.team.members.filter(m=>m.slug.includes('dull_')).length > 12) {
			useAction(user, env.ACTIONS['special_player_dullbuff_aug'], user, {beingUsedAsync: true, reason: "overload"})
		} else {
			actionMessage(user, "%USER CONJURES A WARPED ALLY VIA THE DULL", target, 'none', 2000);
			play('dull', 0.6, 1);
			addStatus({target: user, status: "destabilized", length: 4});
			addStatus({target: user, status: "vulnerable", length: 3});
			addStatus({target: user, status: "weakened", length: 2});
			addStatus({target: user, status: "open_wound", length: 1});

			let golem_peasant = ['player_dull_basic_golem','player_dull_basic_golem','player_dull_husk','player_dull_surgeon_golem','player_dull_pressure_golem']
			let golem_royal = ['player_dull_surgeon_golem','player_dull_surgeon_golem','player_dull_surgeon_golem','player_dull_constructor_golem','player_dull_constructor_golem','player_dull_dullfriend']
			
			var newAllySlug = golem_peasant.sample()
			var newAllySlug1 = golem_royal.sample()

			//try to center the dude
			if(user.team.members.length == 14) {
				let uI = user.team.members.findIndex(a => a.slug == user.slug)
				if(uI < 3) midCombatAllyAdd('player_dull_husk', 'left')
				else if(uI >= 3) midCombatAllyAdd('player_dull_husk', 'right')
			} else {
				let rand2 = Math.random()
				if (rand2 > 0.5) 
				{
					let rand = Math.random()
					if (rand < 0.75) {
						midCombatAllyAdd(newAllySlug,'left')
					} 
					else if (rand >= 0.25) {
						midCombatAllyAdd(newAllySlug1,'left')	
					}
				}
				else
				{
					let rand1 = Math.random()
					if (rand1 < 0.75) {
						midCombatAllyAdd(newAllySlug,'right')
					} 
					else if (rand1 >= 0.25) {
						midCombatAllyAdd(newAllySlug1,'right')
					}
				}
			}
			setTimeout(()=>advanceTurn(user), 1000)
		}
    },
    disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('dull_')).length > 12) return "TOO MANY ALLIES" }
}

env.ACTIONS.special_player_dullsummon_special = {
    slug: "special_player_dullsummon_special",
    name: "Dull Portal::SPECIAL",
    type: 'special+summon+nomimic',
    desc: "'attempt to collect great ally from elsewhere';'expose self to dull radiation on success'",
    help: "25% SUMMON::1 BOSS OR OTHERWISE SPECIAL FOE AS AN ALLY (MAX: 12 SUMMONS)\nSELF:: ON SUCCESS, +5T:DESTABILIZED +4T:VULNERABLE +3T:WEAKENED +2T:OPEN WOUND +1T:STUN\nNOTICE::UNAFFECTED BY FOCUSED",
    anim: "heal",
    accuracy: 1,
    crit: 0,
	itemAction: true, //we have to lie here so that imps can't use this action
    exec: function(user, target) {
        let chance = Math.random()
		let fated = user.statusEffects.find(status => status.slug == "fated_dull")
		if(user.team.members.filter(m=>m.slug.includes('dull_')).length > 12) {
			useAction(user, env.ACTIONS['special_player_dullbuff_aug'], user, {beingUsedAsync: true, reason: "overload"}) // this looks horrid
		} else if(chance < (0.75 - (fated ? fated.power * 0.05 : 0))) {
            actionMessage(user, "%USER CAN'T KEEP THE PORTAL OPEN", target, 'none', 2000);
            play('criticalError', 1.1, 1.3)
        } else {
            actionMessage(user, "%USER CONJURES A POWERFUL ALLY VIA THE DULL", target, 'none', 2000);
            play('dull', 0.5, 0.8);
			addStatus({target: user, status: "destabilized", length: 5});
			addStatus({target: user, status: "vulnerable", length: 4});
			addStatus({target: user, status: "weakened", length: 3});
			addStatus({target: user, status: "open_wound", length: 2});
			addStatus({target: user, status: "stun", length: 1});

            let collapse_divine = ['player_dull_movefriend','player_dull_movefriend','player_dull_movefriend','player_dull_bstrdshelf','player_dull_bstrdshelf','player_dull_bstrdshelf','player_dull_bstrdshelf','player_dull_gungolem','player_dull_gungolem']
            let golem_divine = ['player_dull_translation_core','player_dull_translation_core','player_dull_translation_core','player_dull_kivii','player_dull_kivii','player_dull_golemboss','player_dull_dullzika']
            let special_divine = ['player_dull_critta_pawn','player_dull_bstrdlight','player_dull_critta_pawn','player_dull_bstrdlight','player_dull_critta_pawn','player_dull_bstrdlight','player_dull_critta_knight','player_dull_bstrdlight','player_dull_critta_knight','player_dull_bstrdlight','player_dull_critta_knight','player_dull_bstrdlight','player_dull_critta_bishop','player_dull_bstrdlight','player_dull_critta_bishop','player_dull_bstrdlight','player_dull_critta_bishop','player_dull_bstrdlight','player_dull_critta_rook','player_dull_bstrdlight','player_dull_critta_rook','player_dull_bstrdlight','player_dull_critta_rook','player_dull_bstrdlight','player_dull_critta_queen','player_dull_critta_queen','player_dull_critta_king','player_dull_critta_king','player_dull_critta_spawner']
            
            var newAllySlug = collapse_divine.sample()
            var newAllySlug1 = golem_divine.sample()
            var newAllySlug2 = special_divine.sample()

            //try to center the dude
            if(user.team.members.length == 14) {
                let uI = user.team.members.findIndex(a => a.slug == user.slug)
                if(uI < 3) midCombatAllyAdd('player_dull_bstrdshelf', 'left')
                else if(uI >= 3) midCombatAllyAdd('player_dull_bstrdshelf', 'right')
            } else {
                let rand = Math.random()
                if (rand > 0.5) {
                    let rand1 = Math.random()
                    if (rand1 < 0.5) {
                        midCombatAllyAdd(newAllySlug,'left')
                    } 
                    else if (rand1 < 0.8) {
                        midCombatAllyAdd(newAllySlug1,'left')	
                    }
                    else {
                        midCombatAllyAdd(newAllySlug2,'left')	
                    }
                }
                else {
                    let rand2 = Math.random()
                    if (rand2 < 0.5) {
                        midCombatAllyAdd(newAllySlug,'right')
                    } 
                    else if (rand2 < 0.8) {
                        midCombatAllyAdd(newAllySlug1,'right')
                    }
                    else {
                        midCombatAllyAdd(newAllySlug2,'right')
                    }
                }
            }
        }
            setTimeout(()=>advanceTurn(user), 1000)
    },
    disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('dull_')).length > 12) return "TOO MANY ALLIES" }
}

env.ACTIONS.dullsummon_failure = {
    slug: "dullsummon_failure",
    name: "Nothing",
    type: 'autohit',
    desc: "'just nothing'",
    anim: "heal",
    help: "NOTHING",
    usage: {
        act: "%USER CAN'T HOLD THE PORTAL OPEN"
    },
    exec: function(user, target) {
        play('criticalError', 1)
        return 'nothing';
    }
}

	env.ACTIONS.special_dullsummon_select = {
        slug: "special_dullsummon_select",
        name: "Dull Contrivance",
        type: 'special+summon+nomimic',
        desc: "'select range of allies to collect';'offer user responsive choice'",
        anim: "wobble",
		itemAction: true,
        help: "CHOOSE:: DULL PORTAL::LOW ::OR:: DULL PORTAL::MEDIUM ::OR:: DULL PORTAL::HIGH ::OR:: DULL PORTAL::SPECIAL",
        usage: {
            act: "%USER CONSIDERS THEIR OPTIONS"
        },
		details: {
            onUse: "'select range of allies to collect';'present user choice of outcome'",
        },
        accuracy: 1,
        crit: 0,
        exec: function(user, target) {
            let action = this

            //summon a div that lets the player click guaranteed or chance <--- we are modifying this to let the player choose between dull portal actions
            actionChoice({
                user: user,
                action: action,
                choiceText: `${user.name} considers their options...`,
                options: [
                    {text: "Dull Portal::LOW", definition: "NOTE::'SUMMON::4 DULL CONTAINERS (MAX: 12 SUMMONS)'\nSELF::'+2T:DESTABILIZED +1T:VULNERABLE'"},
                    {text: "Dull Portal::MEDIUM", definition: "NOTE::'SUMMON::2 COLLAPSE FOES AS WARPED ALLIES (MAX: 12 SUMMONS)'\nSELF::'+3T:DESTABILIZED +2T:VULNERABLE +1T:WEAKENED'"},
					{text: "Dull Portal::HIGH", definition: "NOTE::'SUMMON::1 GOLEM MAINTANENCE FOE AS A WARPED ALLY (MAX: 12 SUMMONS)'\nSELF::'+4T:DESTABILIZED +3T:VULNERABLE +2T:WEAKENED +1T:OPEN WOUND'"},
					{text: "Dull Portal::SPECIAL", definition: "NOTE::'25% SUMMON::1 BOSS OR OTHERWISE SPECIAL FOE AS AN ALLY (MAX: 12 SUMMONS)'\nSELF::'ON SUCCESS, +5T:DESTABILIZED +4T:VULNERABLE +3T:WEAKENED +2T:OPEN WOUND +1T:STUN'\nNOTICE::UNAFFECTED BY FOCUSED"},
                ],
                choiceCallback: (c) => {
                    //reap the consequences
                        
                    var hit //note to self::make c0-c3 use the useAction function to use corresponding dull portal actions <--- why did i say use so many times.....
                    switch(c) {
                        case "c0":
                            hit = useAction(user, env.ACTIONS['special_player_dullsummon_low'], user, {beingUsedAsync: true, reason: "contrivance"})
                            break;
                        case "c1":
                            hit = useAction(user, env.ACTIONS['special_player_dullsummon_medium'], user, {beingUsedAsync: true, reason: "contrivance"})
                            break
						case "c2":
                            hit = useAction(user, env.ACTIONS['special_player_dullsummon_high'], user, {beingUsedAsync: true, reason: "contrivance"})
                            break
						case "c3":
                            hit = useAction(user, env.ACTIONS['special_player_dullsummon_special'], user, {beingUsedAsync: true, reason: "contrivance"})
                            break
                    }

                    setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE);
                }
            })
        },
		disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('dull_')).length > 12) return "TOO MANY ALLIES" }
    },

// spirestone actions
	// spirestone utility default
    env.ACTIONS.evade_empowered = {
        slug: "evade_empowered",
        name: "Juke",
        type: 'autohit',
        anim: "",
        usage: {
            act: "%USER CREATES AN OPENING"
        },
		details: {
            onUse: () => "'gain [STATUS::empowered] [STATUS::evasion]'",
            flavor: "'strategic sidestep to empower next strike'"
        },
		stats: {
            status: {
                evasion: {
                    name: 'evasion',
                    length: 1
                },
                empowered: {
                    name: 'empowered',
                    length: 1
                },                
            }
        },
        exec: function(user, target) {
            play('mend', 0.4);
            addStatus({target: user, status: "evasion", length: 1, noReact: true}); 
            addStatus({target: user, status: "empowered", length: 1, noReact: true}); 
            return 'nothing';
        },

        avoidChaining: true
    },

	// spirestone primary augment
    env.ACTIONS.haymaker = {
        slug: "haymaker",
        name: "Overclocked Strike",
        type: 'target',
        desc: "'deadly attack upon one target';'damage and stun immensely improved by FOCUSED'",
        anim: "basic-attack",
        help: "100% -3HP + (XT:FOCUSED), 40%C -3HP +(XT:FOCUSED) +1T:STUN + (XT:FOCUSED / 2), SELF::-FOCUSED",
        usage: {
            act: "%USER CHARGES %TARGET",
            crit: "%TARGET IS LEFT REELING",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET EVADES"
        },
		details: {
            flavor: "'deadly attack upon one target';'damage and stun immensely improved by FOCUSED'",
            onHit: `'[STAT::amt]'`,
            onCrit: `'[STATUS::stun]'`,
			conditional: "+1 BASE DAMAGE PER TURN OF FOCUSED, ADDITIONAL [STATUS::stun] ON CRIT PER TWO TURNS OF FOCUSED"
        },
        stats: {
            crit: 0.4,
            amt: 3,
            status: {
                stun: {
                    name: 'stun',
                    length: 1
                }
            },
        },
        accuracy: 1,
        crit: 0.4,
        amt: 3,
        exec: function(user, target) {
			let power = Math.floor(hasStatus(user, 'focused') )
			let power2 = 2 * Math.floor(hasStatus(user, 'hyperfocus_flat') )
			let finalPower = power + power2
            removeStatus(user, "windup")
			setTimeout(()=>{
				removeStatus(user, "focused")
			},
				env.ADVANCE_RATE * 0.2)
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'hit',
                    rate: 0.8
                },
                critStatus: {
                    name: 'stun',
                    length: 1 + Math.floor(finalPower / 2)
                },
				hitExec: ({target}) => {
					combatHit(target, {amt: (finalPower), origin: user, autohit: true})
				},
				critExec: ({target}) => {
					combatHit(target, {amt: (finalPower), origin: user, autohit: true})
				}
            })
        }
	},

    env.ACTIONS.spirestone_focused = {
        slug: "spirestone_focused",
        name: "Extra Preparation",
        type: 'autohit',
        anim: "",
        usage: {
            act: "%USER WAITS FOR THE RIGHT MOMENT..."
        },
		details: {
            onUse: `'[STATUS::windup] [STATUS::focused]'`,
            flavor: "'hold prepared attack';'progressively increase power'"
        },
        stats: {
            status: {
                windup: {
                    name: 'windup',
                    length: 1
                },
                focused: {
                    name: 'focused',
                    length: 2
                },
            },
        }, 
		disableIf: (actor)=>{ if(hasStatus(actor,"fear")) return "PROHIBITED BY FEAR" },
        avoidChaining: true,
        exec: function(user, target) {
            play('talklaugh', 0.5);
            addStatus({target: user, status: "windup", length: 1}); 
            addStatus({target: user, status: "focused", length: 2, noReact: true});
            return 'nothing';
        }
    },

	// spirestone secondary augment
    env.ACTIONS.special_hardening_barrier = {
        slug: "special_hardening_barrier",
        name: "Hardening Cover",
        type: 'special',
        desc: "'apply ablative protection';'upgrades protection to passively increase accuracy'",
        help: "ALLIES::+1 BP +HARDENED",
        anim: "cloak-barrier",
        autohit: true,
        usage: {
            act: "%USER SHIELDS THEIR ALLIES"
        },
		details: {
            flavor: "'broadly apply ablative protection';'upgraded barrier increases combat ability while active'",
            onUse: "'[STAT::amtBP] [STATUS::hardened] to nearby allies'",
        },
        stats: {
            crit: 0,
            amtBP: 2,
            amt: 2,
            status: { 
                hardened: {
                    name: 'hardened', 
                    length: 1
                },
            } 
        },
        exec: function(user, target, beingUsedAsync) {
			let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        beneficial: true,
                        type: 'barrier',
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'guard',
                            rate: 2
                        },
                        hitStatus: {
                            name: 'hardened',
                            length: 1
                        },
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },

	// spirestone utility augment
    env.ACTIONS.team_huddle = {
        slug: "team_huddle",
        name: "Team Huddle",
        type: 'self+autohit+support',
        anim: "",
		details: {
            flavor: "'back off';'empower entire team'",
            onUse:` [STATUS::evasion]';'[STATUS::empowered] to all allies'`,
        },
        stats: {
            accuracy: .8,
            crit: 0.4,
            amt: 2,
            status: {
                evasion: {
                    name: 'evasion',
                    length: 1
                },
                empowered: {
                    name: 'empowered',
                    length: 2
                },
            },
        },
        usage: {
            act: "%USER PREPARES THEIR ALLIES TO FIGHT"
        },
        autohit: true,
        exec: function(user, target) {
            play("talkchoir7", 2)
            addStatus({target: user, origin: user, status: "evasion", origin: user, length: 1}); 
            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "empowered", origin: user, length: 2, noReact: true}); 
                    play('mend', 0.4);
                }
            })
            return 'nothing'
        }
    },

	// hands actions
		//hands primary
    env.ACTIONS.ceremonial_weapon = {
        slug: "ceremonial_weapon",
        name: "Corikuva",
        verb: "swing at",
        type: 'target',
        desc: "'utilize ceremonial weaponry';'purported to curse foes'",
        anim: "basic-attack",
        help: "80% -1HP + ONE OF (+3T:PUNCTURE, +2T:CURSED, +2T:VULNERABLE), 20%C x2 + ONE OF (+3T:PUNCTURE, +2T:CURSED, +2T:VULNERABLE, +1T:STUN)",
        usage: {
            act: "%USER SWINGS AT %TARGET",
            crit: "A FRIGHTENING BLOW",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET EVADES"
        },
		details: {
            flavor: "utilize ceremonial weaponry';'purported to curse foes'",
            onHit: "'[STAT::amt], inflict one of following';'[STATUS::puncture]';'[STATUS::cursed]';'[STATUS::vulnerable]'",
            onCrit:"'inflict one of following';'[STATUS::puncture]';'[STATUS::cursed]';'[STATUS::vulnerable]';'[STATUS::stun]'",
        },
        stats: {
            accuracy: .8,
            crit: 0.2,
            amt: 1,
            status: {
                cursed: {
                    name: 'cursed',
                    length: 2
                },
                puncture: {
                    name: 'puncture',
                    length: 3
                },
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },
				stun: {
					name: 'stun',
					length: 1
				}
            },
        },
        accuracy: 0.8,
        crit: 0.2,
        amt: 1,
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'destabilize',
                    rate: 2
                },
                hitExec: ({target})=> {
                    let rand = Math.random()
                    if(rand < 0.3) {
                        addStatus({target, origin: user, status: "puncture", origin: user, length: 3}); 
                        
                    } else if(rand < 0.6) {
                        addStatus({target, origin: user, status: "vulnerable", origin: user, length: 2}); 

                    } else {
                        addStatus({target, origin: user, status: "cursed", origin: user, length: 2}); 
                    }
                },
				critExec: ({target})=> {
                    let rand1 = Math.random()
                    if(rand1 < 0.25) {
                        addStatus({target, origin: user, status: "puncture", origin: user, length: 3}); 
                        
                    } else if(rand1 < 0.5) {
                        addStatus({target, origin: user, status: "vulnerable", origin: user, length: 2}); 

                    } else if(rand1 < 0.75) {
                        addStatus({target, origin: user, status: "cursed", origin: user, length: 2}); 
                    } else {
						
						addStatus({target, origin: user, status: "stun", origin: user, length: 1}); 
					}
                }
            })
        }
    },
		//hands secondary
    env.ACTIONS.prayer = {
        slug: "prayer",
        name: "Prayer",
        type: 'support+target+self+autohit',
        desc: "'make plea to chosen deity';'many beneficial outcomes'",
        help: "AUTOHIT ONE OF (+3HP +3T:REGEN, +2T:EVASION +SURGE, +2T:FOCUSED +1T:EMPOWERED, +3T:FAVORED) 10%C CHOOSE ANOTHER RANDOM EFFECT",
        anim: "heal",
		disableIf: (actor)=>{ if(hasStatus(actor,"fear")) return "PROHIBITED BY FEAR" },
        usage: {
            act: "%USER PRAYS FOR %TARGET",
            crit: "%TARGET FEELS WAY BETTER",
            hit: "%TARGET FEELS BETTER",
            miss: "%TARGET IS A HERETIC"
        },
		details: {
            flavor: "make plea to chosen deity'",
            onHit: "'grant one of following';'+3HP, [STATUS::regen]';'[STATUS::evasion], [STATUS::surge]';'[STATUS::focused], [STATUS::empowered]';'[STATUS::favored]'",
            onCrit:"'grant one of following';'+3HP, [STATUS::regen]';'[STATUS::evasion], [STATUS::surge]';'[STATUS::focused], [STATUS::empowered]';'[STATUS::favored]'",
        },
        stats: {
            autohit: true,
            crit: 0.1,
            amt: 0,
            status: {
                regen: { name: 'regen', length: 3 },
                evasion: { name: 'evasion', length: 2 },
				surge: { name: 'surge', length: 1 },
				focused: { name: 'focused', length: 2 },
				empowered: { name: 'empowered', length: 1 },
				favored: { name: 'favored', length: 3 },
            },
        },
        autohit: true,
        beneficial: true,
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                beneficial: true,
                action: this, 
                user, 
                target,
				hitSfx: {
					name: "mend",
					rate: 0.75
				},
                hitExec: ({target})=> {
                    let rand = Math.random()
                    if(rand < 0.25) {

                        addStatus({target, origin: user, status: "regen", origin: user, length: 3}); 
                        combatHit(target, {amt: -3, origin: user, autohit: true, beneficial: true});
                    } else if(rand < 0.5) {

                        addStatus({target, origin: user, status: "evasion", origin: user, length: 2}); 
						addStatus({target, origin: user, status: "surge", origin: user, length: 1}); 
                    } else if(rand < 0.75) {

                        addStatus({target, origin: user, status: "focused", origin: user, length: 2});
						addStatus({target, origin: user, status: "empowered", origin: user, length: 1});
                    } else {

						addStatus({target, origin: user, status: "favored", origin: user, length: 3}); 
					}
                },
				critExec: ({target})=> {
                    let rand1 = Math.random()
                    if(rand1 < 0.25) {

                        addStatus({target, origin: user, status: "regen", origin: user, length: 3}); 
                        combatHit(target, {amt: -3, origin: user, autohit: true, beneficial: true});
                    } else if(rand1 < 0.5) {

                        addStatus({target, origin: user, status: "evasion", origin: user, length: 2}); 
						addStatus({target, origin: user, status: "surge", origin: user, length: 1}); 
                    } else if(rand1 < 0.75) {

                        addStatus({target, origin: user, status: "focused", origin: user, length: 2});
						addStatus({target, origin: user, status: "empowered", origin: user, length: 1});
                    } else {

						addStatus({target, origin: user, status: "favored", origin: user, length: 3}); 
					}
                },
            })
        },

        avoidChaining: true,
        disableIf: (actor) => {
            return (
                actor.team.name == "enemy" &&
                !actor.team.members.some(member => ((member != actor) && (member.state != "dead") ))
            )
        }
    },
		//hands utility
    env.ACTIONS.special_prophesize = {
        slug: "special_prophesize",
        name: "Prophesize",
        type: 'special',
        desc: "'receive prophetic visions to bless allies';'incite divine intervention against foes'",
        help: "ALLIES:: ONE OF (+3T:REGEN, +2T:EVASION, +3T:FAVORED, +1T:FOCUSED), FOES:: ONE OF (+3T:PUNCTURE, +2T:VULNERABLE, +3T:CURSED, +2T:FEAR)",
        anim: "heal",
        autohit: true,
		details: {
            flavor: "'receive prophetic visions to bless allies';'incite divine intervention against foes'",
            conditional: "ALLIES::'grant one of following';'[STATUS::regen]';'[STATUS::evasion]';'[STATUS::favored]';'[STATUS::focused]'\nFOES::'inflict one of following';'[STATUS::puncture]';'[STATUS::vulnerable]';'[STATUS::cursed]';'[STATUS::fear]''",
        },
		stats: {
            autohit: true,
            crit: 0.1,
            amt: 0,
            status: {
                regen: { name: 'regen', length: 3 },
                evasion: { name: 'evasion', length: 2 },
				focused: { name: 'focused', length: 1 },
				favored: { name: 'favored', length: 3 },
				puncture: { name: 'puncture', length: 3 },
                vulnerable: { name: 'vulnerable', length: 2 },
				fear: { name: 'fear', length: 2 },
				cursed: { name: 'cursed', length: 3 },
            },
        },
        usage: {
            act: "%USER SEES THE FUTURE"
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
            let allyTeam = user.team.name
            let enemyTeam = user.enemyTeam.name

            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                advanceAfterExec: true, beingUsedAsync, user,
                exec: (actor) => {
                    if(actor.slug == user.slug) return;

                    switch(actor.team.name) {
                        case allyTeam:
                            env.GENERIC_ACTIONS.singleTarget({
                                beneficial: true,
                                action, 
                                user, 
                                target: actor,
                                canCrit: false,
								hitSfx: {
									name: "talkchoir",
									rate: 0.75
								},
                                hitExec: ()=> {
										let rand = Math.random()
										if(rand < 0.25) {

											addStatus({target: actor, origin: user, status: "regen", length: 3}); 
										} else if(rand < 0.5) {

											addStatus({target: actor, origin: user, status: "evasion", length: 2}); 
										} else if(rand < 0.75) {

											addStatus({target: actor, origin: user, status: "favored", length: 3}); 
										} else {
											
											addStatus({target: actor, origin: user, status: "focused", length: 1});
										}
									}
                            })
                        break

                        case enemyTeam:
                            env.GENERIC_ACTIONS.singleTarget({
                                action, 
                                user, 
                                target: actor,
                                canCrit: false,
								hitSfx: {
									name: "talkfairy",
									rate: 0.75
								},
                                hitExec: ()=> {
										let rand1 = Math.random()
										if(rand1 < 0.25) {

											addStatus({target: actor, origin: user, status: "puncture", origin: user, length: 3}); 
										} else if(rand1 < 0.5) {

											addStatus({target: actor, origin: user, status: "vulnerable", origin: user, length: 2}); 
										} else if(rand1 < 0.75) {

											addStatus({target: actor, origin: user, status: "cursed", origin: user, length: 3}); 
										} else {
											
											addStatus({target: actor, origin: user, status: "fear", origin: user, length: 2});
										}
									}
                            })                            
                        break
                    }
                }
            })
        }
    },
		//hands primary augment
    env.ACTIONS.ceremonial_judgement = {
        slug: "ceremonial_judgement",
        name: "Kuvakivii",
        type: 'target',
        desc: "'utilize enchanted weaponry';'cast judgement on foes'",
        anim: "basic-attack",
        help: "80% -2HP, 10%C x2 + (FOES:: + ONE OF (+3T:PUNCTURE, +3T:CURSED, +3T:VULNERABLE)",
        usage: {
            act: "%USER SWINGS AT %TARGET",
            crit: "%TARGET'S TEAM FEELS JUDGED",
            hit: "%TARGET IS BLUDGEONED",
            miss: "%TARGET DODGES"
        },
		details: {
            flavor: "utilize enchanted weaponry';'cast judgement on foes'",
			onHit: "[STAT::amt]",
            onCrit: "'inflict one of following to all foes';'[STATUS::puncture]';'[STATUS::cursed]';'[STATUS::vulnerable]';[STATUS::stun]'",
        },
        stats: {
            accuracy: .8,
            crit: 0.15,
            amt: 2,
            status: {
                cursed: {
                    name: 'cursed',
                    length: 3
                },
                puncture: {
                    name: 'puncture',
                    length: 3
                },
                vulnerable: {
                    name: 'vulnerable',
                    length: 3
                },
				stun: {
                    name: 'stun',
                    length: 1
                }
            },
        },
        exec: function(user, target) {

            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'destabilize',
                    rate: 1.5
                },

                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i)=> {
						let rand = Math.random()
						if(rand < 0.25) {
							addStatus({target: actor, origin: user, status: "puncture", origin: user, length: 3}); 
							console.log('applying puncture')
							play('stab', 0.75)
						} else if(rand < 0.5) {
							console.log('applying vulnerable')
							addStatus({target: actor, origin: user, status: "vulnerable", origin: user, length: 3}); 
							play('status', 1)
						} else if(rand < 0.75) {
							console.log('applying cursed')
							addStatus({target: actor, origin: user, status: "cursed", origin: user, length: 3}); 
							play('talkfairy', 0.5)
						}
						else {
							console.log('applying stun')
							addStatus({target: actor, origin: user, status: "stun", origin: user, length: 1}); 
							play('fear', 1)
						}
					}
                })
            })
        }
    },
		//hands secondary augment
    env.ACTIONS.special_prayer_allies = {
        slug: "special_prayer_allies",
        name: "Ritual",
        type: 'special',
        desc: "'perform ritual to bless allies';'many beneficial outcomes'",
        help: "ALLIES:: AUTOHIT ONE OF (+2HP -PUNCTURE, +SURGE, +1T:FOCUSED, +2T:FAVORED), 10%C CHOOSE ANOTHER RANDOM EFFECT",
        anim: "heal",
		beneficial: true,
		disableIf: (actor)=>{ if(hasStatus(actor,"fear")) return "PROHIBITED BY FEAR" },
        usage: {
            act: "%USER PRAYS FOR THEIR TEAM"
        },
		details: {
            flavor: "'perform ritual to entertain chosen deity'",
            onUse: "'grant one of following';'+2HP, -PUNCTURE';'[STATUS::surge]';'[STATUS::focused]';'[STATUS::favored]'",
            onCrit: "'grant one of following';'+2HP, -PUNCTURE';'[STATUS::surge]';'[STATUS::focused]';'[STATUS::favored]'",
        },
        stats: {
            autohit: true,
            crit: 0.1,
            amt: 0,
            status: {
				surge: { name: 'surge', length: 1 },
				focused: { name: 'focused', length: 1 },
				favored: { name: 'favored', length: 2},
            },
        },
        exec: function(user, target, beingUsedAsync) {
            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
					env.GENERIC_ACTIONS.singleTarget({
						user: user,
						target: actor,
						action: this,
						beneficial: true,
						hitSfx: {
							name: 'mend',
							rate: 0.75
						},
						critSfx: {
							name: 'mend',
							rate: 0.5
						},
						hitExec: ({target})=> {
							let rand = Math.random()
							if(rand < 0.25) {
								removeStatus(target, "puncture")
								combatHit(target, {amt: -2, origin: user, autohit: true, beneficial: true});
							} else if(rand < 0.5) {

								addStatus({target, origin: user, status: "surge", origin: user, length: 1}); 
							} else if(rand < 0.75) {

								addStatus({target, origin: user, status: "focused", origin: user, length: 1});
							} else {

								addStatus({target, origin: user, status: "favored", origin: user, length: 2}); 
							}
						},
						critExec: ({target})=> {
							let rand1 = Math.random()
							if(rand1 < 0.25) {
								removeStatus(target, "puncture")
								combatHit(target, {amt: -2, origin: user, autohit: true, beneficial: true});
							} else if(rand1 < 0.5) {

								addStatus({target, origin: user, status: "surge", origin: user, length: 1}); 
							} else if(rand1 < 0.75) {

								addStatus({target, origin: user, status: "focused", origin: user, length: 1});
							} else {

								addStatus({target, origin: user, status: "favored", origin: user, length: 2}); 
							}
						}
					})
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	//oh god here we go
	//major arcana actions start here
	env.ACTIONS.tarot_thefool = {
        slug: "tarot_thefool",
        name: "TAROT:: The Fool",
        type: 'autohit',
        desc: "'SORRY NOTHING'",
        anim: "",
        help: "NO EFFECT",
        usage: {
            act: "%USER DRAWS THE FOOL"
        },
        exec: function(user, target, beingUsedAsync) {
            advanceTurn(user)
        }
    },
	
	env.ACTIONS.tarot_thefool_reversed = {
        slug: "tarot_thefool_reversed",
        name: "TAROT:: The Fool, Reversed",
        type: 'special',
        desc: "'affect all thoughtforms with incoherence'",
        help: "ALL::AUTOHIT +3T:VULNERABLE +SURGE +CRITICAL FLAW",
        anim: "wobble",
        autohit: true,
        canCrit: false,
        exec: function(user, target, beingUsedAsync) {
            actionMessage(user, "%USER DRAWS THE FOOL, REVERSED", target);
            
            if(env.rpg.classList.contains("bastard")) {                
                if(user.team.name == "ally") {
                    env.rpg.classList.add('incoherentbg')
                    content.classList.add('painprep', 'painfade', 'painhalf')
                    setTimeout(()=>{content.classList.add('painmode')}, 100)
                    setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                    setTimeout(()=>{content.classList.remove('painprep', 'painfade', 'painhalf')}, 5000)

                    setTimeout(()=>{env.rpg.classList.remove('incoherentbg')}, 4000)
                }
            } else {
                ratween(env.bgm, 1, 2000)
                env.rpg.classList.add('incoherentbg')
                content.classList.add('painprep', 'painhalf')
                setTimeout(()=>{content.classList.add('painmode')}, 100)
                setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                setTimeout(()=>{content.classList.remove('painprep', 'painhalf')}, 5000)
            }
            
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        autohit: true,
                        hitSfx: {
                            name: 'talkfairy',
                            rate: 0.75
                        },
                        genExec: ({target}) => {
                            addStatus({target: actor, origin: user, status: "vulnerable", length: 3});
							addStatus({target: actor, origin: user, status: "critical_flaw", length: 1});
							addStatus({target: actor, origin: user, status: "surge", length: 1});
                        }
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_themagician = { //beneficial card
		slug: "tarot_themagician",
		name: "TAROT:: The Magician",
		type: 'special+summon+nomimic',
		desc: "'collect additional allies from elsewhere'",
		help: "SUMMON::4 IDEAS (MAX: 12 SUMMONS)\nALLIES::+2T:EMPOWERED",
		anim: "heal",
		accuracy: 1,
		crit: 0,
		itemAction: true, //we have to lie here so that imps can't use this action
		noRepeat: true,
		exec: function(user, target, beingUsedAsync) {
			actionMessage(user, "%USER DRAWS THE MAGICIAN", target, 'none', 2000);
			play('dull', 0.8, 1);
			
			//try to center the dude
			if(user.team.members.length == 14) {
				let uI = user.team.members.findIndex(a => a.slug == user.slug)
				if(uI < 3) midCombatAllyAdd('player_critta_spawner_bee', 'left')
				else if(uI >= 3) midCombatAllyAdd('player_critta_spawner_bee', 'right')
			} else {
				midCombatAllyAdd('player_critta_spawner_bee', 'left')
				midCombatAllyAdd('player_critta_spawner_bee', 'left')
				midCombatAllyAdd('player_critta_spawner_bee', 'right')
				midCombatAllyAdd('player_critta_spawner_bee', 'right')
			}
			setTimeout(()=>{             
				env.GENERIC_ACTIONS.teamWave({
						team: user.team,
						exec: (actor, i)=>{
							addStatus({target: actor, origin: user, status: "empowered", origin: user, length: 2, noReact: true}); 
							play('mend', 0.5);
						}
					})
				}, env.ADVANCE_RATE * 0.5)
			setTimeout(()=>advanceTurn(user), 1000)
		},
		disableIf: (actor) => {if(actor.team.members.length > 15) return "TOO MANY ALLIES" }
	}
	
	env.ACTIONS.tarot_themagician_noadvance = { //beneficial card
		slug: "tarot_themagician_noadvance",
		name: "TAROT:: The Magician",
		type: 'special+summon+nomimic',
		desc: "'collect additional allies from elsewhere'",
		help: "SUMMON::4 IDEAS (MAX: 12 SUMMONS)\nALLIES::+2T:EMPOWERED",
		anim: "heal",
		accuracy: 1,
		crit: 0,
		itemAction: true, //we have to lie here so that imps can't use this action
		noRepeat: true,
		exec: function(user, target, beingUsedAsync) {
			actionMessage(user, "%USER DRAWS THE MAGICIAN", target, 'none', 2000);
			play('dull', 0.8, 1);
			
			//try to center the dude
			if(user.team.members.length == 14) {
				let uI = user.team.members.findIndex(a => a.slug == user.slug)
				if(uI < 3) midCombatAllyAdd('player_critta_spawner_bee', 'left')
				else if(uI >= 3) midCombatAllyAdd('player_critta_spawner_bee', 'right')
			} else {
				midCombatAllyAdd('player_critta_spawner_bee', 'left')
				midCombatAllyAdd('player_critta_spawner_bee', 'left')
				midCombatAllyAdd('player_critta_spawner_bee', 'right')
				midCombatAllyAdd('player_critta_spawner_bee', 'right')
			}
			setTimeout(()=>{             
				env.GENERIC_ACTIONS.teamWave({
						team: user.team,
						exec: (actor, i)=>{
							addStatus({target: actor, origin: user, status: "empowered", origin: user, length: 2, noReact: true}); 
							play('mend', 0.5);
						}
					})
				}, env.ADVANCE_RATE * 0.5)
		},
		disableIf: (actor) => {if(actor.team.members.length > 15) return "TOO MANY ALLIES" }
	}
	
	env.ACTIONS.tarot_themagician_reversed = {
        slug: "tarot_themagician_reversed",
        name: "TAROT:: The Magician, Reversed",
        type: 'special',
        desc: "'affect all thoughtforms with incoherence'",
        help: "ALL::AUTOHIT +3T:WEAKENED, +3T:FEAR, +MADNESS",
        anim: "wobble",
        autohit: true,
        canCrit: false,
        exec: function(user, target, beingUsedAsync) {
            actionMessage(user, "%USER DRAWS THE MAGICIAN, REVERSED", target);
            
            if(env.rpg.classList.contains("bastard")) {                
                if(user.team.name == "ally") {
                    env.rpg.classList.add('incoherentbg')
                    content.classList.add('painprep', 'painfade', 'painhalf')
                    setTimeout(()=>{content.classList.add('painmode')}, 100)
                    setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                    setTimeout(()=>{content.classList.remove('painprep', 'painfade', 'painhalf')}, 5000)

                    setTimeout(()=>{env.rpg.classList.remove('incoherentbg')}, 4000)
                }
            } else {
                ratween(env.bgm, 1, 2000)
                env.rpg.classList.add('incoherentbg')
                content.classList.add('painprep', 'painhalf')
                setTimeout(()=>{content.classList.add('painmode')}, 100)
                setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                setTimeout(()=>{content.classList.remove('painprep', 'painhalf')}, 5000)
            }
            
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        autohit: true,
                        hitSfx: {
                            name: 'fear',
                            rate: 0.75
                        },
                        genExec: ({target}) => {
                            addStatus({target: actor, origin: user, status: "weakened", length: 3});
							addStatus({target: actor, origin: user, status: "fear", length: 3});
							addStatus({target: actor, origin: user, status: "madness", length: 1});
                        }
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_thehighpriestess = { //beneficial card
        slug: "tarot_thehighpriestess",
        name: "TAROT:: The High Priestess",
        type: 'self+autohit+support',
        desc: "'back off';'focus entire team'",
        anim: "",
        help: "ALLIES::+4T:FOCUSED, +3T:EVASION",
        usage: {
            act: "%USER DRAWS THE HIGH PRIESTESS"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkchoir7", 2)

            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "focused", origin: user, length: 4, noReact: true});
                    addStatus({target: actor, origin: user, status: "evasion", origin: user, length: 3, noReact: true}); 					
                    play('mend', 0.5);
                },
				advanceAfterExec: true, beingUsedAsync, user,
            })

            return 'nothing'
        }
    },
	
	env.ACTIONS.tarot_thehighpriestess_reversed = { //beneficial card
        slug: "tarot_thehighpriestess_reversed",
        name: "TAROT:: The High Priestess, Reversed",
        type: 'autohit+support',
        desc: "'back off';'focus entire team'",
        anim: "",
        help: "FOES::+4T:FEAR, +4T:CURSED",
        usage: {
            act: "%USER DRAWS THE HIGH PRIESTESS, REVERSED"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkfairy", 2)

            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "fear", origin: user, length: 4, noReact: true});
                    addStatus({target: actor, origin: user, status: "cursed", origin: user, length: 4, noReact: true}); 					
                    play('status', 0.5);
                },
				advanceAfterExec: true, beingUsedAsync, user,
            })

            return 'nothing'
        }
    },
	
	env.ACTIONS.tarot_theempress = { //beneficial card
        slug: "tarot_theempress",
        name: "TAROT:: The Empress",
        type: 'special',
        desc: "'project broad reparative applicators';'restore allies to fighting condition'",
        help: "ALLIES::AUTOHIT +4HP +4T:REGEN -PUNCTURE -DOWN",
        anim: "heal",
        autohit: true,
        amt: -4,
        usage: {
            act: "%USER DRAWS THE EMPRESS"
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        //beneficial: true,
                        action, 
                        user, 
                        target: actor,
                        hitStatus: {name: 'regen', length: 4},
                        hitSfx: {
                            name: 'mend',
                            rate: 1
                        },
                        genExec: ()=>{
                            if(actor.state == "dead") {
                                actor.hp = 3
                                combatRevive(actor)
                                reactDialogue(actor, 'receive_rez')
                                addStatus({target: actor, origin: user, status: "evasion", length: 2, noReact: true}); 
                            }
                        }                
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_theempress_reversed = { //beneficial card
        slug: "tarot_theempress_reversed",
        name: "TAROT:: The Empress, Reversed",
        type: 'special',
        desc: "'wide directional release of rapidly decaying dull light';'deconstructs foes'",
        help: "FOES::100% -3HP +4T:PUNCTURE, 20%C x2 +4T:PUNCTURE",
        anim: "basic-attack",
        accuracy: 1,
        crit: 0.2,
        amt: 3,
        usage: {
            act: "%USER DRAWS THE EMPRESS, REVERSED"
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
                    let anim = env.COMBAT_ANIMS.shoot
                    let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
                    let animDelay = baseDelay + anim.duration;
                        
                    setTimeout(()=>anim.exec(action, user, actor), baseDelay)
                    setTimeout(function(){
                        env.GENERIC_ACTIONS.singleTarget({
                            beneficial: true,
                            action: action, 
                            user, 
                            target: actor,
                            hitSfx: { name: 'shot6', rate: 0.75 },
                            critSfx: { name: 'stab', rate: 0.5 },
							hitStatus: { name: 'puncture', length: 4 },
							critStatus: { name: 'puncture', length: 4 }
                        })
                    }, animDelay);
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_theemperor = { //beneficial card
        slug: "tarot_theemperor",
        name: "TAROT:: The Emperor",
        type: 'special',
        desc: "'apply ablative protection';'upgrades protection to passively increase accuracy'",
        help: "ALLIES::+5 BP +HARDENED +REPAIRS +1T:FOCUSED",
        anim: "cloak-barrier",
        autohit: true,
        crit: 0,
        amt: 5,
        usage: {
            act: "%USER DRAWS THE EMPEROR"
        },
        exec: function(user, target, beingUsedAsync) {
			let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        beneficial: true,
                        type: 'barrier',
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'guard',
                            rate: 0.5
                        },
						hitExec: ({target})=> {
							addStatus({target, origin: user, status: "hardened", length: 1, noReact: true})
							addStatus({target, origin: user, status: "repairs", length: 1, noReact: true})
							addStatus({target, origin: user, status: "focused", length: 1, noReact: true})
						},
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_theemperor_reversed = { //beneficial card
        slug: "tarot_theemperor_reversed",
        name: "TAROT:: The Emperor, Reversed",
        type: 'special',
        desc: "'apply ablative protection';'upgrades protection to passively increase accuracy'",
        help: "FOES::+10 BP +MILLION TEETH +FRACTALLINE",
        anim: "cloak-barrier",
        autohit: true,
        crit: 0,
        amt: 10,
        usage: {
            act: "%USER DRAWS THE EMPEROR, REVERSED"
        },
        exec: function(user, target, beingUsedAsync) {
			let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        beneficial: true,
                        type: 'barrier',
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'talkfairy',
                            rate: 2
                        },
						hitExec: ({target})=> {
							addStatus({target, origin: user, status: "million_teeth", length: 1, noReact: true})
							addStatus({target, origin: user, status: "fractalline", length: 1, noReact: true})
						},
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_thehierophant = { //beneficial card
        slug: "tarot_thehierophant",
        name: "TAROT:: The Hierophant",
        type: 'special',
        desc: "'reveal a terrible truth';'mark self for death';'randomly affect enemy team'",
        anim: "",
        help: "ALLIES::FULLY RESTORE HP",
        usage: {
            act: "%USER DRAWS THE HIEROPHANT"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {

            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i)=>{
                        play('talkflower', 1)
                        sendFloater({
                            target: actor,
                            type: "arbitrary",
                            specialClass: "fate",
                            arbitraryString: "REST",
                            size: 2
                        })
                        
                        actor.hp = actor.maxhp

                        //special handling for weird hp usage
                        let conjoin = actor.statusEffects.find(status=>status.slug == "player_conjoined")
                        if(conjoin) conjoin.events.onCombatHit();
                        updateStats({actor})
                },
                advanceAfterExec: true, beingUsedAsync, user,
                endCallback: ()=>{console.log('just called advance')}
            })
			advanceTurn(user)
        }
    },
	
	env.ACTIONS.tarot_thehierophant_noadvance = { //beneficial card
        slug: "tarot_thehierophant_noadvance",
        name: "TAROT:: The Hierophant",
        type: 'special',
        desc: "'reveal a terrible truth';'mark self for death';'randomly affect enemy team'",
        anim: "",
        help: "ALLIES::FULLY RESTORE HP",
        usage: {
            act: "%USER DRAWS THE HIEROPHANT"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {

            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i)=>{
                        play('talkflower', 1)
                        sendFloater({
                            target: actor,
                            type: "arbitrary",
                            specialClass: "fate",
                            arbitraryString: "REST",
                            size: 2
                        })
                        
                        actor.hp = actor.maxhp

                        //special handling for weird hp usage
                        let conjoin = actor.statusEffects.find(status=>status.slug == "player_conjoined")
                        if(conjoin) conjoin.events.onCombatHit();
                        updateStats({actor})
                },
                advanceAfterExec: true, beingUsedAsync, user,
                endCallback: ()=>{console.log('just called advance')}
            })
        }
    },
	
	env.ACTIONS.tarot_thehierophant_reversed = {
        slug: "tarot_thehierophant_reversed",
        name: "TAROT:: The Hierophant, Reversed",
        type: 'special',
        desc: "'grasp the nature of this place';'recognize and exploit framing device'",
        anim: "wobble",
        help: "ALL::STATUS INVERSION",
        usage: {
            act: "%USER DRAWS THE HIEROPHANT, REVERSED"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkfairy", 1.5)
            let action = this
            
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'talkfairy',
                            rate: 0.75
                        },
                        genExec: ({target}) => {
                            invertStatuses(actor)
                        }
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_thelovers = {
        slug: "tarot_thelovers",
        name: "TAROT:: The Lovers",
        type: 'special+nomimic',
        desc: "'impart horrific knowledge';'afflict foes with fear and madness';'misdirect attacks of foes'",
        anim: "",
        help: "FOES::+CONJOINED",
        usage: {
            act: "%USER DRAWS THE LOVERS"
        },
        autohit: true,
		itemAction: true, //we have to lie here so that imps can't use this action
        exec: function(user, target, beingUsedAsync) {
            play("talkfairy", 0.35)

            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "conjoined", length: 1}); 
                },
                
                advanceAfterExec: true, beingUsedAsync, user,
                endCallback: ()=>{console.log('just called advance')}
            })
        }
    },
	
	env.ACTIONS.tarot_thelovers_reversed = {
        slug: "tarot_thelovers_reversed",
        name: "TAROT:: The Lovers, Reversed",
        type: 'special',
        desc: "'receive prophetic visions to bless allies';'incite divine intervention against foes'",
        help: "ALLIES:: +2T:VULNERABLE, +1T:STUN, FOES:: +1T:FOCUSED +SURGE",
        anim: "",
        autohit: true,
        usage: {
            act: "%USER DRAWS THE LOVERS, REVERSED"
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
            let allyTeam = user.team.name
            let enemyTeam = user.enemyTeam.name

            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                advanceAfterExec: true, beingUsedAsync, user,
                exec: (actor) => {

                    switch(actor.team.name) {
                        case allyTeam:
                            env.GENERIC_ACTIONS.singleTarget({
                                beneficial: true,
                                action, 
                                user, 
                                target: actor,
                                canCrit: false,
								hitSfx: {
									name: "talkfairy",
									rate: 0.5
								},
                                hitExec: ()=> {
										addStatus({target: actor, origin: user, status: "vulnerable", origin: user, length: 2});
										addStatus({target: actor, origin: user, status: "stun", origin: user, length: 1});
									}
                            })
                        break

                        case enemyTeam:
                            env.GENERIC_ACTIONS.singleTarget({
                                action, 
                                user, 
                                target: actor,
                                canCrit: false,
								hitSfx: {
									name: "talkchoir7",
									rate: 2
								},
                                hitExec: ()=> {
										addStatus({target: actor, origin: user, status: "focused", origin: user, length: 1});
										addStatus({target: actor, origin: user, status: "surge", origin: user, length: 1});
									}
                            })                            
                        break
                    }
                }
            })
        }
    },
	
	env.ACTIONS.tarot_thechariot = { //beneficial card
        slug: "tarot_thechariot",
        name: "TAROT:: The Chariot",
        type: 'self+autohit+support',
        desc: "'back off';'focus entire team'",
        anim: "",
        help: "ALLIES::+4T:FOCUSED, +4T:EMPOWERED",
        usage: {
            act: "%USER DRAWS THE CHARIOT"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkchoir7", 2)


            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "focused", origin: user, length: 4, noReact: true}); 
					addStatus({target: actor, origin: user, status: "empowered", origin: user, length: 4, noReact: true}); 
                    play('mend', 0.5);
                },
				advanceAfterExec: true, beingUsedAsync, user,
            })

            return 'nothing'
        }
    },
	
	env.ACTIONS.tarot_thechariot_reversed = {
        slug: "tarot_thechariot_reversed",
        name: "TAROT:: The Chariot, Reversed",
        type: 'self+autohit+support',
        desc: "'back off';'focus entire team'",
        anim: "",
        help: "ALLIES::2T:FEAR, +MADNESS, +WILD SURGE",
        usage: {
            act: "%USER DRAWS THE CHARIOT, REVERSED"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkfairy", 2)


            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "fear", origin: user, length: 2, noReact: true}); 
					addStatus({target: actor, origin: user, status: "madness", origin: user, length: 1, noReact: true}); 
					addStatus({target: actor, origin: user, status: "wild_surge", origin: user, length: 1, noReact: true}); 
                    play('fear', 0.5);
                },
				advanceAfterExec: true, beingUsedAsync, user,
            })

            return 'nothing'
        }
    },
	
	env.ACTIONS.tarot_strength = { //beneficial card
        slug: "tarot_strength",
        name: "TAROT:: Strength",
        type: 'self+autohit+support',
        desc: "'back off';'focus entire team'",
        anim: "",
        help: "ALLIES::+5T:FOCUSED +INFALLIBLE",
        usage: {
            act: "%USER DRAWS STRENGTH"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkchoir7", 2)


            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "focused", origin: user, length: 5, noReact: true}); 
					addStatus({target: actor, origin: user, status: "infallible", origin: user, length: 1, noReact: true}); 
                    play('talkchoir', 0.5);
                },
				advanceAfterExec: true, beingUsedAsync, user,
            })

            return 'nothing'
        }
    },
	
	env.ACTIONS.tarot_strength_reversed = { //beneficial card
        slug: "tarot_strength_reversed",
        name: "TAROT:: Strength, Reversed",
        type: 'special',
        desc: "'impart horrific knowledge';'afflict foes with fear and madness';'misdirect attacks of foes'",
        anim: "",
        help: "FOES::+3T:FEAR +MADNESS SPECIAL::100% REDUCE FOE HP BY 75%",
        usage: {
            act: "%USER DRAWS STRENGTH, REVERSED"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkfairy", 0.25)

            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "fear", length: 3}); 
                    addStatus({target: actor, origin: user, status: "madness", length: 1});
                        
					sendFloater({
						target: actor,
						type: "arbitrary",
						specialClass: "fate",
						arbitraryString: "REPENT",
						size: 2
					})
					
					actor.hp = Math.floor(actor.hp * 0.25)

					//special handling for weird hp usage
					let conjoin = actor.statusEffects.find(status=>status.slug == "conjoined")
					if(conjoin) conjoin.events.onCombatHit();
					updateStats({actor})
					
					advanceAfterExec: true,
					beingUsedAsync,
					user
					endCallback: ()=>{console.log('just called advance')}
					advanceTurn(user)
				}
            })
        }
    },
	
	env.ACTIONS.tarot_strength_reversed_noadvance = { //beneficial card
        slug: "tarot_strength_reversed_noadvance",
        name: "TAROT:: Strength, Reversed",
        type: 'special',
        desc: "'impart horrific knowledge';'afflict foes with fear and madness';'misdirect attacks of foes'",
        anim: "",
        help: "FOES::+3T:FEAR +MADNESS SPECIAL::100% REDUCE FOE HP BY 75%",
        usage: {
            act: "%USER DRAWS STRENGTH, REVERSED"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkfairy", 0.25)

            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "fear", length: 3}); 
                    addStatus({target: actor, origin: user, status: "madness", length: 1});
                        
					sendFloater({
						target: actor,
						type: "arbitrary",
						specialClass: "fate",
						arbitraryString: "REPENT",
						size: 2
					})
					
					actor.hp = Math.floor(actor.hp * 0.25)

					//special handling for weird hp usage
					let conjoin = actor.statusEffects.find(status=>status.slug == "conjoined")
					if(conjoin) conjoin.events.onCombatHit();
					updateStats({actor})
					
					advanceAfterExec: true,
					beingUsedAsync,
					user
					endCallback: ()=>{console.log('just called advance')}
				}
            })
        }
    },
	
	env.ACTIONS.tarot_thehermit = { //beneficial card
        slug: "tarot_thehermit",
        name: "TAROT:: The Hermit",
        type: 'autohit',
        desc: "'hide vulnerability';'look for opportunity';'useful against wily foes'",
        anim: "",
        help: "SELF::+SURGE +4T:FOCUSED +4T:EVASION +4T:EMPOWERED +4T:CARAPACE +4T:SPIKES +4T:REGEN +4T:FAVORED",
        usage: {
            act: "%USER DRAWS THE HERMIT"
        },
        
        exec: function(user, target, beingUsedAsync) {
            play('talkchoir', 0.5);
				addStatus({target: user, origin: user, status: "surge", length: 1})
                addStatus({target: user, origin: user, status: "focused", length: 4})
                addStatus({target: user, origin: user, status: "evasion", length: 4})
                addStatus({target: user, origin: user, status: "empowered", length: 4})
                addStatus({target: user, origin: user, status: "carapace", length: 4})
                addStatus({target: user, origin: user, status: "spikes", length: 4})
				addStatus({target: user, origin: user, status: "regen", length: 4})
				addStatus({target: user, origin: user, status: "favored", length: 4})
				advanceTurn(user)
            return 'nothing';
        },
        avoidChaining: true
    },
	
	env.ACTIONS.tarot_thehermit_reversed = {
        slug: "tarot_thehermit_reversed",
        name: "TAROT:: The Hermit, Reversed",
        type: 'autohit',
        desc: "'hide vulnerability';'look for opportunity';'useful against wily foes'",
        anim: "",
        help: "SELF::+2T:STUN +4T:FEAR +4T:VULNERABLE +CRITICAL FLAW +4T:WEAKENED +4T:OPEN WOUND +4T:SIPHON +4T:PUNCTURE +4T:CURSED",
        usage: {
            act: "%USER DRAWS THE HERMIT, REVERSED"
        },
        
        exec: function(user, target, beingUsedAsync) {
            play('fairy', 0.25);
				addStatus({target: user, origin: user, status: "stun", length: 2})
                addStatus({target: user, origin: user, status: "fear", length: 4})
                addStatus({target: user, origin: user, status: "vulnerable", length: 4})
				addStatus({target: user, origin: user, status: "critical_flaw", length: 1})
                addStatus({target: user, origin: user, status: "weakened", length: 4})
                addStatus({target: user, origin: user, status: "open_wound", length: 4})
                addStatus({target: user, origin: user, status: "siphon", length: 4})
				addStatus({target: user, origin: user, status: "puncture", length: 4})
				addStatus({target: user, origin: user, status: "cursed", length: 4})
				advanceTurn(user)
            return 'nothing';
        },
        avoidChaining: true
    },
	
	env.ACTIONS.tarot_thewheeloffortune = { //beneficial card
        slug: "tarot_thewheeloffortune",
        name: "TAROT:: The Wheel Of Fortune",
        type: 'special',
        desc: "'receive prophetic visions to bless allies';'incite divine intervention against foes'",
        help: "ALLIES:: ONE OF (+4T:REGEN +3HP, +4T:EVASION +SURGE, +6T:FAVORED +CHOSEN, +4T:FOCUSED +INFALLIBLE), FOES:: ONE OF (+4T:PUNCTURE -3HP, +4T:VULNERABLE +1T:STUN +CRITICAL FLAW, +6T:CURSED +FORSAKEN, +4T:FEAR +MADNESS)",
        anim: "",
        autohit: true,
        usage: {
            act: "%USER DRAWS THE WHEEL OF FORTUNE"
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
            let allyTeam = user.team.name
            let enemyTeam = user.enemyTeam.name

            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                advanceAfterExec: true, beingUsedAsync, user,
                exec: (actor) => {

                    switch(actor.team.name) {
                        case allyTeam:
                            env.GENERIC_ACTIONS.singleTarget({
                                beneficial: true,
                                action, 
                                user, 
                                target: actor,
                                canCrit: false,
								hitSfx: {
									name: "talkchoir",
									rate: 0.5
								},
                                hitExec: ()=> {
									let rand = Math.random()
									if(rand < 0.25) {
										combatHit(target, {amt: -3, origin: user, autohit: true, beneficial: true});
										addStatus({target: actor, origin: user, status: "regen", length: 4}); 
									} else if(rand < 0.5) {
										addStatus({target: actor, origin: user, status: "surge", length: 1}); 
										addStatus({target: actor, origin: user, status: "evasion", length: 4}); 
									} else if(rand < 0.75) {
										addStatus({target: actor, origin: user, status: "favored", length: 6});
										addStatus({target: actor, origin: user, status: "chosen", length: 1}); 
									} else {
										addStatus({target: actor, origin: user, status: "focused", length: 4});
										addStatus({target: actor, origin: user, status: "infallible", length: 1});
									}
								}
                            })
                        break

                        case enemyTeam:
                            env.GENERIC_ACTIONS.singleTarget({
                                action, 
                                user, 
                                target: actor,
                                canCrit: false,
								hitSfx: {
									name: "talkfairy",
									rate: 0.5
								},
                                hitExec: ()=> {
									let rand1 = Math.random()
									if(rand1 < 0.25) {
										combatHit(target, {amt: 3, origin: user, autohit: true, beneficial: false});
										addStatus({target: actor, origin: user, status: "puncture", origin: user, length: 4}); 
									} else if(rand1 < 0.5) {
										addStatus({target: actor, origin: user, status: "stun", origin: user, length: 1});
										addStatus({target: actor, origin: user, status: "vulnerable", origin: user, length: 4});
										addStatus({target: actor, origin: user, status: "critical_flaw", origin: user, length: 1});											
									} else if(rand1 < 0.75) {
										addStatus({target: actor, origin: user, status: "cursed", origin: user, length: 6});
										addStatus({target: actor, origin: user, status: "forsaken", origin: user, length: 1}); 
									} else {
										addStatus({target: actor, origin: user, status: "fear", origin: user, length: 4});
										addStatus({target: actor, origin: user, status: "madness", origin: user, length: 1});
									}
								}
                            })                            
                        break
                    }
                }
            })
        }
    },
	
	env.ACTIONS.tarot_thewheeloffortune_reversed = {
        slug: "tarot_thewheeloffortune_reversed",
        name: "TAROT:: The Wheel Of Fortune, Reversed",
        type: 'special',
        desc: "'Ã¢Â«Â§Ã¢ÂªÂ¶Ã£Â¥Â¥Ã£Â³'",
        help: "SSP IN  THE WHEE L LL LL",
        anim: "",
        autohit: true,
        crit: 0,
        usage: {
            act: "%USER DRAWS THE WHEEL OF FORTUNE, REVERSED"
        },
        noRepeat: true,
        possiblePassives: ["light_veilkdrop", "light_humorist", "eyes_dancer", "bone_adaptive", "claws_chitin", "light_glee", "eyes_hypercritical", "malware_drill", "malware_rot", "weak_point"],
        exec: function(user, target, beingUsedAsync) {
			let actor = user

                    env.rpg.insertAdjacentHTML('beforeend', `
                    <figure id="chancepanel" class="hidden" for="${actor.slug}">
                        <img src="/img/sprites/flantrusive/panelbase.gif">
                        <div class="wheel">
                            <ul>
                                <li class="d1">1</li>
                                <li class="d2">2</li>
                                <li class="d3">3</li>
                                <li class="d4">4</li>
                                <li class="d5">5</li>
                                <li class="d6">6</li>
                            </ul>
                        </div>
                        <div class="display">
                            <ol>
                                <li class="d1">1. life up</li>
                                <li class="d2">2. main up</li>
                                <li class="d3">3. unlucky</li>
                                <li class="d4">4. bomb</li>
                                <li class="d5">5. unlucky</li>
                                <li class="d6">6. change</li>
                            </ol>
                        </div>
                        <div class="result">
                            <div>
                                <span></span>
                            </div>
                        </div>
                    </figure>`)
                
                    actor.chancePanel = env.rpg.querySelector(`#chancepanel[for="${actor.slug}"]`)
                    actor.chancePanel.result = actor.chancePanel.querySelector(".result span")
                    actor.chancePanel.spin = (state) => { 
                        actor.chancePanel.removeAttribute("chosen")
                        actor.chancePanel.classList.toggle("spinning", state) 
                        actor.chancePanel.result.innerHTML = "???"
                    }
                
                    actor.chancePanel.stopAndResult = () => { 
                        let result = rand(1, 7)
                        actor.chancePanel.spin(false)
                        actor.chancePanel.setAttribute("chosen", result)
                
                        return result
                    }
			setTimeout(()=>{
				if(!user.chancePanel) throw 'ok intrusive spawned wrong';
				let action = this

				user.box.classList.add("disable")
				user.chancePanel.classList.add("active")
				user.chancePanel.classList.remove("hidden")
				user.chancePanel.spin(true)

				play("talkfairy", 0.5)
				let result

				setTimeout(()=>{
					result = user.chancePanel.stopAndResult()
					user.box.classList.remove("disable")
					playCombatCrit()
				}, 1000)

				setTimeout(()=>{
					switch(result) {
						case 1: // life up - gives 5HP and 5 turns of regen to allies
							user.chancePanel.result.innerHTML = "LUCKY! CHA CHA"
							env.GENERIC_ACTIONS.teamWave({
								team: user.team,
								exec: (actor, i) => {
									env.GENERIC_ACTIONS.singleTarget({
										beneficial: true,
										autohit: true,
										action,
										amt: -5,
										canCrit: false,
										user, 
										target: actor,
										hitSfx: {
											name: 'talklaugh',
											rate: 0.5
										},
										hitStatus: {
											name: 'regen',
											length: 5
										},
									})
								},
								advanceAfterExec: true, beingUsedAsync
							})
						break

						case 2: // main up - allies get focus and empowered
							user.chancePanel.result.innerHTML = "LUCKY! CHA CHA"
							env.GENERIC_ACTIONS.teamWave({
								team: user.team,
								exec: (actor, i) => {
									env.GENERIC_ACTIONS.singleTarget({
										beneficial: true,
										autohit: true,
										action,
										amt: 0,
										canCrit: false,
										user, 
										target: actor,
										hitSfx: {
											name: 'talklaugh',
											rate: 0.5
										},
										hitStatus: {
											name: 'focused',
											length: 2
										},
										genExec: ({target}) => {
											addStatus({target, status: "empowered", length: 1, noReact: true})
										}
									})
								},
								advanceAfterExec: true, beingUsedAsync
							})
						break

						case 3: // unlucky
						case 5: // gives enemies focus and empowered
							user.chancePanel.result.innerHTML = "BAD TIM!::E NO,W!"

							env.GENERIC_ACTIONS.teamWave({
								team: user.enemyTeam,
								exec: (actor, i) => {
									env.GENERIC_ACTIONS.singleTarget({
										beneficial: true,
										autohit: true,
										action,
										amt: 0,
										canCrit: false,
										user, 
										target: actor,
										hitSfx: {
											name: 'talklaugh',
											rate: 0.5
										},
										hitStatus: {
											name: 'focused',
											length: 2
										},
										genExec: ({target}) => {
											addStatus({target, status: "empowered", length: 1, noReact: true})
										}
									})
								},
								advanceAfterExec: true, beingUsedAsync
							})
						break

						case 4: // bombs - spawns a bastard bomb
							user.chancePanel.result.innerHTML = "BOOM :=)"
							play('dull', 0.8, 1)

							if(user.team.members.length < 6) {
								let bomb = midCombatEnemyAdd("intrusive_bomblet", 'right')
								if(bomb){
									addStatus({target: bomb, status: "weak_point", length: 1})
									addStatus({target: bomb, status: "ethereal", length: 1})
									delete bomb.statusImmunities
								}
							} else {
								useAction(user, env.ACTIONS.special_mass_destabilize, user, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "???"})
							}
						break

						case 6: // change - gives everyone a special passive that's overridden by each change roll
							user.chancePanel.result.innerHTML = "THINK AGAIN"
							env.GENERIC_ACTIONS.teamWave({
								arbitraryActorList: env.rpg.turnOrder,
								exec: (actor, i) => {
									env.GENERIC_ACTIONS.singleTarget({
										beneficial: true,
										autohit: true,
										action,
										amt: 0,
										canCrit: false,
										user, 
										target: actor,
										hitSfx: {
											name: 'talkfairy',
											rate: 0.5
										},
										genExec: ({target}) => {
											let currentStatuses = target.statusEffects.map(status => status.slug)
											let possiblePassives = this.possiblePassives.filter(statusName => !currentStatuses.includes(statusName))

											console.log("in with", target, possiblePassives)

											//special ones can happen on certain creatures
											if(
												!target.slug.includes("intrusive") ||
												target.slug == "intrusive_bishopfreak"
											) possiblePassives.push("visionary")

											if(
												!target.slug.includes("intrusive") ||
												target.slug == "intrusive_bishopfreak" ||
												target.slug == "intrusive_statusoid"
											) possiblePassives.push("active_support")

											if(
												!target.slug.includes("intrusive") ||
												target.slug == "intrusive_bishopfreak" ||
												target.slug == "intrusive_statusoid"
											) possiblePassives.push("impatient")
											
											// remove passive beforehand if one exists
											if(target.intrusivePassive) { removeStatus(target, target.intrusivePassive, {forceRemoveStatus: true}) }
											target.intrusivePassive = possiblePassives.sample()
											addStatus({target, status: target.intrusivePassive, length: 1, noReact: true})                                        
										}
									})
								},
								advanceAfterExec: true, beingUsedAsync
							})
						break
					}
				}, 1500)

				setTimeout(()=>user.chancePanel.classList.remove("active"), 3500)
			}, 0)
        }
    },
	
	
	env.ACTIONS.tarot_justice = { //beneficial card
        slug: "tarot_justice",
        name: "TAROT:: Justice",
        type: 'special',
        desc: "'reveal a terrible truth';'mark self for death';'randomly affect enemy team'",
        anim: "",
        help: "SELF::+3T:DESTABILIZE +2T:VULNERABLE +CRITICAL FLAW, FOES::AUTOHIT ONE OF (+3T:STUN, +4T:DESTABILIZED +4T:OPEN WOUND, +4T:FEAR +MADNESS)\nSPECIAL::25% CHANCE TO REDUCE FOE HP BY 75%",
        usage: {
            act: "%USER DRAWS JUSTICE"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkfairy", 0.25)
            addStatus({target: user, status: "destabilized", length: 3});
            addStatus({target: user, status: "vulnerable", length: 2});
			addStatus({target: user, status: "critical_flaw", length: 1});


            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
                    let rand = Math.random()
                    if(rand < 0.3) {
                        play("talkfairy", 1)
                        addStatus({target: actor, origin: user, status: "destabilized", length: 4});
						addStatus({target: actor, origin: user, status: "open_wound", length: 4});
                        
                    } else if(rand < 0.6) {
                        play("fear", 0.5)
                        addStatus({target: actor, origin: user, status: "fear", length: 4}); 
						addStatus({target: actor, origin: user, status: "madness", length: 1});
                    } else {
                        play("fear", 1)
                        addStatus({target: actor, origin: user, status: "stun", length: 3}); 
                    }

                    if(Math.random() < 0.25) {
                        
                        sendFloater({
                            target: actor,
                            type: "arbitrary",
                            specialClass: "fate",
                            arbitraryString: "REPENT",
                            size: 2
                        })
                        
                        actor.hp = Math.floor(actor.hp * 0.25)

                        //special handling for weird hp usage
                        let conjoin = actor.statusEffects.find(status=>status.slug == "conjoined")
                        if(conjoin) conjoin.events.onCombatHit();
                        updateStats({actor})
                    }
                },
                
                advanceAfterExec: true, beingUsedAsync, user,
                endCallback: ()=>{console.log('just called advance')}
            })
        }
    },
	
	env.ACTIONS.tarot_justice_reversed = {
        slug: "tarot_justice_reversed",
        name: "TAROT:: Justice, Reversed",
        type: 'special',
        desc: "'affect all thoughtforms with incoherence'",
        help: "ALL::BENEFICIAL STATUS INVERSION",
        anim: "wobble",
        autohit: true,
        canCrit: false,
        exec: function(user, target, beingUsedAsync) {
            actionMessage(user, "%USER DRAWS JUSTICE, REVERSED", target);
            
            if(env.rpg.classList.contains("bastard")) {                
                if(user.team.name == "ally") {
                    env.rpg.classList.add('incoherentbg')
                    content.classList.add('painprep', 'painfade', 'painhalf')
                    setTimeout(()=>{content.classList.add('painmode')}, 100)
                    setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                    setTimeout(()=>{content.classList.remove('painprep', 'painfade', 'painhalf')}, 5000)

                    setTimeout(()=>{env.rpg.classList.remove('incoherentbg')}, 4000)
                }
            } else {
                ratween(env.bgm, 1, 2000)
                env.rpg.classList.add('incoherentbg')
                content.classList.add('painprep', 'painhalf')
                setTimeout(()=>{content.classList.add('painmode')}, 100)
                setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                setTimeout(()=>{content.classList.remove('painprep', 'painhalf')}, 5000)
            }
            
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        autohit: true,
                        hitSfx: {
                            name: 'talkfairy',
                            rate: 0.5
                        },
                        genExec: ({target}) => {
                            invertStatuses(actor, (statusObj)=>statusObj.beneficial)
                        }
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_thehangedman = { //beneficial card
        slug: "tarot_thehangedman",
        name: "TAROT:: The Hanged Man",
        type: 'special',
        desc: "'intercept all attacks on allies';'prepare to take great damage'",
        help: "ALLIES::+4T:REDIRECTION (TO USER), SELF::+2T:CARAPACE +2T:SPIKES +SACRIFICE -VULNERABLE",
        anim: "basic-attack",
        accuracy: 1,
        crit: 0,
        usage: {
            act: "%USER DRAWS THE HANGED MAN"
        },
        exec: function(user, target, beingUsedAsync) {
            reactDialogue(user, `give_redirection`)

            addStatus({target: user, status: "carapace", length: 2, noReact: true}); 
            addStatus({target: user, status: "spikes", length: 2, noReact: true}); 
			addStatus({target: user, status: "sacrifice", length: 1, noReact: true}); 
            removeStatus(user, "vulnerable") 

            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
                    if(actor.slug == user.slug) return
                    addStatus({target: actor, origin: user, status: "redirection", length: 4}); 
                    play('guard', 2, 0.75);
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_thehangedman_reversed = { //beneficial card
        slug: "tarot_thehangedman_reversed",
        name: "TAROT:: The Hanged Man, Reversed",
        type: 'special',
        desc: "'extend self beyond limits';'spend own health for total destruction'",
        help: "SELF::+2T:DESTABILIZED +1T:VULNERABLE\nFOES::100% SPECIAL\nSPECIAL::REDUCE USER HP TO 1, DEALING 200% LOST HP AS DAMAGE SPLIT OVER LIVING FOES (MIN:1)",
        anim: "basic-attack",
        usage: {
            act: "%USER DRAWS THE HANGED MAN, REVERSED"
        },
        accuracy: 1,
        crit: 0,
        amt: 0,
        exec: function(user, target, beingUsedAsync) {
            let action = this
            let living = user.enemyTeam.members.reduce((acc, mem) => acc + (mem.state != "dead" ? 1 : 0), 0)
            let hpAmt = user.hp - 1
            let splitAmt = Math.max(Math.floor((hpAmt * 2) / living), 1)

            user.hp = 1
            addStatus({target: user, status: "destabilized", length: 2, noReact: true})
			addStatus({target: user, status: "vulnerable", length: 1, noReact: true})

            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
                    let anim = env.COMBAT_ANIMS.shoot
                    let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
                    let animDelay = baseDelay + anim.duration * 0.5;
                        
                    setTimeout(()=>anim.exec(action, user, actor), baseDelay)
                    setTimeout(function(){
                        env.GENERIC_ACTIONS.singleTarget({
                            action, 
                            user, 
                            target: actor,
                            hitSfx: { name: 'shot2' },
                            specialAmt: splitAmt
                        })
                    }, animDelay);
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        },
    }, 
	
	env.ACTIONS.tarot_death = {
        slug: "tarot_death",
        name: "TAROT:: Death",
        type: 'special',
        desc: "'affect all thoughtforms with incoherence'",
        help: "ALL::100% -3HP +2T:DESTABILIZED +2T:FEAR, 30%C x2",
        anim: "wobble",
        accuracy: 1,
        crit: 0.3,
		amt: 3,
        exec: function(user, target, beingUsedAsync) {
            actionMessage(user, "%USER DRAWS DEATH", target);
            
            if(env.rpg.classList.contains("bastard")) {                
                if(user.team.name == "ally") {
                    env.rpg.classList.add('incoherentbg')
                    content.classList.add('painprep', 'painfade', 'painhalf')
                    setTimeout(()=>{content.classList.add('painmode')}, 100)
                    setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                    setTimeout(()=>{content.classList.remove('painprep', 'painfade', 'painhalf')}, 5000)

                    setTimeout(()=>{env.rpg.classList.remove('incoherentbg')}, 4000)
                }
            } else {
                ratween(env.bgm, 1, 2000)
                env.rpg.classList.add('incoherentbg')
                content.classList.add('painprep', 'painhalf')
                setTimeout(()=>{content.classList.add('painmode')}, 100)
                setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                setTimeout(()=>{content.classList.remove('painprep', 'painhalf')}, 5000)
            }
            
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'dull',
                            rate: 0.75
                        },
                        hitExec: ({target}) => {
                            addStatus({target: actor, origin: user, status: "destabilized", length: 2});
							addStatus({target: actor, origin: user, status: "fear", length: 2});
                        }
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_death_reversed = {
        slug: "tarot_death_reversed",
        name: "TAROT:: Death, Reversed",
        type: 'special',
        desc: "'affect all thoughtforms with incoherence'",
        help: "ALL::90% -2HP +2T:WEAKENED +2T:FEAR +5T:ROT, 20%C x2 +2T:WEAKENED +2T:FEAR +5T:ROT +1T:STUN",
        anim: "wobble",
        accuracy: 1,
        crit: 0.3,
		amt: 3,
        exec: function(user, target, beingUsedAsync) {
            actionMessage(user, "%USER DRAWS DEATH, REVERSED", target);
            
            if(env.rpg.classList.contains("bastard")) {                
                if(user.team.name == "ally") {
                    env.rpg.classList.add('incoherentbg')
                    content.classList.add('painprep', 'painfade', 'painhalf')
                    setTimeout(()=>{content.classList.add('painmode')}, 100)
                    setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                    setTimeout(()=>{content.classList.remove('painprep', 'painfade', 'painhalf')}, 5000)

                    setTimeout(()=>{env.rpg.classList.remove('incoherentbg')}, 4000)
                }
            } else {
                ratween(env.bgm, 1, 2000)
                env.rpg.classList.add('incoherentbg')
                content.classList.add('painprep', 'painhalf')
                setTimeout(()=>{content.classList.add('painmode')}, 100)
                setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                setTimeout(()=>{content.classList.remove('painprep', 'painhalf')}, 5000)
            }
            
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'talksignal',
                            rate: 0.75
                        },
                        hitExec: ({target}) => {
                            addStatus({target: actor, origin: user, status: "weakened", length: 2});
							addStatus({target: actor, origin: user, status: "fear", length: 2});
							addStatus({target: actor, origin: user, status: "rot", length: 5});
                        },
						critExec: ({target}) => {
							addStatus({target: actor, origin: user, status: "weakened", length: 2});
							addStatus({target: actor, origin: user, status: "fear", length: 2});
							addStatus({target: actor, origin: user, status: "rot", length: 5});
							addStatus({target: actor, origin: user, status: "stun", length: 1});
						}
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_temperance = { //beneficial
        slug: "tarot_temperance",
        name: "TAROT:: Temperance",
        type: 'special',
        desc: "'reveal a terrible truth';'mark self for death';'randomly affect enemy team'",
        anim: "",
        help: "FOES::SET HP TO HALF OF MAX HP",
        usage: {
            act: "%USER DRAWS TEMPERANCE"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {

            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
                        play('talkchoir', 0.5)
                        sendFloater({
                            target: actor,
                            type: "arbitrary",
                            specialClass: "fate",
                            arbitraryString: "PATIENCE",
                            size: 2
                        })
                        
                        actor.hp = Math.floor(actor.maxhp * 0.5)

                        //special handling for weird hp usage
                        let conjoin = actor.statusEffects.find(status=>status.slug == "player_conjoined")
                        if(conjoin) conjoin.events.onCombatHit();
                        updateStats({actor})
                },
                advanceAfterExec: true, beingUsedAsync, user,
                endCallback: ()=>{console.log('just called advance')}
            })
        }
    },
	
	env.ACTIONS.tarot_temperance_reversed = {
        slug: "tarot_temperance_reversed",
        name: "TAROT:: Temperance, Reversed",
        type: 'special',
        desc: "'affect all thoughtforms with incoherence'",
        help: "ALL::REDUCE ACTOR HP BY 75%",
        anim: "wobble",
        autohit: true,
        canCrit: false,
        exec: function(user, target, beingUsedAsync) {
            actionMessage(user, "%USER DRAWS TEMPERANCE, REVERSED", target);
            
            if(env.rpg.classList.contains("bastard")) {                
                if(user.team.name == "ally") {
                    env.rpg.classList.add('incoherentbg')
                    content.classList.add('painprep', 'painfade', 'painhalf')
                    setTimeout(()=>{content.classList.add('painmode')}, 100)
                    setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                    setTimeout(()=>{content.classList.remove('painprep', 'painfade', 'painhalf')}, 5000)

                    setTimeout(()=>{env.rpg.classList.remove('incoherentbg')}, 4000)
                }
            } else {
                ratween(env.bgm, 1, 2000)
                env.rpg.classList.add('incoherentbg')
                content.classList.add('painprep', 'painhalf')
                setTimeout(()=>{content.classList.add('painmode')}, 100)
                setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                setTimeout(()=>{content.classList.remove('painprep', 'painhalf')}, 5000)
            }
            
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        autohit: true,
                        hitSfx: {
                            name: 'talkfairy',
                            rate: 0.25
                        },
                        genExec: ({target}) => {
                            sendFloater({
                            target: actor,
                            type: "arbitrary",
                            specialClass: "fate",
                            arbitraryString: "REPENT",
                            size: 2
                        })
                        
                        actor.hp = Math.floor(actor.hp * 0.25)

                        //special handling for weird hp usage
                        let conjoin = actor.statusEffects.find(status=>status.slug == "conjoined")
                        if(conjoin) conjoin.events.onCombatHit();
                        updateStats({actor})
                        }
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_thedevil = { //beneficial card
        slug: "tarot_thedevil",
        name: "TAROT:: The Devil",
        type: 'special',
        desc: "'receive prophetic visions to bless allies';'incite divine intervention against foes'",
        help: "FOES:: +2T:VULNERABLE, +1T:STUN, ALLIES:: +2T:FOCUSED +SURGE",
        anim: "",
        autohit: true,
        usage: {
            act: "%USER DRAWS THE DEVIL"
        },
        exec: function(user, target, beingUsedAsync) {
			if(user.slug.includes("critta_impetus")) {
				advanceTurn(user)
				console.log(`we actually can't let imps draw the devil sorrgy`)
			} else {
            let action = this
            let allyTeam = user.team.name
            let enemyTeam = user.enemyTeam.name

				env.GENERIC_ACTIONS.teamWave({
					arbitraryActorList: env.rpg.turnOrder,
					advanceAfterExec: true, beingUsedAsync, user,
					exec: (actor) => {

						switch(actor.team.name) {
							case allyTeam:
								env.GENERIC_ACTIONS.singleTarget({
									beneficial: true,
									action, 
									user, 
									target: actor,
									canCrit: false,
									hitSfx: {
										name: "talkchoir7",
										rate: 2
									},
									hitExec: ()=> {
										addStatus({target: actor, origin: user, status: "focused", origin: user, length: 2});
										addStatus({target: actor, origin: user, status: "surge", origin: user, length: 1});
									}
								})
							break

							case enemyTeam:
								env.GENERIC_ACTIONS.singleTarget({
									action, 
									user, 
									target: actor,
									canCrit: false,
									hitSfx: {
										name: "talkfairy",
										rate: 0.5
									},
									hitExec: ()=> {
										addStatus({target: actor, origin: user, status: "vulnerable", origin: user, length: 2});
										addStatus({target: actor, origin: user, status: "stun", origin: user, length: 1});
									}
								})                            
							break
						}
					},
					advanceAfterExec: true, beingUsedAsync, user,
				})
			}
        }
    },
	
    env.ACTIONS.tarot_thedevil_reversed = { //beneficial card
        slug: "tarot_thedevil_reversed",
        name: "TAROT:: The Devil, Reversed",
        type: 'special',
        desc: "'wide directional release of rapidly decaying dull light';'deconstructs foes'",
        help: "SELF::+INCOHERENT, FOES::AUTOHIT -4HP 20%C x2 +1T:STUN",
        anim: "basic-attack",
        autohit: true,
        crit: 0.2,
        amt: 4,
        usage: {
            act: "%USER DRAWS THE DEVIl, REVERSED"
        },
        exec: function(user, target, beingUsedAsync) {
            addStatus({target: user, status: "incoherent", length: 1, noReact: true})
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
                    let anim = env.COMBAT_ANIMS.flare
                    let baseDelay = ((env.ADVANCE_RATE * 0.2) * i)
                    let animDelay = baseDelay + anim.duration;
                        
                    setTimeout(()=>anim.exec(action, user, actor), baseDelay)
                    setTimeout(function(){
                        env.GENERIC_ACTIONS.singleTarget({
                            beneficial: true,
                            action: action, 
                            user, 
                            target: actor,
                            hitSfx: { name: 'shot6', rate: 1.5 },
                            critSfx: { name: 'shot6', rate: 0.75 },
							critStatus: {
								name: 'stun',
								length: 1
							},
                        })
                    }, animDelay);
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_thetower = {
        slug: "tarot_thetower",
        name: "TAROT:: The Tower",
        type: 'special',
        desc: "'affect all thoughtforms with incoherence'",
        help: "ALL::100% -1HP +3T:FEAR +3T:PUNCTURE +3T:VULNERABLE +AMPLIFIER, 10%C x2",
        anim: "wobble",
        accuracy: 1,
        crit: 0.3,
		amt: 1,
        exec: function(user, target, beingUsedAsync) {
            actionMessage(user, "%USER DRAWS THE TOWER", target);
            
            if(env.rpg.classList.contains("bastard")) {                
                if(user.team.name == "ally") {
                    env.rpg.classList.add('incoherentbg')
                    content.classList.add('painprep', 'painfade', 'painhalf')
                    setTimeout(()=>{content.classList.add('painmode')}, 100)
                    setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                    setTimeout(()=>{content.classList.remove('painprep', 'painfade', 'painhalf')}, 5000)

                    setTimeout(()=>{env.rpg.classList.remove('incoherentbg')}, 4000)
                }
            } else {
                ratween(env.bgm, 1, 2000)
                env.rpg.classList.add('incoherentbg')
                content.classList.add('painprep', 'painhalf')
                setTimeout(()=>{content.classList.add('painmode')}, 100)
                setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                setTimeout(()=>{content.classList.remove('painprep', 'painhalf')}, 5000)
            }
            
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'talksignal',
                            rate: 0.75
                        },
                        hitExec: ({target}) => {
							addStatus({target: actor, origin: user, status: "fear", length: 3});
							addStatus({target: actor, origin: user, status: "puncture", length: 3});
							addStatus({target: actor, origin: user, status: "vulnerable", length: 3});
							addStatus({target: actor, origin: user, status: "hands_malfunction", length: 1});
                        }
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_thetower_reversed = {
        slug: "tarot_thetower_reversed",
        name: "TAROT:: The Tower, Reversed",
        type: 'special',
        desc: "'affect all thoughtforms with incoherence'",
        help: "ALL::100% +1HP +2T:FOCUSED +2T:REGEN +2T:EVASION 10%C x2",
        anim: "wobble",
        accuracy: 1,
        crit: 0.3,
		amt: -1,
        exec: function(user, target, beingUsedAsync) {
            actionMessage(user, "%USER DRAWS THE TOWER, REVERSED", target);
            
            if(env.rpg.classList.contains("bastard")) {                
                if(user.team.name == "ally") {
                    env.rpg.classList.add('incoherentbg')
                    content.classList.add('painprep', 'painfade', 'painhalf')
                    setTimeout(()=>{content.classList.add('painmode')}, 100)
                    setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                    setTimeout(()=>{content.classList.remove('painprep', 'painfade', 'painhalf')}, 5000)

                    setTimeout(()=>{env.rpg.classList.remove('incoherentbg')}, 4000)
                }
            } else {
                ratween(env.bgm, 1, 2000)
                env.rpg.classList.add('incoherentbg')
                content.classList.add('painprep', 'painhalf')
                setTimeout(()=>{content.classList.add('painmode')}, 100)
                setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                setTimeout(()=>{content.classList.remove('painprep', 'painhalf')}, 5000)
            }
            
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'talkflower',
                            rate: 0.75
                        },
                        hitExec: ({target}) => {
							addStatus({target: actor, origin: user, status: "focused", length: 2});
							addStatus({target: actor, origin: user, status: "regen", length: 2});
							addStatus({target: actor, origin: user, status: "evasion", length: 2});
                        }
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_thestar = { //beneficial card
        slug: "tarot_thestar",
        name: "TAROT:: The Star",
        type: 'self+autohit+support',
        desc: "'back off';'focus entire team'",
        anim: "",
        help: "ALLIES::AUTOHIT +3HP +2T:REGEN +5T:FAVORED +CHOSEN",
        usage: {
            act: "%USER DRAWS THE STAR"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkchoir7", 2)


            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i)=>{
					combatHit(actor, {amt: -3, origin: user, autohit: true, beneficial: true});
					addStatus({target: actor, origin: user, status: "regen", origin: user, length: 2}); 
                    addStatus({target: actor, origin: user, status: "favored", origin: user, length: 5, noReact: true}); 
					addStatus({target: actor, origin: user, status: "chosen", origin: user, length: 1, noReact: true});
                    play('talkflower', 1);
                },
				advanceAfterExec: true, beingUsedAsync, user,
            })

            return 'nothing'
        }
    },
	
	env.ACTIONS.tarot_thestar_reversed = { //beneficial card
        slug: "tarot_thestar_reversed",
        name: "TAROT:: The Star, Reversed",
        type: 'self+autohit+support',
        desc: "'back off';'focus entire team'",
        anim: "",
        help: "FOES::AUTOHIT -3HP +2T:PUNCTURE +5T:CURSED +FORSAKEN",
        usage: {
            act: "%USER DRAWS THE STAR, REVERSED"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkfairy", 2)


            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
					combatHit(actor, {amt: 3, origin: user, autohit: true, beneficial: false});
					addStatus({target: actor, origin: user, status: "puncture", origin: user, length: 2}); 
                    addStatus({target: actor, origin: user, status: "cursed", origin: user, length: 5, noReact: true}); 
					addStatus({target: actor, origin: user, status: "forsaken", origin: user, length: 1, noReact: true});
                    play('talkfairy', 1);
                },
				advanceAfterExec: true, beingUsedAsync, user,
            })

            return 'nothing'
        }
    },
	
	env.ACTIONS.tarot_themoon = { //beneficial card
		slug: "tarot_themoon",
		name: "TAROT:: The Moon",
		type: 'special+summon+nomimic',
		desc: "'collect additional allies from elsewhere'",
		help: "SUMMON::6 HALLUCINATIONS (MAX: 12 SUMMONS)\nALLIES::+3T:FAVORED",
		anim: "heal",
		accuracy: 1,
		crit: 0,
		itemAction: true, //we have to lie here so that imps can't use this action
		noRepeat: true,
		exec: function(user, target, beingUsedAsync) {
			actionMessage(user, "%USER DRAWS THE MOON", target, 'none', 2000);
			play('dull', 0.8, 1);
			
			//try to center the dude
			if(user.team.members.length == 14) {
				let uI = user.team.members.findIndex(a => a.slug == user.slug)
				if(uI < 14) midCombatAllyAdd('player_hallucination', 'left')
				else if(uI >= 14) midCombatAllyAdd('player_hallucination', 'right')
			} else {
				midCombatAllyAdd('player_hallucination', 'left')
				midCombatAllyAdd('player_hallucination', 'left')
				midCombatAllyAdd('player_hallucination', 'left')
				midCombatAllyAdd('player_hallucination', 'right')
				midCombatAllyAdd('player_hallucination', 'right')
				midCombatAllyAdd('player_hallucination', 'right')
			}
			setTimeout(()=>{             
				env.GENERIC_ACTIONS.teamWave({
						team: user.team,
						exec: (actor, i)=>{
							addStatus({target: actor, origin: user, status: "favored", origin: user, length: 3, noReact: true}); 
							play('mend', 0.5);
						}
					})
				}, env.ADVANCE_RATE * 0.5)
			setTimeout(()=>advanceTurn(user), 1000)
		},
		disableIf: (actor) => {if(actor.team.members.length > 15) return "TOO MANY ALLIES" }
	}
	
	env.ACTIONS.tarot_themoon_noadvance = { //beneficial card
		slug: "tarot_themoon_noadvance",
		name: "TAROT:: The Moon",
		type: 'special+summon+nomimic',
		desc: "'collect additional allies from elsewhere'",
		help: "SUMMON::6 HALLUCINATIONS (MAX: 12 SUMMONS)\nALLIES::+3T:FAVORED",
		anim: "heal",
		accuracy: 1,
		crit: 0,
		itemAction: true, //we have to lie here so that imps can't use this action
		noRepeat: true,
		exec: function(user, target, beingUsedAsync) {
			actionMessage(user, "%USER DRAWS THE MOON", target, 'none', 2000);
			play('dull', 0.8, 1);
			
			//try to center the dude
			if(user.team.members.length == 14) {
				let uI = user.team.members.findIndex(a => a.slug == user.slug)
				if(uI < 14) midCombatAllyAdd('player_hallucination', 'left')
				else if(uI >= 14) midCombatAllyAdd('player_hallucination', 'right')
			} else {
				midCombatAllyAdd('player_hallucination', 'left')
				midCombatAllyAdd('player_hallucination', 'left')
				midCombatAllyAdd('player_hallucination', 'left')
				midCombatAllyAdd('player_hallucination', 'right')
				midCombatAllyAdd('player_hallucination', 'right')
				midCombatAllyAdd('player_hallucination', 'right')
			}
			setTimeout(()=>{             
				env.GENERIC_ACTIONS.teamWave({
						team: user.team,
						exec: (actor, i)=>{
							addStatus({target: actor, origin: user, status: "favored", origin: user, length: 3, noReact: true}); 
							play('mend', 0.5);
						}
					})
				}, env.ADVANCE_RATE * 0.5)
		},
		disableIf: (actor) => {if(actor.team.members.length > 15) return "TOO MANY ALLIES" }
	}
	
	env.ACTIONS.tarot_themoon_reversed = {
        slug: "tarot_themoon_reversed",
        name: "TAROT:: The Moon, Reversed",
        type: 'special',
        desc: "'affect all thoughtforms with incoherence'",
        help: "ALL::AUTOHIT +2T:FEAR, +MADNESS +SURGE",
        anim: "wobble",
        autohit: true,
        canCrit: false,
        exec: function(user, target, beingUsedAsync) {
            actionMessage(user, "%USER DRAWS THE MOON, REVERSED", target);
            
            if(env.rpg.classList.contains("bastard")) {                
                if(user.team.name == "ally") {
                    env.rpg.classList.add('incoherentbg')
                    content.classList.add('painprep', 'painfade', 'painhalf')
                    setTimeout(()=>{content.classList.add('painmode')}, 100)
                    setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                    setTimeout(()=>{content.classList.remove('painprep', 'painfade', 'painhalf')}, 5000)

                    setTimeout(()=>{env.rpg.classList.remove('incoherentbg')}, 4000)
                }
            } else {
                ratween(env.bgm, 1, 2000)
                env.rpg.classList.add('incoherentbg')
                content.classList.add('painprep', 'painhalf')
                setTimeout(()=>{content.classList.add('painmode')}, 100)
                setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                setTimeout(()=>{content.classList.remove('painprep', 'painhalf')}, 5000)
            }
            
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        autohit: true,
                        hitSfx: {
                            name: 'fear',
                            rate: 0.75
                        },
                        genExec: ({target}) => {
                            addStatus({target: actor, origin: user, status: "surge", length: 1});
							addStatus({target: actor, origin: user, status: "fear", length: 2});
							addStatus({target: actor, origin: user, status: "madness", length: 1});
                        }
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_thesun = { //beneficial card
        slug: "tarot_thesun",
        name: "TAROT:: The Sun",
        type: 'self+autohit+support',
        desc: "'back off';'focus entire team'",
        anim: "",
        help: "ALLIES::+3T:FOCUSED +JOY",
        usage: {
            act: "%USER DRAWS THE SUN"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkflower", 1)

            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "focused", origin: user, length: 3, noReact: true});
					addStatus({target: actor, origin: user, status: "joy", origin: user, length: 1, noReact: true}); 					
                    play('talkflower', 1, 0.8);
                },
				advanceAfterExec: true, beingUsedAsync, user,
            })

            return 'nothing'
        }
    },
	
	env.ACTIONS.tarot_thesun_reversed = { //beneficial card
        slug: "tarot_thesun_reversed",
        name: "TAROT:: The Sun, Reversed",
        type: 'self+autohit+support',
        desc: "'back off';'focus entire team'",
        anim: "",
        help: "FOES::+3T:FEAR +DESPAIR",
        usage: {
            act: "%USER DRAWS THE SUN, REVERSED"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkfairy", 1)

            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "fear", origin: user, length: 3, noReact: true});
					addStatus({target: actor, origin: user, status: "despair_malfunction", origin: user, length: 1, noReact: true}); 					
                    play('talkfairy', 0.5, 0.35);
                },
				advanceAfterExec: true, beingUsedAsync, user,
            })

            return 'nothing'
        }
    },
	
	env.ACTIONS.tarot_judgement = {
        slug: "tarot_judgement",
        name: "TAROT:: Judgement",
        type: 'special',
        desc: "'grasp the nature of this place';'recognize and exploit framing device'",
        anim: "wobble",
        help: "ALL::+3T:EMPOWERED -DOWN",
        usage: {
            act: "%USER DRAWS JUDGEMENT"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkchoir7", 1.5)
            let action = this
            
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'mend',
                            rate: 0.5
                        },
                        genExec: ({target}) => {
							addStatus({target, origin: user, status: "empowered", origin: user, length: 3, noReact:true});
							if(target.state == "dead") {
								target.hp = Math.floor(target.maxhp * 0.25)
								combatRevive(target)
								reactDialogue(target, 'receive_rez')
							}
						}
					})
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_judgement_reversed = {
        slug: "tarot_judgement_reversed",
        name: "TAROT:: Judgement, Reversed",
        type: 'special',
        desc: "'affect all thoughtforms with incoherence'",
        help: "ALL::AUTOHIT +3T:WEAKENED +3T:CURSED",
        anim: "wobble",
        autohit: true,
        canCrit: false,
        exec: function(user, target, beingUsedAsync) {
            actionMessage(user, "%USER DRAWS JUDGEMENT, REVERSED", target);
            
            if(env.rpg.classList.contains("bastard")) {                
                if(user.team.name == "ally") {
                    env.rpg.classList.add('incoherentbg')
                    content.classList.add('painprep', 'painfade', 'painhalf')
                    setTimeout(()=>{content.classList.add('painmode')}, 100)
                    setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                    setTimeout(()=>{content.classList.remove('painprep', 'painfade', 'painhalf')}, 5000)

                    setTimeout(()=>{env.rpg.classList.remove('incoherentbg')}, 4000)
                }
            } else {
                ratween(env.bgm, 1, 2000)
                env.rpg.classList.add('incoherentbg')
                content.classList.add('painprep', 'painhalf')
                setTimeout(()=>{content.classList.add('painmode')}, 100)
                setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                setTimeout(()=>{content.classList.remove('painprep', 'painhalf')}, 5000)
            }
            
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        autohit: true,
                        hitSfx: {
                            name: 'talkcroak',
                            rate: 0.75
                        },
                        genExec: ({target}) => {
							addStatus({target: actor, origin: user, status: "weakened", length: 3});
							addStatus({target: actor, origin: user, status: "cursed", length: 3});
                        }
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.tarot_theworld = { //beneficial card
        slug: "tarot_theworld",
        name: "TAROT:: The World",
        type: 'self+autohit+support',
        desc: "'back off';'focus entire team'",
        anim: "",
        help: "ALLIES::+2T:FOCUSED +2T:FAVORED +INFALLIBLE +JOY +CHOSEN",
        usage: {
            act: "%USER DRAWS THE WORLD"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkchoir7", 2)

            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "focused", origin: user, length: 2, noReact: true}); 
					addStatus({target: actor, origin: user, status: "favored", origin: user, length: 2, noReact: true}); 
					addStatus({target: actor, origin: user, status: "infallible", origin: user, length: 1, noReact: true}); 
					addStatus({target: actor, origin: user, status: "joy", origin: user, length: 1, noReact: true}); 
					addStatus({target: actor, origin: user, status: "chosen", origin: user, length: 1, noReact: true}); 
                    play('talkflower', 0.75);
                },
				advanceAfterExec: true, beingUsedAsync, user,
            })

            return 'nothing'
        }
    },
	
	env.ACTIONS.tarot_theworld_reversed = {
        slug: "tarot_theworld_reversed",
        name: "TAROT:: The World, Reversed",
        type: 'self+autohit+support',
        desc: "'back off';'focus entire team'",
        anim: "",
        help: "ALLIES::SWAP REMAINING HP FOR LOST HP",
        usage: {
            act: "%USER DRAWS THE WORLD, REVERSED"
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkfairy", 0.25)

            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i)=>{
							sendFloater({
                            target: actor,
                            type: "arbitrary",
                            specialClass: "fate",
                            arbitraryString: "PERISH",
                            size: 2
                        })

                        if(actor.hp == actor.maxhp) { actor.hp = 1 } // safeguard to not kill maxxed out teams (turns out having a ~2% chance of nigh guarenteed death feels unfair :P oops)
                        else { actor.hp = -(actor.hp - actor.maxhp) }

                        //special handling for weird hp usage
                        let conjoin = actor.statusEffects.find(status=>status.slug == "conjoined")
                        if(conjoin) conjoin.events.onCombatHit();
                        updateStats({actor})
                    play('talkfairy', 0.25);
                },
				advanceAfterExec: true, beingUsedAsync, user,
            })

            return 'nothing'
        }
    },
	
		//hands utility augment
	env.ACTIONS.special_tarot = {
		slug: "special_tarot",
		name: "Tarot",
		type: 'special',
		desc: "'draw card from deck';'reap consequences'",
		help: "SELF/ALLIES/FOES/ALL:: 100% RANDOM SPECIAL EFFECT",
		anim: "heal",
		autohit: true,
		canCrit: false,
		usage: {
			act: "%USER CONSIDERS THE DECK CAREFULLY"
		},
		details: {
            flavor: "'draw card from deck';'reap consequences'",
			onUse: "'inflict random effect upon one of following';'self';'all allies';'all foes';'all actors'"
        },
        stats: {
            autohit: true,
            canCrit: false,
        },
		exec: function(user, target){
			setTimeout(()=>{
				let power = 0
				let fated = user.statusEffects.find(status => status.slug == "fated_hands")
				let rand = Math.random()
				
				let majorArcana = ['tarot_thefool','tarot_thefool_reversed','tarot_themagician','tarot_themagician_reversed','tarot_thehighpriestess','tarot_thehighpriestess_reversed','tarot_theempress','tarot_theempress_reversed','tarot_theemperor','tarot_theemperor_reversed','tarot_thehierophant','tarot_thehierophant_reversed','tarot_thelovers','tarot_thelovers_reversed','tarot_thechariot','tarot_thechariot_reversed','tarot_strength','tarot_strength_reversed','tarot_thehermit','tarot_thehermit_reversed','tarot_thewheeloffortune','tarot_thewheeloffortune_reversed','tarot_justice','tarot_justice_reversed','tarot_thehangedman','tarot_thehangedman_reversed','tarot_death','tarot_death_reversed','tarot_temperance','tarot_temperance_reversed','tarot_thedevil','tarot_thedevil_reversed','tarot_thetower','tarot_thetower_reversed','tarot_thestar','tarot_thestar_reversed','tarot_themoon','tarot_themoon_reversed','tarot_thesun','tarot_thesun_reversed','tarot_judgement','tarot_judgement_reversed','tarot_theworld','tarot_theworld_reversed']
				if (rand > (1 - (fated ? fated.power * 0.1 : 0))) {
					majorArcana = ['tarot_themagician','tarot_thehighpriestess','tarot_thehighpriestess_reversed','tarot_theempress','tarot_theempress_reversed','tarot_theemperor','tarot_theemperor_reversed','tarot_thehierophant','tarot_thechariot','tarot_strength','tarot_strength_reversed','tarot_thehermit','tarot_thewheeloffortune','tarot_justice','tarot_thehangedman','tarot_thehangedman_reversed','tarot_thedevil','tarot_thedevil_reversed','tarot_thestar','tarot_thestar_reversed','tarot_themoon','tarot_thesun','tarot_thesun_reversed','tarot_theworld']
				}
				let chosenCard = majorArcana.sample()
				useAction(user, env.ACTIONS[chosenCard], target, {beingUsedAsync: false, reason: "tarot"})
				},
			env.ADVANCE_RATE * 1)
		}
	}
	
	env.ACTIONS.special_tarot_noadvance = {
		slug: "special_tarot_noadvance",
		name: "Tarot",
		type: 'special',
		desc: "'draw card from deck';'reap consequences'",
		help: "SELF/ALLIES/FOES/ALL:: 100% RANDOM SPECIAL EFFECT",
		anim: "heal",
		autohit: true,
		canCrit: false,
		usage: {
			act: "%USER CONSIDERS THE DECK CAREFULLY"
		},
		exec: function(user, target){
			setTimeout(()=>{
				let power = 0
				let fated = user.statusEffects.find(status => status.slug == "fated_hands")
				let rand = Math.random()
				
				let majorArcana = ['tarot_thefool','tarot_thefool_reversed','tarot_themagician_noadvance','tarot_themagician_reversed','tarot_thehighpriestess','tarot_thehighpriestess_reversed','tarot_theempress','tarot_theempress_reversed','tarot_theemperor','tarot_theemperor_reversed','tarot_thehierophant_noadvance','tarot_thehierophant_reversed','tarot_thelovers','tarot_thelovers_reversed','tarot_thechariot','tarot_thechariot_reversed','tarot_strength','tarot_strength_reversed_noadvance','tarot_thehermit','tarot_thehermit_reversed','tarot_thewheeloffortune','tarot_thewheeloffortune_reversed','tarot_justice','tarot_justice_reversed','tarot_thehangedman','tarot_thehangedman_reversed','tarot_death','tarot_death_reversed','tarot_temperance','tarot_temperance_reversed','tarot_thedevil','tarot_thedevil_reversed','tarot_thetower','tarot_thetower_reversed','tarot_thestar','tarot_thestar_reversed','tarot_themoon_noadvance','tarot_themoon_reversed','tarot_thesun','tarot_thesun_reversed','tarot_judgement','tarot_judgement_reversed','tarot_theworld','tarot_theworld_reversed']
				if (rand > (1 - (fated ? fated.power * 0.1 : 0))) {
					majorArcana = ['tarot_themagician_noadvance','tarot_thehighpriestess','tarot_thehighpriestess_reversed','tarot_theempress','tarot_theempress_reversed','tarot_theemperor','tarot_theemperor_reversed','tarot_thehierophant_noadvance','tarot_thechariot','tarot_strength','tarot_strength_reversed_noadvance','tarot_thehermit','tarot_thewheeloffortune','tarot_justice','tarot_thehangedman','tarot_thehangedman_reversed','tarot_thedevil','tarot_thedevil_reversed','tarot_thestar','tarot_thestar_reversed','tarot_themoon_noadvance','tarot_thesun','tarot_thesun_reversed','tarot_theworld']
				}
				let chosenCard = majorArcana.sample()
				useAction(user, env.ACTIONS[chosenCard], target, {beingUsedAsync: false, reason: "tarot"})
				},
			env.ADVANCE_RATE * 1)
		}
	}
	
	env.ACTIONS.special_player_handssummon = {
		slug: "special_player_handssummon",
		name: "Daemon Portal",
		type: 'special+summon+nomimic',
		desc: "'collect daemons from elsewhere'",
		help: "SUMMON DAEMONIC ALLY (MAX:4 DAEMONS)",
		usage: {
			act: "%USER BINDS A DAEMON TO THIS PLANE"
		},
		anim: "heal",
		accuracy: 1,
		crit: 0,
		itemAction: true, //we have to lie here so that imps can't use this action
		noRepeat: true,
		exec: function(user) {
			if(user.team.members.filter(m=>m.slug.includes('hands')).length > 4) {
				play('dull', 0.6);
				play('talkfairy', 0.5);

				let daemon_peasant = ['player_hands_critta_pawn','player_hands_critta_knight','player_hands_critta_bishop','player_hands_critta_rook']
				let daemon_royal = ['player_hands_critta_queen','player_hands_critta_king']
				let daemon_divine = ['player_hands_critta_dragon','player_hands_critta_unicorn','player_hands_critta_princess','player_hands_critta_princess_defensive','player_hands_critta_superknight']
				
				var newAllySlug = daemon_peasant.sample()
				var newAllySlug1 = daemon_royal.sample()
				var newAllySlug2 = daemon_divine.sample()

				//try to center the dude
				if(user.team.members.length == 14) {
					let uI = user.team.members.findIndex(a => a.slug == user.slug)
					if(uI < 3) midCombatAllyAdd('player_hands_critta_pawn', 'left')
					else if(uI >= 3) midCombatAllyAdd('player_hands_critta_pawn', 'right')	
				} else {
					let rand = Math.random()
					if (rand > 0.5) {
						let rand1 = Math.random()
						if (rand1 < 0.5) {
							midCombatAllyAdd(newAllySlug,'left')
						} 
						else if (rand1 < 0.8) {
							midCombatAllyAdd(newAllySlug1,'left')	
						}
						else {
							midCombatAllyAdd(newAllySlug2,'left')	
						}
					}
					else {
						let rand2 = Math.random()
						if (rand2 < 0.5) {
							midCombatAllyAdd(newAllySlug,'right')
						} 
						else if (rand2 < 0.8) {
							midCombatAllyAdd(newAllySlug1,'right')
						}
						else {
							midCombatAllyAdd(newAllySlug2,'right')
						}
					}
				}
				setTimeout(()=>advanceTurn(user), 200)
			}
		},
		disableIf: (actor) => {if(user.team.members.filter(m=>m.slug.includes('hands')).length < 4) return "TOO MANY ALLIES" }
	}
	//metal actions
		//metal secondary
	env.ACTIONS.metal_barrier = {
        slug: "metal_barrier",
        name: "Barrier",
        verb: "shield",
        type: 'support+target+self+autohit',
        desc: "'apply ablative corru layer';'chance to apply passive protection mechanism'",
        help: "AUTOHIT +2BP, 20%C +2BP ONE OF (+REPAIRS, +HARDENED, +CHITINOUS)",
        anim: "heal",
        usage: {
            act: "%USER SHIELDS %TARGET",
            crit: "%TARGET FEELS INVINCIBLE",
            hit: "%TARGET GAINS A THIN BARRIER",
            miss: "IT DOES NOT STICK"
        },
        autohit: true,
		canCrit: true,
		beneficial: true,
        details: {
            flavor: "apply ablative corru layer to target';'chance to apply passive protection mechanism'",
            onHit: "'[STAT::amtBP]'",
            onCrit: "'additional [STAT::amtBP]';'grant one of following';'[STATUS::repairs]';'[STATUS::hardened]';'[STATUS::chitinous]'",
        },
        stats: {
            crit: 0.2,
            amtBP: 2,
			status: {
				repairs: { name: 'repairs', length: 1 },
				hardened: { name: 'hardened', length: 1 },
				chitinous: { name: 'chitinous', length: 1 },
			},
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                beneficial: true,
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'mend',
                    rate: 1.5
                },
				critSfx: {
					name: 'guard',
					rate: 1.5
				},
				hitExec: ({target})=> {
					combatHit(target, {amt: 2, origin: user, autohit: true, beneficial: true, type: 'barrier'});
				},
				critExec: ({target})=> {
					combatHit(target, {amt: 2, origin: user, autohit: true, beneficial: true, type: 'barrier'});
					let rand = Math.random()
                    if(rand < 0.3) {
                        addStatus({target, origin: user, status: "repairs", origin: user, length: 1}); 
                        
                    } else if(rand < 0.6) {
                        addStatus({target, origin: user, status: "hardened", origin: user, length: 1}); 

                    } else {
                        addStatus({target, origin: user, status: "chitinous", origin: user, length: 1}); 
                    }
				}
            })
        }
    },
	
		//metal primary
	env.ACTIONS.salvage = {
		slug: "salvage",
		name: "Salvage",
		type: 'summon+target',
		anim: "basic-attack",
		usage: {
			act: "%USER GRASPS AT %TARGET",
			crit: "%USER FABRICATES A GOLEM",
			hit: "%TARGET IS STRUCK",
			miss: "%TARGET EVADES"
		},
		details: {
            flavor: "'utilize golem repair tool and attached drone';'chance to use micro-vat to fabricate golem'",
            onHit: "'[STAT::amt]'",
            onCrit: "'[STATUS::weakened]';'summon golem ally';'max::4 golems'",
        },
        stats: {
            accuracy: 0.8,
            crit: 0.1,
            amt: 1,
            status: {
                weakened: { name: 'weakened', length: 2 },
            },
        },
		exec: function(user, target) {
			let fated = user.statusEffects.find(status => status.slug == "fated_metal")
			return env.GENERIC_ACTIONS.singleTarget({
				action: this,
				user,
				target,
				critStatus: {
					name: 'weakened',
					length: 2
				},
				critExec: ({target}) => {
					if(user.team.name == "ally") {
						let metal_peasant = ['player_metal_basic_golem','player_metal_constructor_golem','player_metal_maintcloak','player_metal_pressure_golem','player_metal_surgeon_golem']
						let metal_royal = ['player_metal_archival_golem','player_metal_dull_golem']
						
						let newAllySlug = metal_peasant.sample()
						let newAllySlug1 = metal_royal.sample()
						
						let rand = Math.random()
						if (rand < 0.75) {
							user.lastSide = !user.lastSide
							if(user.team.members.filter(m=>m.slug.includes('metal')).length < (fated ? fated.power + 4 : 4)) {
								midCombatAllyAdd(newAllySlug, user.lastSide ? "left" : "right")
							}
						} else {
							user.lastSide = !user.lastSide
							if(user.team.members.filter(m=>m.slug.includes('metal')).length < (fated ? fated.power + 4 : 4)) {
								midCombatAllyAdd(newAllySlug1, user.lastSide ? "left" : "right")
							}
						}
					} else {
						let metal_peasant_enemy = ['metal_basic_golem','metal_constructor_golem','metal_maintcloak','metal_pressure_golem','metal_surgeon_golem']
						let metal_royal_enemy = ['metal_archival_golem','metal_dull_golem']
						
						let newEnemySlug = metal_peasant_enemy.sample()
						let newEnemySlug1 = metal_royal_enemy.sample()
						
						let rand = Math.random()
						if (rand < 0.75) {
							user.lastSide = !user.lastSide
							if(user.team.members.filter(m=>m.slug.includes('metal')).length < (fated ? fated.power + 4 : 4)) {
								midCombatEnemyAdd(newEnemySlug, user.lastSide ? "left" : "right")
							}
						} else {
							user.lastSide = !user.lastSide
							if(user.team.members.filter(m=>m.slug.includes('metal')).length < (fated ? fated.power + 4 : 4)) {
								midCombatEnemyAdd(newEnemySlug1, user.lastSide ? "left" : "right")
							}
						}
					}
				}
			})
		}
	},
		//metal primary augment
	env.ACTIONS.reforge = {
		slug: "reforge",
		name: "Reforge",
		type: 'summon+target+nomimic',
		desc: "'utilize golem repair tool and attached foundry vat';'use siphoned sfer to construct greater golem'",
		help: "100% -2HP, 10%C +3T:WEAKENED SUMMON::+1 GREATER GOLEM (MAX:4)",
		anim: "basic-attack",
		accuracy: 1,
		crit: 0.1,
		amt: 2,
		details: {
            flavor: "'utilize golem repair tool and attached foundry vat';'use siphoned sfer to construct greater golem'",
            onHit: "'[STAT::amt]'",
            onCrit: "'[STATUS::weakened]';'summon greater golem ally';'max::4 golems'"
        },
        stats: {
            accuracy: 1,
            crit: 0.1,
            amt: 2,
            status: {
                weakened: { name: 'weakened', length: 3 },
            }
        },
		//itemAction: true, //we have to lie here so that imps can't use this action
		usage: {
			act: "%USER GRASPS AT %TARGET",
			crit: "%USER CONSTRUCTS A MASSIVE GOLEM",
			hit: "%TARGET IS STRUCK",
			miss: "%TARGET EVADES"
		},
		exec: function(user, target) {
			let fated = user.statusEffects.find(status => status.slug == "fated_metal")
			removeStatus(user, "windup")
			return env.GENERIC_ACTIONS.singleTarget({
				action: this,
				user,
				target,
				critStatus: {
					name: 'weakened',
					length: 3
				},
				/*
				critExec: ({target}) => {
					
					let rand = Math.random()
					if (rand < 0.75) {
						user.lastSide = !user.lastSide
						if(user.team.members.filter(m=>m.slug.includes('metal')).length < (fated ? fated.power + 4 : 4)) {
							midCombatAllyAdd(newAllySlug, user.lastSide ? "left" : "right")
						}
					} else {
						user.lastSide = !user.lastSide
						if(user.team.members.filter(m=>m.slug.includes('metal')).length < (fated ? fated.power + 4 : 4)) {
							midCombatAllyAdd(newAllySlug1, user.lastSide ? "left" : "right")
						}
					}
				}
				*/
				critExec: ({target}) => {
				let metal_peasant = ['player_metal_basic_golem_mega','player_metal_constructor_golem_mega','player_metal_maintcloak_mega','player_metal_pressure_golem_mega','player_metal_surgeon_golem_mega']
				let metal_royal = ['player_metal_archival_golem_mega','player_metal_dull_golem_mega']
				
				let newAllySlug = metal_peasant.sample()
				let newAllySlug1 = metal_royal.sample()
				let rand = Math.random()
				user.lastSide = !user.lastSide
				if(rand < 0.75) {
						if(user.team.members.filter(m=>m.slug.includes('metal')).length < (fated ? fated.power + 4 : 4)) {
							if(user.team.name == "enemy") { midCombatActorAdd(myTeam, newAllySlug, user.lastSide ? "left" : "right") }
							else { midCombatAllyAdd(newAllySlug, user.lastSide ? "left" : "right") }
						}
					}
				else { 
						if(user.team.members.filter(m=>m.slug.includes('metal')).length < (fated ? fated.power + 4 : 4)) {
							if(user.team.name == "enemy") { midCombatActorAdd(myTeam, newAllySlug1, user.lastSide ? "left" : "right") }
							else { midCombatAllyAdd(newAllySlug1, user.lastSide ? "left" : "right") }
						}
					}
				}
			})
		}
	},
		//metal secondary augment
	env.ACTIONS.special_chitinous_barrier = {
        slug: "special_chitinous_barrier",
        name: "Defensive Cover",
        type: 'special',
        desc: "'apply ablative protection';'upgrades protection to provide passive defense'",
        help: "ALLIES::+2 BP +CHITINOUS",
        anim: "cloak-barrier",
        autohit: true,
        amt: 2,
        usage: {
            act: "%USER SHIELDS THEIR ALLIES"
        },
		details: {
            flavor: "'apply ablative protection';'upgraded barrier provides passive defense while active'",
            onUse: "'[STAT::amtBP] [STATUS::chitinous] to nearby allies'",
        },
        stats: {
            accuracy: 1,
            crit: 0.1,
            amtBP: 2,
            status: {
                chitinous: { name: 'chitinous', length: 1 },
            }
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this

            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        beneficial: true,
                        type: 'barrier',
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'mend',
                            rate: 2
                        },
                        hitStatus: {
                            name: 'chitinous',
                            length: 1
                        },
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
		//metal utility augment
	env.ACTIONS.berserk_mega = {
        slug: "berserk_mega",
        name: "Taunt",
        type: 'autohit',
        desc: "'self-modify for maximum offense';'tempt foes into striking recklessly'",
        help: "+1T:DENATURED +2T:SERRATIONS -VULNERABLE",
        anim: "heal",
        usage: {
            act: "%USER MELTS INTO A MORE AGGRESSIVE SHAPE"
        },
        details: {
            flavor: "'self-modify for maximum offense';;'tempt foes into striking recklessly'",
            onUse: "'[STATUS::denatured] [STATUS::serrations] -[STATUS::vulnerable]'"
        },
        stats: {
            status: {
                denatured: { name: 'denatured', length: 1 },
                serrations: { name: 'serrations', length: 2 },
				vulnerable: { name: 'vulnerable', showReference: true },
            }
        },
        exec: function(user, target) {
            play('destabilize', 0.5);
            removeStatus(user, "vulnerable"); 
            addStatus({target: user, status: "denatured", length: 1, noReact: true}); 
            addStatus({target: user, status: "serrations", length: 2, noReact: true}); 
            return 'nothing';
        }
    },
	//pain actions
		//pain primary 1
	env.ACTIONS.playershelf_crush = {
		slug: "playershelf_crush",
		name: "Crush",
		verb: "crush",
		type: 'target',
		desc: "'utilize long limbs to eviscerate to a target';'guarantee strike'",
		anim: "basic-attack",
		help: "100% -2HP",
		usage: {
			act: "%USER LUNGES AT %TARGET",
			hit: "%TARGET TAKES A SOLID HIT",
			miss: "%TARGET ESCAPES BY A HAIR"
		},
		accuracy: 1,
		amt: 2,
		exec: function(user, target) {
			advanceTurn(user)
			return env.GENERIC_ACTIONS.singleTarget({
				action: this, 
				user, 
				target,
				hitSfx: {
					name: 'stab',
					rate: 0.75
				},
				missSfx: {
					name: 'miss',
					rate: 0.75
				},
			})
		}
	}
		//pain primary 2
	env.ACTIONS.playershelf_annihilation = {
		slug: "playershelf_annihilation",
		name: "Annihilation",
		verb: "annihilate",
		type: 'target',
		desc: "'utilize long limbs to eviscerate a target';'maximize damage'",
		anim: "basic-attack",
		help: "50% -2HP (SELF:: -1HP), 50%C x2 +2T:PUNCTURE +1T:STUN (SELF:: -1HP)",
		usage: {
			act: "%USER LUNGES AT %TARGET",
			crit: "%TARGET IS BRUTALLY STABBED",
			hit: "%TARGET TAKES A SOLID HIT",
			miss: "%TARGET ESCAPES BY A HAIR"
		},
		accuracy: 0.5,
		crit: 0.5,
		amt: 2,
		exec: function(user, target) {
			advanceTurn(user)
			return env.GENERIC_ACTIONS.singleTarget({
				action: this, 
				user, 
				target,
				hitSfx: {
					name: 'stab',
					rate: 0.75
				},
				missSfx: {
					name: 'miss',
					rate: 0.75
				},
				critExec: ({target})=>{
					addStatus({target, status: "stun", length: 1});
					addStatus({target, status: "puncture", length: 2});
					combatHit(user, {amt: 1, autohit: true, canCrit: false, redirectable: false, origin: user})
				},
				hitExec: ({target})=>{
					combatHit(user, {amt: 1, autohit: true, canCrit: false, redirectable: false, origin: user})
				}
			})
		}
	}
	
		//pain primary test
		//in theory, if i remove the actionAnim property, it should work fine, the only casualty being antishells using it will look kind of dumb
	env.ACTIONS.special_playershelf_annihilate = {
        slug: "special_playershelf_annihilate",
        name: "Annihilation",
        type: 'special+target',
        desc: "'utilize long limbs to eviscerate a target';'offer user responsive choice'",
        anim: "wobble",
        help: "CHOOSE::100% -2HP ::OR:: 50% -2HP (SELF:: -1HP), 50%C x2 +2T:PUNCTURE +1T:STUN (SELF:: -1HP)",
        usage: {
            act: "%USER LUNGES AT %TARGET",
            crit: "%TARGET IS BRUTALLY STABBED",
            hit: "%TARGET TAKES A SOLID HIT",
            miss: "%TARGET ESCAPES BY A HAIR"
        },
        accuracy: 1,
        crit: 0,
		details: {
            onUse: "'utilize long limbs to eviscerate a target';'offer user choice of outcome'",
            conditional: "<em>HIT 1</em>::'HIT::[STAT::hit1ACC]% CRIT::0% [STAT::hit1HP]'\n<em>HIT 2</em>::'HIT::[STAT::hit2ACC]% CRIT::[STAT::hit2CRIT]% [STAT::hit1HP]';'[STAT::hit2HP] to SELF on HIT';'[STAT::hit2HP] to SELF, [STATUS::stun] [STATUS::puncture] to TARGET on CRIT'"
        },

        stats: {
            hit1HP: 2,
            hit1ACC: 100,
            hit2HP: 1,
            hit2ACC: 50,
            hit2CRIT: 50,

            status: {
                stun: { name: 'stun', length: 1 },
                puncture: { name: 'puncture', length: 2 }
            },
        },
        exec: function(user, target) {
			if(user.slug.includes("falsecritta")) { // antishell usage safeguard
				let rand = Math.random()
				if(rand < 0.5) {
					useAction(user, env.ACTIONS['playershelf_crush'], target, {beingUsedAsync: true, reason: "annihilation"})
					setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE);
				} else if(rand > 0.5) { 
					useAction(user, env.ACTIONS['playershelf_annihilation'], target, {beingUsedAsync: true, reason: "annihilation"}) 
					setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE);
				}
			}
			else {
			let action = this

				//summon a div that lets the player click guaranteed or chance <--- we are modifying this to let the player choose between a high damage guarenteed strike or a self-damaging strike that can crit
				actionChoice({
					user: user,
					action: action,
					choiceText: `${user.name} lunges at ${target.name}...`,
					options: [
						{text: "Guarantee strike", definition: "NOTE::'100% -2HP'"},
						{text: "Try a riskier attack", definition: "NOTE::'50% -2HP (SELF:: -1HP), 50%C x2 +2T:PUNCTURE +1T:STUN (SELF:: -1HP)'"},
					],
					choiceCallback: (c) => {
						//reap the consequences
							
						var hit
						switch(c) {
							case "c0":
								hit = combatHit(target, {amt: 2, acc: 1, crit: 0, origin: user});
								break;
							case "c1":
								hit = combatHit(target, {amt: 2, acc: 0.5, crit: 0.5, origin: user})
								combatHit(user, {amt: 1, autohit: true, canCrit: false, redirectable: false, origin: user})
								break
						}

						actionMessage(user, action, target, hit)
						switch(hit) {
							case "crit":                                
								playCombatCrit()
								addStatus({target: target, origin: user, status: "stun", length: 1})
								addStatus({target: target, origin: user, status: "puncture", length: 2, noReact: true})
								combatHit(user, {amt: 1, autohit: true, canCrit: false, redirectable: false, origin: user})
								removeStatus(target, "windup")
								break
							case true:
								reactDialogue(target, 'receive_hit')
								play("stab", 0.75)
								break;
							case false:
								reactDialogue(target, 'evade')
								play("miss", 0.75)
								break;
						}

						setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE);
					}
				})
			}
        }
    },

		//pain secondary
	env.ACTIONS.infiltrate = {
		slug: "infiltrate",
		name: "Infiltrate",
		type: 'target',
		anim: "skitter",
		usage: {
			act: "%USER LUNGES",
			crit: "%TARGET IS PUPPETED FROM THE INSIDE OUT",
			hit: "%USER TERRIFIES %TARGET",
			miss: "%TARGET RECOILS"
		},
		details: {
            flavor: "'attempt to enter target body';'chance to indirectly control actions'",
            onHit: "'[STATUS::fear]'",
            onCrit: "'[STATUS::puncture] [STATUS::puppet] [STAT::selfHP]'"
        },
        stats: {
            accuracy: 0.9,
            crit: 0.1,
            amt: 0,
			selfHP: 1,
            status: {
                fear: { name: 'fear', length: 2 },
				puncture: { name: 'puncture', length: 1 },
				puppet: { name: 'puppet', length: 1 },
            }
        },
		exec: function(user, target) {
			return env.GENERIC_ACTIONS.singleTarget({
				action: this, 
				user, 
				target,
				hitSfx: {
					name: 'talksignal',
					rate: 1
				},
				hitExec: ()=>{
					reactDialogue(user, `give_fear`)
				},
				critSfx: {
					name: 'stab',
					rate: 0.55
				},
				critExec: ({target}) => {
                    addStatus({target, origin: user, status: "puppet", length: 1}); 
					addStatus({target, origin: user, status: "puncture", length: 1}); 
					combatHit(target, {amt: 1, crit: 0, autohit: true, origin: user});
				},
				hitStatus: {
					name: 'fear',
					length: 2
				},
			})
		}
	},
		//pain utility
	env.ACTIONS.special_raise = {
		slug: "special_raise",
		name: "Raise",
		type: 'special+summon',
		desc: "'utilize parasitic bioweapon';'bring foes bodies to terrible life'",
		help: "FOES::80% ONE OF (+2T:FEAR, +1T:PUNCTURE, +2T:VULNERABLE), 5%C -1HP + ONE OF (+2T:FEAR, +1T:PUNCTURE, +1T:WEAKENED) + SUMMON::+1 HUSK (MAX:4)",
		anim: "skitter",
		details: {
			flavor: "'utilize parasitic bioweapon'",
			onHit: "'inflict one of following';'[STATUS::fear], [STATUS::puncture], [STATUS::vulnerable]'",
			onCrit: "'-1HP, inflict one of following';'[STATUS::fear], [STATUS::puncture], [STATUS::weakened]';'summon husk';'max:4'",
		},
		stats: {
			accuracy: .8,
			crit: 0.05,
			amt: 0,
			status: {
				fear: {
					name: 'fear',
					length: 2
				},
				puncture: {
					name: 'puncture',
					length: 1
				},
				weakened: {
					name: 'weakened',
					length: 1
				},
				vulnerable: {
					name: 'vulnerable',
					length: 2
				},
			},
		},
		usage: {
			act: "%USER RAISES THE DEAD"
		},
		exec: function(user, target, beingUsedAsync) {
			let action = this
			let fated = user.statusEffects.find(status => status.slug == "fated_pain")

			env.GENERIC_ACTIONS.teamWave({
				team: user.enemyTeam,
				exec: (actor, i) => {
					env.GENERIC_ACTIONS.singleTarget({
						action: action, 
						user, 
						target: actor,
						hitSfx: { name: 'talksignal' },
						critSfx: { name: 'chomp', rate: 0.45 },
						hitExec: ({target})=> {
							let rand = Math.random()
							if(rand < 0.3) {
								addStatus({target, origin: user, status: "fear", origin: user, length: 2}); 
								
							} else if(rand < 0.6) {
								addStatus({target, origin: user, status: "puncture", origin: user, length: 1}); 

							} else {
								addStatus({target, origin: user, status: "vulnerable", origin: user, length: 2}); 
							}
						},
						critExec: ({target}) => {
							let rand = Math.random()
							
							if(rand < 0.3) {
								addStatus({target, origin: user, status: "fear", origin: user, length: 2}); 
								
							} else if(rand < 0.6) {
								addStatus({target, origin: user, status: "puncture", origin: user, length: 1}); 

							} else {
								addStatus({target, origin: user, status: "weakened", origin: user, length: 1}); 
							}
							if(user.team.name == "ally") {
								let rand1 = Math.random()
								let pain_peasant = ['player_pain_husk','player_pain_husk','player_pain_husk','player_pain_husk','player_pain_husk_bone','player_pain_husk_claws','player_pain_husk_eyes','player_pain_husk_ichor','player_pain_husk_light']
								let newAllySlug = pain_peasant.sample()
								if (rand1 < 1) {
									user.lastSide = !user.lastSide
									if(user.team.members.filter(m=>m.slug.includes('pain')).length < (fated ? fated.power + 4 : 4)) {
										midCombatAllyAdd(newAllySlug, user.lastSide ? "left" : "right")
									}
								}
							}
							else {
								let rand1 = Math.random()
								let pain_peasant_enemy = ['pain_husk','pain_husk','pain_husk','pain_husk','pain_husk_bone','pain_husk_claws','pain_husk_eyes','pain_husk_ichor','pain_husk_light']
								let newEnemySlug = pain_peasant_enemy.sample()
								if (rand1 < 1) {
									user.lastSide = !user.lastSide
									if(user.team.members.filter(m=>m.slug.includes('pain')).length < (fated ? fated.power + 4 : 4)) {
										midCombatEnemyAdd(newEnemySlug, user.lastSide ? "left" : "right")
									}
								}
							}
							combatHit(actor, {amt: 1, crit: 0, autohit: true, origin: user});
						}
					})
				},
				advanceAfterExec: true, beingUsedAsync, user,
			})
		}
	}
		//pain primary aug
	env.ACTIONS.special_playershelf_annihilate_mega = {
        slug: "special_playershelf_annihilate_mega",
        name: "Greater Annihilation",
        type: 'special+target',
        desc: "'utilize long limbs to eviscerate a target';'offer user responsive choice'",
        anim: "wobble", 
        help: "CHOOSE::100% -4HP ::OR:: 50% -4HP (SELF:: -3HP), 50%C x2 +4T:PUNCTURE +3T:OPEN WOUND +2T:WEAKENED +1T:STUN (SELF:: -3HP)",
        usage: {
            act: "%USER LUNGES AT %TARGET",
            crit: "%TARGET IS UNRECOGNIZEABLE",
            hit: "%TARGET IS BRUTALLY STABBED",
            miss: "%TARGET ESCAPED BY A HAIR"
        },
        accuracy: 1,
        crit: 0,
		details: {
            onUse: "'utilize long limbs to eviscerate a target';'offer user choice of outcome'",
            conditional: "<em>HIT 1</em>::'HIT::[STAT::hit1ACC]% CRIT::0% [STAT::hit1HP]'\n<em>HIT 2</em>::'HIT::[STAT::hit2ACC]% CRIT::[STAT::hit2CRIT]% [STAT::hit1HP]';'[STAT::hit2HP] to SELF on HIT';'[STAT::hit2HP] to SELF, [STATUS::stun] [STATUS::puncture] [STATUS::open_wound] to TARGET on CRIT'"
        },

        stats: {
            hit1HP: 4,
            hit1ACC: 100,
            hit2HP: 3,
            hit2ACC: 50,
            hit2CRIT: 50,

            status: {
                stun: { name: 'stun', length: 2 },
                puncture: { name: 'puncture', length: 4 },
				open_wound: { name: 'open_wound', length: 3 },
            },
        },
        exec: function(user, target) {
			removeStatus(user, "windup")
            let action = this

            //summon a div that lets the player click guaranteed or chance <--- we are modifying this to let the player choose between a high damage guarenteed strike or a self-damaging strike that can crit
            actionChoice({
                user: user,
                action: action,
                choiceText: `${user.name} lunges at ${target.name}...`,
                options: [
                    {text: "Guarantee strike", definition: "NOTE::'100% -4HP'"},
                    {text: "Go for the kill", definition: "NOTE::'50% -4HP (SELF:: -3HP), 50%C x2 +4T:PUNCTURE +3T:OPEN WOUND +2T:WEAKENED +1T:STUN (SELF:: -3HP)'"},
                ],
                choiceCallback: (c) => {
                    //reap the consequences
                        
                    var hit
                    switch(c) {
                        case "c0":
                            hit = combatHit(target, {amt: 4, acc: 1.5, crit: 0, origin: user});
                            break;
                        case "c1":
                            hit = combatHit(target, {amt: 4, acc: 0.5, crit: 0.5, origin: user})
							combatHit(user, {amt: 3, autohit: true, canCrit: false, redirectable: false, origin: user})
                            break
                    }

                    actionMessage(user, action, target, hit)
                    switch(hit) {
                        case "crit":                                
                            playCombatCrit()
                            addStatus({target: target, origin: user, status: "stun", length: 2})
                            addStatus({target: target, origin: user, status: "puncture", length: 4, noReact: true})
							addStatus({target: target, origin: user, status: "open_wound", length: 3, noReact: true})
							combatHit(user, {amt: 3, autohit: true, canCrit: false, redirectable: false, origin: user})
                            removeStatus(target, "windup")
                            break
                        case true:
                            reactDialogue(target, 'receive_crit')
                            play("stab", 0.65)
                            break;
                        case false:
                            reactDialogue(target, 'evade')
                            play("miss", 0.65)
                            break;
                    }

                    setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE);
                }
            })
        }
    },
		//pain utility aug 1
	env.ACTIONS.raise_sacrifice = {
		slug: "raise_sacrifice",
		name: "Meiosis",
		desc: "'split off own flesh to create ally'",
		anim: "skitter",
		type: 'special+nomimic+summon',
		help: "SELF:: -2HP +1T:PUNCTURE + SUMMON +1 HUSK (MAX:4)",
		itemAction: true, //we have to lie here so that imps can't use this action
		advanceAfterExec: true,
		usage: {
			act: "%USER CREATES A HUSK FROM THEIR FLESH"
		},
		details: {
			flavor: "'split off own flesh to create ally'",
			onUse: "'TO SELF::[STAT::amt] [STATUS::puncture]'\n'summon husk';'max:4'",
		},
		stats: {
			amt: 2,
			status: {
				puncture: {
					name: 'puncture',
					length: 1
				},
			},
		},
		exec: (user, beingUsedAsync) => {
			let fated = user.statusEffects.find(status => status.slug == "fated_pain")
			play('stab', 0.8)
			combatHit(user, {amt: 2, autohit: true, redirectable: false, runEvents: false, origin: user})
			addStatus({target: user, status: "puncture", length: 1});
			let rand1 = Math.random()
			let pain_peasant = ['player_pain_husk','player_pain_husk','player_pain_husk','player_pain_husk_bone','player_pain_husk_claws','player_pain_husk_eyes','player_pain_husk_ichor','player_pain_husk_light']
			let newAllySlug = pain_peasant.sample()
			if (rand1 < 1) {
				user.lastSide = !user.lastSide
				if(user.team.members.filter(m=>m.slug.includes('pain')).length < (fated ? fated.power + 4 : 4)) {
					midCombatAllyAdd(newAllySlug, user.lastSide ? "left" : "right")
				}
			}
			setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE * 0.2);
		}
	},
		//pain utility aug 2
	env.ACTIONS.raise_sacrifice_mega = {
		slug: "raise_sacrifice_mega",
		name: "Mitosis",
		desc: "'split off own flesh to create ally';'tendency to create stronger husk';'hurts'",
		anim: "skitter",
		type: 'special+nomimic+summon',
		help: "SELF:: -3HP +2T:PUNCTURE + SUMMON +1 HUSK (MAX:4)",
		itemAction: true, //we have to lie here so that imps can't use this action
		advanceAfterExec: true,
		usage: {
			act: "%USER CREATES A HUSK FROM THEIR FLESH"
		},
		details: {
			flavor: "'split off own flesh to create ally';'tendency to create stronger husk';'hurts'",
			onUse: "'TO SELF::[STAT::amt] [STATUS::puncture]'\n'summon husk';'max:4'",
		},
		stats: {
			amt: 3,
			status: {
				puncture: {
					name: 'puncture',
					length: 2
				},
			},
		},
		exec: (user, beingUsedAsync) => {
			let fated = user.statusEffects.find(status => status.slug == "fated_pain")
			play('stab', 0.6)
			combatHit(user, {amt: 3, autohit: true, redirectable: false, runEvents: false, origin: user})
			addStatus({target: user, status: "puncture", length: 2});
			let rand1 = Math.random()
			let pain_royal = ['player_pain_husk_bone','player_pain_husk_claws','player_pain_husk_eyes','player_pain_husk_ichor','player_pain_husk_light','player_pain_husk_flesh','player_pain_husk_dull','player_pain_husk_spirestone','player_pain_husk_hands','player_pain_husk_flesh','player_pain_husk_dull','player_pain_husk_spirestone','player_pain_husk_hands','player_pain_husk_bone','player_pain_husk_claws','player_pain_husk_eyes','player_pain_husk_ichor','player_pain_husk_light','player_pain_husk_flesh','player_pain_husk_dull','player_pain_husk_spirestone','player_pain_husk_hands','player_pain_husk_flesh','player_pain_husk_dull','player_pain_husk_spirestone','player_pain_husk_hands','player_pain_husk_akizet','player_pain_husk_gakvu','player_pain_husk_tozik','player_pain_husk_miltza','player_pain_husk_bozko','player_pain_husk_cavik','player_pain_husk_ikgolem','player_pain_husk_kazki']
			let newAllySlug = pain_royal.sample()
			if (rand1 < 1) {
				user.lastSide = !user.lastSide
				if(user.team.members.filter(m=>m.slug.includes('pain')).length < (fated ? fated.power + 4 : 4)) {
					midCombatAllyAdd(newAllySlug, user.lastSide ? "left" : "right")
				}
			}
			setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE * 0.3);
		}
	},
		//pain secondary aug
	env.ACTIONS.swarm = { // note to self::don't do this again
		slug: "swarm",
		name: "Swarm",
		type: 'summon+nomimic+target',
		desc: "'attempt to enter target body';'assume direct control'",
		help: "90% -1HP +1T:PUNCTURE, 5%C +2T:FEAR +1T:STUN +HOST BODY +HUSKED\nSUMMON::+1 HUSKED ALLY (MAX:1)",
		anim: "basic-attack",
		accuracy: 0.9,
		crit: 0.05,
		amt: 1,
		itemAction: true, //we have to lie here so that imps can't use this action
		usage: {
			act: "%USER SURROUNDS %TARGET",
			crit: "%TARGET IS HUSKED",
			hit: "%TARGET IS LACERATED",
			miss: "%TARGET ESCAPES"
		},
		details: {
            flavor: "'attempt to enter target body';'assume direct control'",
            onHit: "'[STATUS::puncture]'",
            onCrit: "'[STATUS::fear] [STATUS::puppet_mega] [STATUS::puppet_conjoined]'"
        },
        stats: {
            accuracy: 0.9,
            crit: 0.05,
            amt: 1,
            status: {
                fear: { name: 'fear', length: 2 },
				puncture: { name: 'puncture', length: 1 },
				puppet_mega: { name: 'puppet_mega', length: 1 },
				puppet_conjoined: { name: 'puppet_conjoined', length: 1 },
            }
        },
		exec: function(user, target) {
			let fated = user.statusEffects.find(status => status.slug == "fated_pain")
			return env.GENERIC_ACTIONS.singleTarget({
				action: this,
				user,
				target,
				hitStatus: {
					name: 'puncture',
					length: 1
				},
				hitSfx: {
					name: 'stab',
					rate: 1.5
				},
				critSfx: {
					name: 'chomp',
					rate: 0.5
				},
				critExec: ({target}) => {
					addStatus({target: target, origin: user, status: "fear", length: 2})
					addStatus({target: target, origin: user, status: "stun", length: 1})
					if(target.statusImmunities && target.statusImmunities.includes("stun")) return //if the target is a boss enemy, don't husk them
					if(user.team.members.filter(m=>m.slug.includes('husked')).length > (fated ? fated.power + 1 : 1)) return //if the husked ally limit has been reached, don't apply the husking statuses
					if(target.slug.includes('falsecritta')) return //if the target is an antishell, don't bother
					if(target.slug.includes('gauntlet')) return //if the target is a doz gauntlet, don't bother
					if(target.originalSlug) { slugInsert = target.originalSlug } //grab target slug
					else slugInsert = target.slug //ok turns out if there's only one actor on the team they don't get an original slug
					let newAllySlug = slugInsert+ '_husked' //set newAllySlug to the slug + husked
					if(!env.COMBAT_ACTORS[newAllySlug]) return //make sure this actor has a husked variant before trying to husk them
					addStatus({target: target, origin: user, status: "puppet_mega", length: 1})
					addStatus({target: target, origin: user, status: "puppet_conjoined", length: 1})
					
					let rand = Math.random()
					if (rand < 1) {
						user.lastSide = !user.lastSide
						if(user.team.members.filter(m=>m.slug.includes('husked')).length < (fated ? fated.power + 1 : 1)) { //summon corresponding combat actor
							midCombatAllyAdd(newAllySlug, user.lastSide ? "left" : "right")
						}
					}
				}
			})
		}
	},
	
	//trusive actions
		//trusive primary aug (so that it doesn't conflict with surge and wild surge)
	env.ACTIONS.trusive_smash = {
        slug: "trusive_smash",
        name: "Unnatural Strike",
        type: 'target',
        desc: "'focused, deadly attack upon one target';'immense physical trauma'",
        anim: "basic-attack",
        help: "100% -4HP, 40% X2 +1T:STUN +2T:OPEN WOUND +3T:VULNERABLE +CRITICAL FLAW",
        usage: {
            act: "%USER CHARGES %TARGET",
            crit: "%TARGET IS LEFT REELING",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'focused, deadly attack upon one target';'immense physical trauma'", 
            onHit: "'[STAT::amt]'",
			onCrit: "'[STATUS::stun] [STATUS::open_wound] [STATUS::vulnerable] [STATUS::critical_flaw]'",
        },
        stats: {
            accuracy: 1,
            crit: 0.4, 
            amt: 4,
            status: { 
                stun: {
                    name: 'stun',
                    length: 1
                },
                open_wound: {
                    name: 'open_wound',
                    length: 2
                },
                vulnerable: {
                    name: 'vulnerable',
                    length: 3
                },
                critical_flaw: {
                    name: 'critical_flaw',
                    length: 1
                },

            }
        },
        exec: function(user, target) {
            removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'hit',
                    rate: 0.8
                },
                critExec: ({target})=> {
                    addStatus({target, origin: user, status: "stun", length: 1})
                    addStatus({target, origin: user, status: "open_wound", length: 2, noReact: true})
                    addStatus({target, origin: user, status: "vulnerable", length: 3, noReact: true})
                    addStatus({target, origin: user, status: "critical_flaw", length: 1, noReact: true})
                }
            })
        },
		disableIf: (user)=> {if(user.windupActions.includes("trusive_splitter")) return "PROHIBITED BY INCOHERENCE"}
    },
		//frenzy action for secondary so it doesn't ONLY murderize you
	env.ACTIONS.frenzy_heal = {
        slug: "frenzy_heal",
        name: "Healing Frenzy",
        type: 'target',
        desc: "'puncture vital cystic component';'may inspire additional stabbing';'stop regen'\n'best paired with focus and vulnerability'",
        anim: "basic-attack",
        help: "70% -1HP +2T:PUNCTURE -REGEN, 10%C USE THIS ACTION AGAIN (SELF:: +1HP, -PUNCTURE)",
        usage: {
            act: "%USER STABS %TARGET",
            crit: "%USER JUST KEEPS GOING",
            hit: "%TARGET BLEEDS SLUDGY CORRU",
            miss: "%TARGET EVADES"
        },
        accuracy: 0.7,
        crit: 0.1,
        amt: 1,
        exec: function(user, target) {
            let action = this
            return env.GENERIC_ACTIONS.singleTarget({
                action, 
                user, 
                target,
                hitSfx: {
                    name: 'stab',
                    rate: 1
                },
                critSfx: {
                    name: 'stab',
                    rate: 1.75
                },
                hitExec: ({target}) => {
                    addStatus({target, status: "puncture", length: 2});
                },
                critExec: ({target})=> {
                    if(target.hp > 0 && target.state != "lastStand") {
                        env.setTimeout(()=>{
                            useAction(user, this, target, {beingUsedAsync: true, reason: "frenzy"})
							combatHit(user, {amt: -1, autohit: true, origin: user, beneficial: true})
							removeStatus(user, "puncture")
                        }, 400)
                    }
                }
            })
        }
    },
	
		//trusive secondary
    env.ACTIONS.special_mass_frenzy = {
        slug: "special_mass_frenzy",
        name: "Wound Thoughtspace",
        type: 'special',
        desc: "'blind frenzy across battlefield';'indiscriminate damage'",
        help: "ALL::70% -1HP +2T:PUNCTURE -REGEN, 10%C x2 CONTINUE ATTACKING TARGET + (SELF:: +1HP, -PUNCTURE)",
        anim: "wobble",
        autohit: true,
        accuracy: 100,
		details: {
            flavor: "'blind frenzy across battlefield';'indiscriminate damage'",
            onUse: "'HIT all actors';'[STAT::percentage]% chance to CRIT'",
			onHit: "'[STAT::selfHP] [STATUS::puncture]'",
			onCrit: "'continue attacking target';'[STAT::healHP] -[STATUS::displayPuncture] to user'"
        },
        stats: {
			autohit: true,
			selfHP: 1,
			healHP: -1,
			percentage: 10,
            status: {
                puncture: {
                    name: 'puncture',
                    length: 2
                },
				displayPuncture: {
                    name: 'puncture',
                    showReference: true
                }
            },
        },
        exec: function(user, target, beingUsedAsync) {
            actionMessage(user, "THE THOUGHTSPACE GROWS VIOLENT", target);
            
            if(env.rpg.classList.contains("bastard")) {                
                if(user.team.name == "ally") {
                    env.rpg.classList.add('incoherentbg')
                    content.classList.add('painprep', 'painfade', 'painhalf')
                    setTimeout(()=>{content.classList.add('painmode')}, 100)
                    setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                    setTimeout(()=>{content.classList.remove('painprep', 'painfade', 'painhalf')}, 5000)

                    setTimeout(()=>{env.rpg.classList.remove('incoherentbg')}, 4000)
                }
            } else {
                ratween(env.bgm, 1, 2000)
                env.rpg.classList.add('incoherentbg')
                content.classList.add('painprep', 'painhalf')
                setTimeout(()=>{content.classList.add('painmode')}, 100)
                setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                setTimeout(()=>{content.classList.remove('painprep', 'painhalf')}, 5000)
            }
            
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        autohit: true,
						hitSfx: {
							name: "stab",
							rate: 1
						},
						critSfx: {
							name: "stab",
							rate: 1.75
						},
                        genExec: ({target}) => {
                            useAction(user, env.ACTIONS.frenzy_heal, target, {beingUsedAsync: true, reason: "mass frenzy"})
                        }
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
		//trusive utility
    env.ACTIONS.special_intrusive_alt = {
        slug: "special_intrusive_alt",
        name: "Gamble",
        type: 'special+nomimic',
        desc: "'Ã¢Â«Â§Ã¢ÂªÂ¶Ã£Â¥Â¥Ã£Â³'",
        help: "SSP IN  THE WHEE L LL LL",
        anim: "",
		itemAction: true, //lying here so imps can't use this because could you fucking imagine
        autohit: true,
        crit: 0,
        usage: {
            act: "A GRIM GAMBLE IS MADE"
        },
        noRepeat: true,
        possibleSpawns: ["intrusive_blocker_weak", "intrusive_archival_weak", "intrusive_bishopfreak_weak", "intrusive_statusoid_weak" ],
		possibleAllies: ["intrusive_blocker_weak_ally", "intrusive_archival_weak_ally", "intrusive_bishopfreak_weak_ally", "intrusive_statusoid_weak_ally" ],
        possiblePassives: ["light_veilkdrop", "light_humorist", "eyes_dancer", "bone_adaptive", "claws_chitin", "light_glee", "eyes_hypercritical", "malware_drill", "malware_rot", "weak_point"],
        exec: function(user, target, beingUsedAsync) {
			let actor = user

			env.rpg.insertAdjacentHTML('beforeend', `
			<figure id="chancepanel" class="hidden" for="${actor.slug}">
				<img src="/img/sprites/flantrusive/panelbase.gif">
				<div class="wheel">
					<ul>
						<li class="d1">1</li>
						<li class="d2">2</li>
						<li class="d3">3</li>
						<li class="d4">4</li>
						<li class="d5">5</li>
						<li class="d6">6</li>
						<li class="d7">7</li>
					</ul>
				</div>
				<div class="display">
					<ol>
						<li class="d1">1. life up</li>
						<li class="d2">2. main up</li>
						<li class="d3">3. unlucky</li>
						<li class="d4">4. bomb</li>
						<li class="d5">5. unlucky</li>
						<li class="d6">6. change</li>
						<li class="d7">7. lucky</li>
					</ol>
				</div>
				<div class="result">
					<div>
						<span></span>
					</div>
				</div>
			</figure>`)
		
			actor.chancePanel = env.rpg.querySelector(`#chancepanel[for="${actor.slug}"]`)
			actor.chancePanel.result = actor.chancePanel.querySelector(".result span")
			actor.chancePanel.spin = (state) => { 
				actor.chancePanel.removeAttribute("chosen")
				actor.chancePanel.classList.toggle("spinning", state) 
				actor.chancePanel.result.innerHTML = "???"
			}
		
			actor.chancePanel.stopAndResult = () => { 
				let result = rand(1, 8)
				actor.chancePanel.spin(false)
				actor.chancePanel.setAttribute("chosen", result)
		
				return result
			}
			
            if(!user.chancePanel) throw 'ok intrusive spawned wrong';
            let action = this

            user.chancePanel.classList.add("active")
            user.chancePanel.classList.remove("hidden")
            user.chancePanel.spin(true)
            play("talkfairy", 0.5)
            let result

            setTimeout(()=>{
                result = user.chancePanel.stopAndResult()
                playCombatCrit()
            }, 2000)

            setTimeout(()=>{
                switch(result) {
                    case 1: // life up - gives 5HP and 5 turns of regen to allies
                        user.chancePanel.result.innerHTML = "LUCKY! CHA CHA"
                        env.GENERIC_ACTIONS.teamWave({
                            team: user.team,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: -5,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talklaugh',
                                        rate: 0.5
                                    },
                                    hitStatus: {
                                        name: 'regen',
                                        length: 5
                                    },
									genExec: ()=> {
										combatHit(actor, {amt: -5, origin: user, autohit: true, beneficial: true}); //for reasons unclear to me, life up can't heal on its own so we have to do this shenaniganry
									}
                                })
                            },
                            advanceAfterExec: true, beingUsedAsync, user,
                        })
                    break

                    case 2: // main up - team gets focus and empowered but no empowered if you're an enemy :P
                        user.chancePanel.result.innerHTML = "LUCKY! CHA CHA"
                        env.GENERIC_ACTIONS.teamWave({
                            team: user.team,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: 0,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talklaugh',
                                        rate: 0.5
                                    },
                                    hitStatus: {
                                        name: 'focused',
                                        length: 2
                                    },
                                    genExec: ({target}) => {
                                        if(target.team.name == "ally") addStatus({target, status: "empowered", length: 1, noReact: true})
                                    }
                                })
                            },
                            advanceAfterExec: true, beingUsedAsync, user,
                        })
                    break

                    case 3: // spawns enemies
                    case 5: // unlucky
                        user.chancePanel.result.innerHTML = "BAD TIM!::E NO,W!"
                        play('dull', 0.8, 1)
                             
                        if(user.enemyTeam.members.length < 12) {
                            if(user.lastSide) {
                                midCombatEnemyAdd(this.possibleSpawns.sample(), 'left')
                                user.lastSide = 0
                            } else {
                                midCombatEnemyAdd(this.possibleSpawns.sample(), 'right')
                                user.lastSide = 1
                            }
                        } else {
                            useAction(user, env.ACTIONS.special_mass_destabilize, user, {triggerActionUseEvent: false, beingUsedAsync: true})
                        }
            
                        setTimeout(()=>advanceTurn(user), 1000)
                    break

                    case 4: // bombs - spawns a bastard bomb
                        user.chancePanel.result.innerHTML = "BOOM :=)"
                        play('dull', 0.8, 1)

                        if(user.enemyTeam.members.length < 12) {
                            midCombatEnemyAdd("intrusive_bomblet_weak", 'right')
                        } else {
                            useAction(user, env.ACTIONS.special_mass_destabilize, user, {triggerActionUseEvent: false, beingUsedAsync: true})
                        }
            
                        setTimeout(()=>advanceTurn(user), 1000)
                    break

                    case 6: // change - gives everyone a special passive that's overridden by each change roll
                        user.chancePanel.result.innerHTML = "THINK AGAIN"
                        env.GENERIC_ACTIONS.teamWave({
                            arbitraryActorList: env.rpg.turnOrder,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: 0,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talkfairy',
                                        rate: 0.5
                                    },
                                    genExec: ({target}) => {
                                        let currentStatuses = target.statusEffects.map(status => status.slug)
                                        let possiblePassives = this.possiblePassives.filter(statusName => !currentStatuses.includes(statusName))

                                        console.log("in with", target, possiblePassives)

                                        //special ones can happen on certain creatures
                                        if(
                                            !target.slug.includes("intrusive") ||
                                            target.slug.includes("intrusive_bishopfreak")
                                        ) possiblePassives.push("visionary")

                                        if(
                                            !target.slug.includes("intrusive") ||
                                            target.slug.includes("intrusive_bishopfreak") ||
                                            target.slug.includes("intrusive_statusoid")
                                        ) possiblePassives.push("active_support")

                                        if(
                                            !target.slug.includes("intrusive") ||
                                            target.slug.includes("intrusive_bishopfreak") ||
                                            target.slug.includes("intrusive_statusoid")
                                        ) possiblePassives.push("impatient")
                                        
                                        // remove passive beforehand if one exists
                                        if(target.intrusivePassive) { removeStatus(target, target.intrusivePassive, {forceRemoveStatus: true}) }
                                        target.intrusivePassive = possiblePassives.sample()
                                        addStatus({target, status: target.intrusivePassive, length: 1, noReact: true})                                        
                                    }
                                })
                            },
                            advanceAfterExec: true, beingUsedAsync, user,
                        })
                    break
					
					case 7: // lucky - summon intrusive ally
						user.chancePanel.result.innerHTML = "GOOD TIM!::E NO,W!"
                        play('dull', 0.8, 1)
                             
                        if(user.team.members.length < 15) {
                            if(user.lastSide) {
                                midCombatAllyAdd(this.possibleAllies.sample(), 'left')
                                user.lastSide = 0
                            } else {
                                midCombatAllyAdd(this.possibleAllies.sample(), 'right')
                                user.lastSide = 1
                            }
                        } else {
                            useAction(user, env.ACTIONS.special_mass_destabilize, user, {triggerActionUseEvent: false, beingUsedAsync: true})
                        }
            
                        setTimeout(()=>advanceTurn(user), 1000)
                }
            }, 3000)

            setTimeout(()=>user.chancePanel.classList.remove("active"), 6000)
        }
    }
	
		//unused trusive primary aug
	env.ACTIONS.trusive_splitter = {
        slug: "trusive_splitter",
        name: "Thoughtsplitter",
		verb: "thoughtsplit",
        type: 'target',
        desc: "'incoherence enabled cutting beam';'immense physical trauma'",
        anim: "basic-attack",
        help: "AUTOHIT -4HP +2T:OPEN WOUND +3T:VULNERABLE +CRITICAL FLAW, 5% x2 +WEAK POINT",
        usage: {
            act: "%USER BLASTS %TARGET",
            crit: "%TARGET IS IS ANNIHILATED",
            hit: "%TARGET IS SEARED",
            miss: "%TARGET EVADES"
        },
        autohit: true,
        crit: 0.05,
        amt: 4,
        exec: function(user, target) {
            removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'dull',
                    rate: 0.5
                },
				critSfx: {
					name: 'stab',
					rate: 0.4
				},
				critStatus: {
					name: "weak_point",
					length: 1
				},
                hitExec: ({target})=> {
                    addStatus({target, origin: user, status: "open_wound", length: 2, noReact: true})
                    addStatus({target, origin: user, status: "vulnerable", length: 3, noReact: true})
                    addStatus({target, origin: user, status: "critical_flaw", length: 1, noReact: true})
                }
            })
        }
    }, 
		//trusive secondary aug
	env.ACTIONS.special_mass_bite = {
        slug: "special_mass_bite",
        name: "Consume Thoughtspace",
        type: 'special',
        desc: "'affect all thoughtforms with incoherence';'indiscriminate damage'",
        help: "ALL::AUTOHIT -2HP +3T:ROT, 10%C x2 +3T:ROT + (SELF::+2HP, -ROT)",
        anim: "wobble",
        autohit: true,
		amt: 2,
        accuracy: 100,
        crit: 0.1,
		details: {
            flavor: "'affect all thoughtforms with incoherence';'indiscriminate damage'",
            onUse: "'HIT all actors'",
			onHit: "'[STAT::amt] [STATUS::rot]'",
			onCrit: "'[STATUS::rot]';'[STAT::healHP] -[STATUS::displayRot] to user'"
        },
        stats: {
			autohit: true,
			crit: 0.1,
			amt: 2,
			healHP: -2,
            status: {
                rot: {
                    name: 'rot',
                    length: 3
                },
				displayRot: {
                    name: 'rot',
                    showReference: true
                }
            },
        },
        exec: function(user, target, beingUsedAsync) {
            actionMessage(user, "THE THOUGHTSPACE GROWS WEAK", target);
            
            if(env.rpg.classList.contains("bastard")) {                
                if(user.team.name == "ally") {
                    env.rpg.classList.add('incoherentbg')
                    content.classList.add('painprep', 'painfade', 'painhalf')
                    setTimeout(()=>{content.classList.add('painmode')}, 100)
                    setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                    setTimeout(()=>{content.classList.remove('painprep', 'painfade', 'painhalf')}, 5000)

                    setTimeout(()=>{env.rpg.classList.remove('incoherentbg')}, 4000)
                }
            } else {
                ratween(env.bgm, 1, 2000)
                env.rpg.classList.add('incoherentbg')
                content.classList.add('painprep', 'painhalf')
                setTimeout(()=>{content.classList.add('painmode')}, 100)
                setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                setTimeout(()=>{content.classList.remove('painprep', 'painhalf')}, 5000)
            }
            
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        autohit: true,
                        hitSfx: {
                            name: 'chomp',
                            rate: 1
                        },
						critSfx: {
							name: 'chomp',
							rate: 0.6
						},
                        genExec: ({target}) => {
                            addStatus({target: actor, origin: user, status: "rot", length: 3});
                        },
						critExec: ({target, user}) => {
							addStatus({target: actor, origin: user, status: "rot", length: 3});
							combatHit(user, {amt: -2, autohit: true, origin: user, beneficial: true})
							removeStatus(user, "rot")
						}
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    }
	
		//that's right babey it's time for tarot::TWO !!!!!!!!!!!!!!!!!!
			//intrude wheel actions start here
	env.ACTIONS.special_intrusive_life = {
        slug: "special_intrusive_life",
        name: "Intrude::LIFE",
        type: 'special+nomimic',
        desc: "'Ã¢Â«Â§Ã¢ÂªÂ¶Ã£Â¥Â¥Ã£Â³'",
        help: "SSP IN  THE WHEE L LL LL",
        anim: "",
		itemAction: true, //lying here so imps can't use this because could you fucking imagine
        autohit: true,
        crit: 0,
        usage: {
            act: "A GRIM GAMBLE IS MADE"
        },
        noRepeat: true,
        exec: function(user, target, beingUsedAsync) {
			let actor = user

			env.rpg.insertAdjacentHTML('beforeend', `
			<figure id="chancepanel" class="hidden" for="${actor.slug}">
				<img src="/img/sprites/flantrusive/panelbase.gif">
				<div class="wheel">
					<ul>
						<li class="d1">1</li>
						<li class="d2">2</li>
						<li class="d3">3</li>
						<li class="d4">4</li>
					</ul>
				</div>
				<div class="display">
					<ol>
						<li class="d1">1. life up</li>
						<li class="d2">2. life up</li>
						<li class="d3">3. life up</li>
						<li class="d4">4. life up</li>
					</ol>
				</div>
				<div class="result">
					<div>
						<span></span>
					</div>
				</div>
			</figure>`)
		
			actor.chancePanel = env.rpg.querySelector(`#chancepanel[for="${actor.slug}"]`)
			actor.chancePanel.result = actor.chancePanel.querySelector(".result span")
			actor.chancePanel.spin = (state) => { 
				actor.chancePanel.removeAttribute("chosen")
				actor.chancePanel.classList.toggle("spinning", state) 
				actor.chancePanel.result.innerHTML = "???"
			}
		
			actor.chancePanel.stopAndResult = () => { 
				let result = rand(1, 5)
				actor.chancePanel.spin(false)
				actor.chancePanel.setAttribute("chosen", result)
		
				return result
			}
			
            if(!user.chancePanel) throw 'ok intrusive spawned wrong';
            let action = this

            user.chancePanel.classList.add("active")
            user.chancePanel.classList.remove("hidden")
            user.chancePanel.spin(true)
            play("talkfairy", 0.6)
            let result

            setTimeout(()=>{
                result = user.chancePanel.stopAndResult()
                playCombatCrit()
            }, 2000)

            setTimeout(()=>{
                switch(result) {
                    case 1: // life up - 3HP and +3T:REGEN for allies
                        user.chancePanel.result.innerHTML = "LUCKY!"
                        env.GENERIC_ACTIONS.teamWave({
                            team: user.team,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: 3,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talklaugh',
                                        rate: 0.7
                                    },
                                    hitStatus: {
                                        name: 'regen',
                                        length: 3
                                    },
									genExec: ()=> {
										combatHit(actor, {amt: -3, origin: user, autohit: true, beneficial: true});
									},
                                })
                            },
                            advanceAfterExec: true, beingUsedAsync, user,
                        })
                    break

                    case 2: // life up - 5HP and +5T:REGEN for allies
					case 3:
                        user.chancePanel.result.innerHTML = "LUCKY! CHA CHA"
                        env.GENERIC_ACTIONS.teamWave({
                            team: user.team,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: 5,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talklaugh',
                                        rate: 0.5
                                    },
                                    hitStatus: {
                                        name: 'regen',
                                        length: 5
                                    },
									genExec: ()=> {
										combatHit(actor, {amt: -5, origin: user, autohit: true, beneficial: true});
									},
                                })
                            },
                            advanceAfterExec: true, beingUsedAsync, user,
                        })
                    break

                    case 4: // life up - +10HP, +10T:REGEN, -ROT for allies
                        user.chancePanel.result.innerHTML = "LUCKY LUCKY!!"
                        env.GENERIC_ACTIONS.teamWave({
                            team: user.team,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: 10,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talklaugh',
                                        rate: 0.35
                                    },
                                    hitStatus: {
                                        name: 'regen',
                                        length: 10
                                    },
									genExec: ()=> {
										combatHit(actor, {amt: -10, origin: user, autohit: true, beneficial: true});
										removeStatus(actor, "rot")
									},
                                })
                            },
                            advanceAfterExec: true, beingUsedAsync, user,
                        })
                    break
                }
            }, 3000)

            setTimeout(()=>user.chancePanel.classList.remove("active"), 4500)
        }
    },
	
	env.ACTIONS.special_intrusive_main = {
        slug: "special_intrusive_main",
        name: "Intrude::MAIN",
        type: 'special+nomimic',
        desc: "'Ã¢Â«Â§Ã¢ÂªÂ¶Ã£Â¥Â¥Ã£Â³'",
        help: "SSP IN  THE WHEE L LL LL",
        anim: "",
		itemAction: true, //lying here so imps can't use this because could you fucking imagine
        autohit: true,
        crit: 0,
        usage: {
            act: "A GRIM GAMBLE IS MADE"
        },
        noRepeat: true,
        exec: function(user, target, beingUsedAsync) {
			let actor = user

			env.rpg.insertAdjacentHTML('beforeend', `
			<figure id="chancepanel" class="hidden" for="${actor.slug}">
				<img src="/img/sprites/flantrusive/panelbase.gif">
				<div class="wheel">
					<ul>
						<li class="d1">1</li>
						<li class="d2">2</li>
						<li class="d3">3</li>
						<li class="d4">4</li>
					</ul>
				</div>
				<div class="display">
					<ol>
						<li class="d1">1. main up</li>
						<li class="d2">2. main up</li>
						<li class="d3">3. main up</li>
						<li class="d4">4. main up</li>
					</ol>
				</div>
				<div class="result">
					<div>
						<span></span>
					</div>
				</div>
			</figure>`)
		
			actor.chancePanel = env.rpg.querySelector(`#chancepanel[for="${actor.slug}"]`)
			actor.chancePanel.result = actor.chancePanel.querySelector(".result span")
			actor.chancePanel.spin = (state) => { 
				actor.chancePanel.removeAttribute("chosen")
				actor.chancePanel.classList.toggle("spinning", state) 
				actor.chancePanel.result.innerHTML = "???"
			}
		
			actor.chancePanel.stopAndResult = () => { 
				let result = rand(1, 5)
				actor.chancePanel.spin(false)
				actor.chancePanel.setAttribute("chosen", result)
		
				return result
			}
			
            if(!user.chancePanel) throw 'ok intrusive spawned wrong';
            let action = this

            user.chancePanel.classList.add("active")
            user.chancePanel.classList.remove("hidden")
            user.chancePanel.spin(true)
            play("talkfairy", 0.6)
            let result

            setTimeout(()=>{
                result = user.chancePanel.stopAndResult()
                playCombatCrit()
            }, 2000)

            setTimeout(()=>{
                switch(result) {
                    case 1: // main up - +2T:FOCUSED and +1T:EVASION for allies
                        user.chancePanel.result.innerHTML = "LUCKY!"
                        env.GENERIC_ACTIONS.teamWave({
                            team: user.team,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: 0,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talklaugh',
                                        rate: 0.7
                                    },
                                    hitStatus: {
                                        name: 'focused',
                                        length: 2
                                    },
                                    genExec: ({target}) => {
                                        if(target.team.name == "ally") addStatus({target, status: "evasion", length: 1, noReact: true})
                                    }
                                })
                            },
                            advanceAfterExec: true, beingUsedAsync, user,
                        })
                    break

                    case 2: // main up - +2T:FOCUSED and +1T:EMPOWERED for allies
					case 3:
                        user.chancePanel.result.innerHTML = "LUCKY! CHA CHA"
                        env.GENERIC_ACTIONS.teamWave({
                            team: user.team,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: 0,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talklaugh',
                                        rate: 0.5
                                    },
                                    hitStatus: {
                                        name: 'focused',
                                        length: 2
                                    },
                                    genExec: ({target}) => {
                                        if(target.team.name == "ally") addStatus({target, status: "empowered", length: 1, noReact: true})
                                    }
                                })
                            },
                            advanceAfterExec: true, beingUsedAsync, user,
                        })
                    break

                    case 4: // main up - +3T:FOCUSED, +2T:EMPOWERED, +SURGE for allies
                        user.chancePanel.result.innerHTML = "LUCKY LUCKY!!"
                        env.GENERIC_ACTIONS.teamWave({
                            team: user.team,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: 0,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talklaugh',
                                        rate: 0.35
                                    },
                                    hitStatus: {
                                        name: 'focused',
                                        length: 3
                                    },
                                    genExec: ({target}) => {
                                        if(target.team.name == "ally") addStatus({target, status: "empowered", length: 2, noReact: true})
										if(target.team.name == "ally") addStatus({target, status: "surge", length: 1, noReact: true})
                                    }
                                })
                            },
                            advanceAfterExec: true, beingUsedAsync, user,
                        })
                    break
                }
            }, 3000)

            setTimeout(()=>user.chancePanel.classList.remove("active"), 4500)
        }
    },
	
	env.ACTIONS.special_intrusive_unlucky = {
        slug: "special_intrusive_unlucky",
        name: "Intrude::UNLUCKY",
        type: 'special+nomimic',
        desc: "'Ã¢Â«Â§Ã¢ÂªÂ¶Ã£Â¥Â¥Ã£Â³'",
        help: "SSP IN  THE WHEE L LL LL",
        anim: "",
		itemAction: true, //lying here so imps can't use this because could you fucking imagine
        autohit: true,
        crit: 0,
		possibleSpawns: ["intrusive_blocker_weak", "intrusive_archival_weak", "intrusive_bishopfreak_weak", "intrusive_statusoid_weak" ],
		possibleWeakSpawns: ["intrusive_blocker_micro", "intrusive_archival_micro", "intrusive_bishopfreak_micro", "intrusive_statusoid_micro" ],
		possibleMegaSpawns: ["intrusive_blocker_mega", "intrusive_archival_mega", "intrusive_bishopfreak_mega", "intrusive_statusoid_mega" ],
        usage: {
            act: "A GRIM GAMBLE IS MADE"
        },
        noRepeat: true,
        exec: function(user, target, beingUsedAsync) {
			let actor = user

			env.rpg.insertAdjacentHTML('beforeend', `
			<figure id="chancepanel" class="hidden" for="${actor.slug}">
				<img src="/img/sprites/flantrusive/panelbase.gif">
				<div class="wheel">
					<ul>
						<li class="d1">1</li>
						<li class="d2">2</li>
						<li class="d3">3</li>
						<li class="d4">4</li>
					</ul>
				</div>
				<div class="display">
					<ol>
						<li class="d1">1. unlucky</li>
						<li class="d2">2. unlucky</li>
						<li class="d3">3. unlucky</li>
						<li class="d4">4. unlucky</li>
					</ol>
				</div>
				<div class="result">
					<div>
						<span></span>
					</div>
				</div>
			</figure>`)
		
			actor.chancePanel = env.rpg.querySelector(`#chancepanel[for="${actor.slug}"]`)
			actor.chancePanel.result = actor.chancePanel.querySelector(".result span")
			actor.chancePanel.spin = (state) => { 
				actor.chancePanel.removeAttribute("chosen")
				actor.chancePanel.classList.toggle("spinning", state) 
				actor.chancePanel.result.innerHTML = "???"
			}
		
			actor.chancePanel.stopAndResult = () => { 
				let result = rand(1, 5)
				actor.chancePanel.spin(false)
				actor.chancePanel.setAttribute("chosen", result)
		
				return result
			}
			
            if(!user.chancePanel) throw 'ok intrusive spawned wrong';
            let action = this

            user.chancePanel.classList.add("active")
            user.chancePanel.classList.remove("hidden")
            user.chancePanel.spin(true)
            play("talkfairy", 0.6)
            let result

            setTimeout(()=>{
                result = user.chancePanel.stopAndResult()
                playCombatCrit()
            }, 2000)

            setTimeout(()=>{
                switch(result) {
                    case 1: // bad time now - summon two microtrusives
                        user.chancePanel.result.innerHTML = "BAD TIM!::E"
                        play('dull', 1, 0.8)
                             
                        if(user.enemyTeam.members.length < 12) {
                            if(user.lastSide) {
                                midCombatEnemyAdd(this.possibleWeakSpawns.sample(), 'left')
								midCombatEnemyAdd(this.possibleWeakSpawns.sample(), 'right')
                                user.lastSide = 0
                            } else {
                                midCombatEnemyAdd(this.possibleWeakSpawns.sample(), 'right')
								midCombatEnemyAdd(this.possibleWeakSpawns.sample(), 'left')
                                user.lastSide = 1
                            }
                        } else {
                            useAction(user, env.ACTIONS.special_irradiate, user, {triggerActionUseEvent: false, beingUsedAsync: true})
                        }
            
                        setTimeout(()=>advanceTurn(user), 1000)
                    break

                    case 2: // bad time now - normal trusive summon :P
					case 3:
                        user.chancePanel.result.innerHTML = "BAD TIM!::E NO,W!"
                        play('dull', 0.8, 1)
                             
                        if(user.enemyTeam.members.length < 12) {
                            if(user.lastSide) {
                                midCombatEnemyAdd(this.possibleSpawns.sample(), 'left')
                                user.lastSide = 0
                            } else {
                                midCombatEnemyAdd(this.possibleSpawns.sample(), 'right')
                                user.lastSide = 1
                            }
                        } else {
                            useAction(user, env.ACTIONS.special_mass_destabilize, user, {triggerActionUseEvent: false, beingUsedAsync: true})
                        }
						
						setTimeout(()=>advanceTurn(user), 1000)
                    break

                    case 4: // bad time now - summon 1 megatrusive
                        user.chancePanel.result.innerHTML = "!BAD!! TIM!:!E!! NO,W!!!!"
                        play('dull', 0.6, 1)
                             
                        if(user.enemyTeam.members.length < 12) {
                            if(user.lastSide) {
                                midCombatEnemyAdd(this.possibleMegaSpawns.sample(), 'left')
                                user.lastSide = 0
                            } else {
                                midCombatEnemyAdd(this.possibleMegaSpawns.sample(), 'right')
                                user.lastSide = 1
                            }
                        } else {
                            useAction(user, env.ACTIONS.special_mass_bite, user, {triggerActionUseEvent: false, beingUsedAsync: true})
                        }
						
						setTimeout(()=>advanceTurn(user), 1000)
                    break
                }
            }, 3000)

            setTimeout(()=>user.chancePanel.classList.remove("active"), 4500)
        }
    },
	
	env.ACTIONS.special_intrusive_bombs = {
        slug: "special_intrusive_bombs",
        name: "Intrude::BOMBS",
        type: 'special+nomimic',
        desc: "'Ã¢Â«Â§Ã¢ÂªÂ¶Ã£Â¥Â¥Ã£Â³'",
        help: "SSP IN  THE WHEE L LL LL",
        anim: "",
		itemAction: true, //lying here so imps can't use this because could you fucking imagine
        autohit: true,
        crit: 0,
        usage: {
            act: "A GRIM GAMBLE IS MADE"
        },
        noRepeat: true,
        exec: function(user, target, beingUsedAsync) {
			let actor = user

			env.rpg.insertAdjacentHTML('beforeend', `
			<figure id="chancepanel" class="hidden" for="${actor.slug}">
				<img src="/img/sprites/flantrusive/panelbase.gif">
				<div class="wheel">
					<ul>
						<li class="d1">1</li>
						<li class="d2">2</li>
						<li class="d3">3</li>
						<li class="d4">4</li>
					</ul>
				</div>
				<div class="display">
					<ol>
						<li class="d1">1. bomb</li>
						<li class="d2">2. bomb</li>
						<li class="d3">3. bomb</li>
						<li class="d4">4. bomb</li>
					</ol>
				</div>
				<div class="result">
					<div>
						<span></span>
					</div>
				</div>
			</figure>`)
		
			actor.chancePanel = env.rpg.querySelector(`#chancepanel[for="${actor.slug}"]`)
			actor.chancePanel.result = actor.chancePanel.querySelector(".result span")
			actor.chancePanel.spin = (state) => { 
				actor.chancePanel.removeAttribute("chosen")
				actor.chancePanel.classList.toggle("spinning", state) 
				actor.chancePanel.result.innerHTML = "???"
			}
		
			actor.chancePanel.stopAndResult = () => { 
				let result = rand(1, 5)
				actor.chancePanel.spin(false)
				actor.chancePanel.setAttribute("chosen", result)
		
				return result
			}
			
            if(!user.chancePanel) throw 'ok intrusive spawned wrong';
            let action = this

            user.chancePanel.classList.add("active")
            user.chancePanel.classList.remove("hidden")
            user.chancePanel.spin(true)
            play("talkfairy", 0.6)
            let result

            setTimeout(()=>{
                result = user.chancePanel.stopAndResult()
                playCombatCrit()
            }, 2000)

            setTimeout(()=>{
                switch(result) {
                    case 1: // boom - summon 4 microbstrdbombs
                        user.chancePanel.result.innerHTML = "500 BOMBS!!!!"
                        play('dull', 1, 1.2)

                        if(user.enemyTeam.members.length < 12) {
                            midCombatEnemyAdd("intrusive_bomblet_micro", 'right')
							midCombatEnemyAdd("intrusive_bomblet_micro", 'right')
							midCombatEnemyAdd("intrusive_bomblet_micro", 'left')
							midCombatEnemyAdd("intrusive_bomblet_micro", 'left')
                        } else {
                            useAction(user, env.ACTIONS.special_irradiate, user, {triggerActionUseEvent: false, beingUsedAsync: true})
                        }
            
                        setTimeout(()=>advanceTurn(user), 1000)
                    break

                    case 2: // boom - normal bstrdbomb :P
					case 3:
                        user.chancePanel.result.innerHTML = "BOOM :=)"
                        play('dull', 0.8, 1)

                        if(user.enemyTeam.members.length < 12) {
                            midCombatEnemyAdd("intrusive_bomblet_weak", 'right')
                        } else {
                            useAction(user, env.ACTIONS.special_mass_destabilize, user, {triggerActionUseEvent: false, beingUsedAsync: true})
                        }
            
                        setTimeout(()=>advanceTurn(user), 1000)
                    break

                    case 4: // boom - summon DA MEGABSTRDBOMB!!!!!
                        user.chancePanel.result.innerHTML = "BOOM!! >:=)"
                        play('dull', 0.6, 0.8)

                        if(user.enemyTeam.members.length < 12) {
                            midCombatEnemyAdd("intrusive_bomblet_mega", 'left')
                        } else {
                            useAction(user, env.ACTIONS.special_mass_bite, user, {triggerActionUseEvent: false, beingUsedAsync: true})
                        }
            
                        setTimeout(()=>advanceTurn(user), 1000)
                    break
                }
            }, 3000)

            setTimeout(()=>user.chancePanel.classList.remove("active"), 4500)
        }
    },
	
	env.ACTIONS.special_intrusive_thinkagain = {
        slug: "special_intrusive_thinkagain",
        name: "Intrude::THINK AGAIN",
        type: 'special+nomimic',
        desc: "'Ã¢Â«Â§Ã¢ÂªÂ¶Ã£Â¥Â¥Ã£Â³'",
        help: "SSP IN  THE WHEE L LL LL",
        anim: "",
		itemAction: true, //lying here so imps can't use this because could you fucking imagine
        autohit: true,
        crit: 0,
		possiblePassives: ["light_veilkdrop", "light_humorist", "eyes_dancer", "bone_adaptive", "claws_chitin", "light_glee", "eyes_hypercritical", "malware_drill", "malware_rot", "weak_point"],
        possibleActionPassives: ["impatient", "retaliation", "active_support", "visionary", "flesh_menace", "dull_pragmatist", "spirestone_parry", "hands_penance", "metal_autonomous", "pain_rampage"],
		usage: {
            act: "A GRIM GAMBLE IS MADE"
        },
        noRepeat: true,
        exec: function(user, target, beingUsedAsync) {
			let actor = user

			env.rpg.insertAdjacentHTML('beforeend', `
			<figure id="chancepanel" class="hidden" for="${actor.slug}">
				<img src="/img/sprites/flantrusive/panelbase.gif">
				<div class="wheel">
					<ul>
						<li class="d1">1</li>
						<li class="d2">2</li>
						<li class="d3">3</li>
						<li class="d4">4</li>
					</ul>
				</div>
				<div class="display">
					<ol>
						<li class="d1">1. change</li>
						<li class="d2">2. change</li>
						<li class="d3">3. change</li>
						<li class="d4">4. change</li>
					</ol>
				</div>
				<div class="result">
					<div>
						<span></span>
					</div>
				</div>
			</figure>`)
		
			actor.chancePanel = env.rpg.querySelector(`#chancepanel[for="${actor.slug}"]`)
			actor.chancePanel.result = actor.chancePanel.querySelector(".result span")
			actor.chancePanel.spin = (state) => { 
				actor.chancePanel.removeAttribute("chosen")
				actor.chancePanel.classList.toggle("spinning", state) 
				actor.chancePanel.result.innerHTML = "???"
			}
		
			actor.chancePanel.stopAndResult = () => { 
				let result = rand(1, 5)
				actor.chancePanel.spin(false)
				actor.chancePanel.setAttribute("chosen", result)
		
				return result
			}
			
            if(!user.chancePanel) throw 'ok intrusive spawned wrong';
            let action = this

            user.chancePanel.classList.add("active")
            user.chancePanel.classList.remove("hidden")
            user.chancePanel.spin(true)
            play("talkfairy", 0.6)
            let result

            setTimeout(()=>{
                result = user.chancePanel.stopAndResult()
                playCombatCrit()
            }, 2000)

            setTimeout(()=>{
                switch(result) {
                    case 1: // think again - re-use intrude
                        user.chancePanel.result.innerHTML = "AGAIN! AGAIN!"
                        useAction(user, env.ACTIONS.special_intrusive_mega, user, {triggerActionUseEvent: false, beingUsedAsync: false})
                    break

                    case 2: // think again - normal change :P
					case 3:
                        user.chancePanel.result.innerHTML = "THINK AGAIN"
                        env.GENERIC_ACTIONS.teamWave({
                            arbitraryActorList: env.rpg.turnOrder,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: 0,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talkfairy',
                                        rate: 0.5
                                    },
                                    genExec: ({target}) => {
                                        let currentStatuses = target.statusEffects.map(status => status.slug)
                                        let possiblePassives = this.possiblePassives.filter(statusName => !currentStatuses.includes(statusName))

                                        console.log("in with", target, possiblePassives)

                                        //special ones can happen on certain creatures
                                        if(
                                            !target.slug.includes("intrusive") ||
                                            target.slug.includes("intrusive_bishopfreak")
                                        ) possiblePassives.push("visionary")

                                        if(
                                            !target.slug.includes("intrusive") ||
                                            target.slug.includes("intrusive_bishopfreak") ||
                                            target.slug.includes("intrusive_statusoid")
                                        ) possiblePassives.push("active_support")

                                        if(
                                            !target.slug.includes("intrusive") ||
                                            target.slug.includes("intrusive_bishopfreak") ||
                                            target.slug.includes("intrusive_statusoid")
                                        ) possiblePassives.push("impatient")
                                        
                                        // remove passive beforehand if one exists
                                        if(target.intrusivePassive) { removeStatus(target, target.intrusivePassive, {forceRemoveStatus: true}) }
                                        target.intrusivePassive = possiblePassives.sample()
                                        addStatus({target, status: target.intrusivePassive, length: 1, noReact: true})                                        
                                    }
                                })
                            },
                            advanceAfterExec: true, beingUsedAsync, user,
                        })
                    break

                    case 4: // think again - action impulses for everyone!!!! (these ones don't get replaced)
                        user.chancePanel.result.innerHTML = "THINK AGAIN"
                        env.GENERIC_ACTIONS.teamWave({
                            arbitraryActorList: env.rpg.turnOrder,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: 0,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talklaugh',
                                        rate: 0.5
                                    },
                                    genExec: ({target}) => {
                                        let currentStatuses = target.statusEffects.map(status => status.slug)
                                        let possiblePassives = this.possibleActionPassives.filter(statusName => !currentStatuses.includes(statusName))

                                        console.log("in with", target, possiblePassives)

                                        target.intrusivePassive = possiblePassives.sample()
                                        addStatus({target, status: target.intrusivePassive, length: 1, noReact: true})                                        
                                    }
                                })
                            },
                            advanceAfterExec: true, beingUsedAsync, user,
                        })
                    break
                }
            }, 3000)

            setTimeout(()=>user.chancePanel.classList.remove("active"), 4500)
        }
    },
	//mass restore doesn't exist anymore !! oops !!
	env.ACTIONS.special_restore_allies = {
        slug: "special_restore_allies",
        name: "Mass Restore",
        type: 'special',
        desc: "'project broad reparative applicators';'restore allies to fighting condition'",
        help: "ALLIES::+3HP +2T:REGEN -PUNCTURE -DOWN",
        anim: "heal",
        autohit: true,
        amt: -3,
        usage: {
            act: "%USER DEPLOYS A SHIMMERING METALLIC MIST"
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
                    if(actor.slug == user.slug) return
                    env.GENERIC_ACTIONS.singleTarget({
                        beneficial: true,
                        action, 
                        user, 
                        target,
                        hitStatus: {name: 'regen', length: 2},
                        hitSfx: {
                            name: 'mend',
                            rate: 1
                        },
                        genExec: ({target})=>{
                            if(target.state == "dead") {
                                target.hp = 3
                                combatRevive(target)
                                reactDialogue(target, 'receive_rez')
                                addStatus({target: target, origin: user, status: "evasion", length: 2, noReact: true}); 
                            }
                        }                
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
	
	env.ACTIONS.special_intrusive_lucky = {
        slug: "special_intrusive_lucky",
        name: "Intrude::LUCKY",
        type: 'special+nomimic',
        desc: "'Ã¢Â«Â§Ã¢ÂªÂ¶Ã£Â¥Â¥Ã£Â³'",
        help: "SSP IN  THE WHEE L LL LL",
        anim: "",
		itemAction: true, //lying here so imps can't use this because could you fucking imagine
        autohit: true,
        crit: 0,
		possibleAllies: ["intrusive_blocker_weak_ally", "intrusive_archival_weak_ally", "intrusive_bishopfreak_weak_ally", "intrusive_statusoid_weak_ally" ],
		possibleWeakAllies: ["intrusive_blocker_micro_ally", "intrusive_archival_micro_ally", "intrusive_bishopfreak_micro_ally", "intrusive_statusoid_micro_ally" ],
		possibleMegaAllies: ["intrusive_blocker_mega_ally", "intrusive_archival_mega_ally", "intrusive_bishopfreak_mega_ally", "intrusive_statusoid_mega_ally" ],
        usage: {
            act: "A GRIM GAMBLE IS MADE"
        },
        noRepeat: true,
        exec: function(user, target, beingUsedAsync) {
			let actor = user

			env.rpg.insertAdjacentHTML('beforeend', `
			<figure id="chancepanel" class="hidden" for="${actor.slug}">
				<img src="/img/sprites/flantrusive/panelbase.gif">
				<div class="wheel">
					<ul>
						<li class="d1">1</li>
						<li class="d2">2</li>
						<li class="d3">3</li>
						<li class="d4">4</li>
					</ul>
				</div>
				<div class="display">
					<ol>
						<li class="d1">1. lucky</li>
						<li class="d2">2. lucky</li>
						<li class="d3">3. lucky</li>
						<li class="d4">4. lucky</li>
					</ol>
				</div>
				<div class="result">
					<div>
						<span></span>
					</div>
				</div>
			</figure>`)
		
			actor.chancePanel = env.rpg.querySelector(`#chancepanel[for="${actor.slug}"]`)
			actor.chancePanel.result = actor.chancePanel.querySelector(".result span")
			actor.chancePanel.spin = (state) => { 
				actor.chancePanel.removeAttribute("chosen")
				actor.chancePanel.classList.toggle("spinning", state) 
				actor.chancePanel.result.innerHTML = "???"
			}
		
			actor.chancePanel.stopAndResult = () => { 
				let result = rand(1, 5)
				actor.chancePanel.spin(false)
				actor.chancePanel.setAttribute("chosen", result)
		
				return result
			}
			
            if(!user.chancePanel) throw 'ok intrusive spawned wrong';
            let action = this

            user.chancePanel.classList.add("active")
            user.chancePanel.classList.remove("hidden")
            user.chancePanel.spin(true)
            play("talkfairy", 0.6)
            let result

            setTimeout(()=>{
                result = user.chancePanel.stopAndResult()
                playCombatCrit()
            }, 2000)

            setTimeout(()=>{
                switch(result) {
                    case 1: // good time now - summon two microtrusive allies
                        user.chancePanel.result.innerHTML = "GOOD TIM!::E"
                        play('dull', 1, 0.8)
                             
                        if(user.enemyTeam.members.length < 12) {
                            if(user.lastSide) {
                                midCombatAllyAdd(this.possibleWeakAllies.sample(), 'left')
								midCombatAllyAdd(this.possibleWeakAllies.sample(), 'right')
                                user.lastSide = 0
                            } else {
                                midCombatAllyAdd(this.possibleWeakAllies.sample(), 'right')
								midCombatAllyAdd(this.possibleWeakAllies.sample(), 'left')
                                user.lastSide = 1
                            }
                        } else {
                            useAction(user, env.ACTIONS.special_irradiate, user, {triggerActionUseEvent: false, beingUsedAsync: true})
                        }
            
                        setTimeout(()=>advanceTurn(user), 1000)
                    break

                    case 2: // good time now - normal trusive summon (ally edition) :P
					case 3:
                        user.chancePanel.result.innerHTML = "GOOD TIM!::E NO,W!"
                        play('dull', 0.8, 1)
                             
                        if(user.enemyTeam.members.length < 12) {
                            if(user.lastSide) {
                                midCombatAllyAdd(this.possibleAllies.sample(), 'left')
                                user.lastSide = 0
                            } else {
                                midCombatAllyAdd(this.possibleAllies.sample(), 'right')
                                user.lastSide = 1
                            }
                        } else {
                            useAction(user, env.ACTIONS.special_mass_destabilize, user, {triggerActionUseEvent: false, beingUsedAsync: true})
                        }
						
						setTimeout(()=>advanceTurn(user), 1000)
                    break

                    case 4: // good time now - summon 1 megatrusive ally
                        user.chancePanel.result.innerHTML = "!GOOD!! TIM!:!E!! NO,W!!!!"
                        play('dull', 0.6, 1)
                             
                        if(user.enemyTeam.members.length < 12) {
                            if(user.lastSide) {
                                midCombatAllyAdd(this.possibleMegaAllies.sample(), 'left')
                                user.lastSide = 0
                            } else {
                                midCombatAllyAdd(this.possibleMegaAllies.sample(), 'right')
                                user.lastSide = 1
                            }
                        } else {
                            useAction(user, env.ACTIONS.special_restore_allies, user, {triggerActionUseEvent: false, beingUsedAsync: true})
                        }
						
						setTimeout(()=>advanceTurn(user), 1000)
                    break
                }
            }, 3000)

            setTimeout(()=>user.chancePanel.classList.remove("active"), 4500)
        }
    },
	
		//trusive utility aug
    env.ACTIONS.special_intrusive_mega = {
        slug: "special_intrusive_mega",
        name: "Intrude",
        type: 'special+nomimic',
        desc: "'Ã¢Â«Â§Ã¢ÂªÂ¶Ã£Â¥Â¥Ã£Â³'",
        help: "SSP IN  THE WHEE L LL LL",
        anim: "",
		itemAction: true, //lying here so imps can't use this because could you fucking imagine
        autohit: true,
        crit: 0,
        usage: {
            act: "A GRIM GAMBLE IS MADE"
        },
        noRepeat: true,
        exec: function(user, target, beingUsedAsync) {
			let actor = user

			env.rpg.insertAdjacentHTML('beforeend', `
			<figure id="chancepanel" class="hidden" for="${actor.slug}">
				<img src="/img/sprites/flantrusive/panelbase.gif">
				<div class="wheel">
					<ul>
						<li class="d1">1</li>
						<li class="d2">2</li>
						<li class="d3">3</li>
						<li class="d4">4</li>
						<li class="d5">5</li>
						<li class="d6">6</li>
						<li class="d7">7</li>
					</ul>
				</div>
				<div class="display">
					<ol>
						<li class="d1">1. life up</li>
						<li class="d2">2. main up</li>
						<li class="d3">3. unlucky</li>
						<li class="d4">4. bomb</li>
						<li class="d5">5. unlucky</li>
						<li class="d6">6. change</li>
						<li class="d7">7. lucky</li>
					</ol>
				</div>
				<div class="result">
					<div>
						<span></span>
					</div>
				</div>
			</figure>`)
		
			actor.chancePanel = env.rpg.querySelector(`#chancepanel[for="${actor.slug}"]`)
			actor.chancePanel.result = actor.chancePanel.querySelector(".result span")
			actor.chancePanel.spin = (state) => { 
				actor.chancePanel.removeAttribute("chosen")
				actor.chancePanel.classList.toggle("spinning", state) 
				actor.chancePanel.result.innerHTML = "???"
			}
		
			actor.chancePanel.stopAndResult = () => { 
				let result = rand(1, 8)
				actor.chancePanel.spin(false)
				actor.chancePanel.setAttribute("chosen", result)
		
				return result
			}
			
            if(!user.chancePanel) throw 'ok intrusive spawned wrong';
            let action = this

            user.chancePanel.classList.add("active")
            user.chancePanel.classList.remove("hidden")
            user.chancePanel.spin(true)
            play("talkfairy", 0.4)
            let result

            setTimeout(()=>{
                result = user.chancePanel.stopAndResult()
                playCombatCrit()
            }, 2000)

            setTimeout(()=>{
                switch(result) {
                    case 1: // life up - use intrude::life action
                        user.chancePanel.result.innerHTML = "LUCKY! CHA CHA"
                        useAction(user, env.ACTIONS.special_intrusive_life, user, {triggerActionUseEvent: false, beingUsedAsync: false})
                    break

                    case 2: // main up - use intrude::main action
                        user.chancePanel.result.innerHTML = "LUCKY! CHA CHA"
                        useAction(user, env.ACTIONS.special_intrusive_main, user, {triggerActionUseEvent: false, beingUsedAsync: false})
                    break

                    case 3: // use intrude::unlucky action
                    case 5: // unlucky
                        user.chancePanel.result.innerHTML = "BAD TIM!::E NO,W!"
                        useAction(user, env.ACTIONS.special_intrusive_unlucky, user, {triggerActionUseEvent: false, beingUsedAsync: false})
                    break

                    case 4: // bombs - use intrude::bombs action
                        user.chancePanel.result.innerHTML = "BOOM :=)"
                        useAction(user, env.ACTIONS.special_intrusive_bombs, user, {triggerActionUseEvent: false, beingUsedAsync: false})
                    break

                    case 6: // change - use intrude::think again action
                        user.chancePanel.result.innerHTML = "THINK AGAIN"
                        useAction(user, env.ACTIONS.special_intrusive_thinkagain, user, {triggerActionUseEvent: false, beingUsedAsync: false})
                    break
					
					case 7: // lucky - use intrude::lucky action
						user.chancePanel.result.innerHTML = "GOOD TIM!::E NO,W!"
                        useAction(user, env.ACTIONS.special_intrusive_lucky, user, {triggerActionUseEvent: false, beingUsedAsync: false})
                }
            }, 3000)

            setTimeout(()=>user.chancePanel.classList.remove("active"), 15000)
        }
    },
	
    env.ACTIONS.special_intrusive_impulse = {
        slug: "special_intrusive_impulse",
        name: "Gamble",
        type: 'special',
        anim: "",
        autohit: true,
        usage: {
            act: "A GRIM GAMBLE IS MADE"
        },
        details: {
            flavor: "'Ã¢Â«Â§Ã¢ÂªÂ¶Ã£Â¥Â¥Ã£Â³'",
            onUse: `'SSP IN  THE WHEE L LL LL'`,
        },
        noRepeat: true,
        possiblePassives: ["light_veilkdrop", "light_humorist", "eyes_dancer", "bone_adaptive", "claws_chitin", "light_glee", "eyes_hypercritical", "malware_drill", "malware_rot", "weak_point"],
        exec: function(user, target, beingUsedAsync) {
            if(!user.chancePanel) throw 'ok intrusive spawned wrong';
            let action = this

            user.box.classList.add("disable")
            user.chancePanel.classList.add("active")
            user.chancePanel.classList.remove("hidden")
            user.chancePanel.spin(true)

            play("talkfairy", 0.5)
            let result

            setTimeout(()=>{
                result = user.chancePanel.stopAndResult()
                user.box.classList.remove("disable")
                playCombatCrit()
            }, 1000)

            setTimeout(()=>{
                switch(result) {
                    case 1: // life up - gives 5HP and 5 turns of regen to allies
                        user.chancePanel.result.innerHTML = "LUCKY! CHA CHA"
                        env.GENERIC_ACTIONS.teamWave({
                            team: user.team,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: -5,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talklaugh',
                                        rate: 0.5
                                    },
                                    hitStatus: {
                                        name: 'regen',
                                        length: 5
                                    },
                                })
                            },
                            advanceAfterExec: false, beingUsedAsync
                        })
                    break

                    case 2: // main up - allies get focus and empowered
                        user.chancePanel.result.innerHTML = "LUCKY! CHA CHA"
                        env.GENERIC_ACTIONS.teamWave({
                            team: user.team,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: 0,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talklaugh',
                                        rate: 0.5
                                    },
                                    hitStatus: {
                                        name: 'focused',
                                        length: 2
                                    },
                                    genExec: ({target}) => {
                                        addStatus({target, status: "empowered", length: 1, noReact: true})
                                    }
                                })
                            },
                            advanceAfterExec: false, beingUsedAsync
                        })
                    break

                    case 3: // unlucky
                    case 5: // gives enemies focus and empowered
                        user.chancePanel.result.innerHTML = "BAD TIM!::E NO,W!"

                        env.GENERIC_ACTIONS.teamWave({
                            team: user.enemyTeam,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: 0,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talklaugh',
                                        rate: 0.5
                                    },
                                    hitStatus: {
                                        name: 'focused',
                                        length: 2
                                    },
                                    genExec: ({target}) => {
                                        addStatus({target, status: "empowered", length: 1, noReact: true})
                                    }
                                })
                            },
                            advanceAfterExec: false, beingUsedAsync
                        })
                    break

                    case 4: // bombs - spawns a bastard bomb
                        user.chancePanel.result.innerHTML = "BOOM :=)"
                        play('dull', 0.8, 1)

                        if(user.team.members.length < 6) {
                            let bomb = midCombatActorAdd(env.rpg.enemyTeam, "intrusive_bomblet", 'right')
                            if(bomb){
                                addStatus({target: bomb, status: "weak_point", length: 1})
                                addStatus({target: bomb, status: "ethereal", length: 1})
                                delete bomb.statusImmunities
                            }
                        } else {
                            useAction(user, env.ACTIONS.special_mass_destabilize, user, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "???"})
                        }
                    break

                    case 6: // change - gives everyone a special passive that's overridden by each change roll
                        user.chancePanel.result.innerHTML = "THINK AGAIN"
                        env.GENERIC_ACTIONS.teamWave({
                            arbitraryActorList: env.rpg.turnOrder,
                            exec: (actor, i) => {
                                env.GENERIC_ACTIONS.singleTarget({
                                    beneficial: true,
                                    autohit: true,
                                    action,
                                    amt: 0,
                                    canCrit: false,
                                    user, 
                                    target: actor,
                                    hitSfx: {
                                        name: 'talkfairy',
                                        rate: 0.5
                                    },
                                    genExec: ({target}) => {
                                        let currentStatuses = target.statusEffects.map(status => status.slug)
                                        let possiblePassives = this.possiblePassives.filter(statusName => !currentStatuses.includes(statusName))

                                        console.log("in with", target, possiblePassives)

                                        //special ones can happen on certain creatures
                                        if(
                                            !target.slug.includes("intrusive") ||
                                            target.slug == "intrusive_bishopfreak"
                                        ) possiblePassives.push("visionary")

                                        if(
                                            !target.slug.includes("intrusive") ||
                                            target.slug == "intrusive_bishopfreak" ||
                                            target.slug == "intrusive_statusoid"
                                        ) possiblePassives.push("active_support")

                                        if(
                                            !target.slug.includes("intrusive") ||
                                            target.slug == "intrusive_bishopfreak" ||
                                            target.slug == "intrusive_statusoid"
                                        ) possiblePassives.push("impatient")
                                        
                                        // remove passive beforehand if one exists
                                        if(target.intrusivePassive) { removeStatus(target, target.intrusivePassive, {forceRemoveStatus: true}) }
                                        target.intrusivePassive = possiblePassives.sample()
                                        addStatus({target, status: target.intrusivePassive, length: 1, noReact: true})                                        
                                    }
                                })
                            },
                            advanceAfterExec: false, beingUsedAsync
                        })
                    break
                }
            }, 1500)

            setTimeout(()=>user.chancePanel.classList.remove("active"), 3500)
        }
    },
		//lightning primary
	env.ACTIONS.wild_claw = {
        slug: "wild_claw",
        name: "Wild Claw",
        verb: "claw at",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER ATTACKS %TARGET",
            crit: "A FRIGHTENING BLOW",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'utilize wildly unpredictable weaponry';'tendency to strike user if handled improperly'",
            onHit: "'[STAT::amt]';'inflict one of following';'[STATUS::denatured]';'[STATUS::fear] [STATUS::madness]';'[STATUS::stun]'",
			onCrit: "'inflict one of following';'[STATUS::denatured]';'[STATUS::fear] [STATUS::madness]';'[STATUS::stun]'",
			conditional: "<em>MISS::</em>'attack user'"
        },
        stats: {
			//autohit: false, // this is a surprise tool that will help us later
            accuracy: .5,
            crit: 0.5,
            amt: 2,
            status: {
                destabilized: {
                    name: 'destabilized',
                    length: 2
                },
                fear: {
                    name: 'fear',
                    length: 2
                },
                stun: {
                    name: 'stun',
                    length: 1
                },
				denatured: {
                    name: 'denatured',
                    length: 2
                },
				madness: {
                    name: 'madness',
                    length: 1
                },
            },
        },
        exec: function(user, target) {
			let action = this
            return env.GENERIC_ACTIONS.singleTarget({
                action, 
                user, 
                target,
                hitSfx: {
                    name: 'dull',
                    rate: 1.25
                },
				missSfx: { name: 'miss', rate: 0.75 },
				specialAutohit: target == user,
                hitExec: ({target})=> {
                    let rand = Math.random()
                    if(rand < 0.3) {
                        addStatus({target, origin: user, status: "denatured", origin: user, length: 2}); 
                        
                    } else if(rand < 0.6) {
                        addStatus({target, origin: user, status: "fear", origin: user, length: 2}); 
						addStatus({target, origin: user, status: "madness", origin: user, length: 1});
                    } else {
                        addStatus({target, origin: user, status: "stun", origin: user, length: 1}); 
                    }
                },
				critExec: ({target})=> {
                    let rand1 = Math.random()
                    if(rand1 < 0.3) {
                        addStatus({target, origin: user, status: "denatured", origin: user, length: 2}); 
                        
                    } else if(rand1 < 0.6) {
                        addStatus({target, origin: user, status: "fear", origin: user, length: 2});
						addStatus({target, origin: user, status: "madness", origin: user, length: 1});	
                    } else {
                        addStatus({target, origin: user, status: "stun", origin: user, length: 1}); 
                    }
                },
				missExec: ({target})=> {
                    if(user.hp > 0 && user.state != "lastStand") {
                        env.setTimeout(()=>{
                            useAction(user, this, user, {beingUsedAsync: true, reason: "wild claw miss"})
                        }, 400)
                    }
                }
            })
        }
    },   
		//lightning secondary
	env.ACTIONS.denature = {
        slug: "denature",
        name: "Denature",
        type: 'target+self+enemyrandom',
        anim: "heal",

        usage: {
            act: "%USER DENATURES %TARGET",
            crit: "%TARGET RIPPLES WITH INCOHERENCE",
            hit: "%TARGET'S FORM MELTS",
            miss: "%TARGET REMAINS STABLE"
        },

        details: {
            flavor: "'overextend illegal groundsmindry';'greatly alter structure of target'",
            onHit: "'[STATUS::denatured]'",
            onCrit: "'additional [STATUS::denatured]'",
        },

        stats: {
            range: 3,
            autohit: true,
            crit: 0.1,
            status: {
                denatured: {
                    name: 'denatured',
                    length: 3
                },
                vulnerable: {
                    name: 'vulnerable',
                    length: 2
                },
                evasion: {
                    name: 'evasion',
                    length: 1
                },
            }
        },
        
        ignoresBlocks: true,
        ignoresLOS: true,
        aoe: { 
            size: 1, 
            canHit: (actor) => { return true } 
        },
        
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: { name: 'destabilize' },
                critSfx: { name: 'destabilize' },
                critStatus: this.stats.status.denatured,
                hitStatus: this.stats.status.denatured,
                hitExec: ({target}) => {
                    if(checkItem("core_translation") && check("PAGE!!embassy_day", 3.99)) {
                        if(target.team.name != user.team.name) {
                            addStatus({target, status: this.stats.status.vulnerable.name, length: this.stats.status.vulnerable.length})
                        } else {
                            addStatus({target, status: this.stats.status.evasion.name, length: this.stats.status.evasion.length})
                        }
                    }
                }
            })
        },
    },
		//lightning utility
    env.ACTIONS.special_invite_storm_mega = {
        slug: "special_invite_storm_mega",
        name: "Command Storm",
        type: 'special',
        anim: "",
        usage: {
            act: "%USER SPEAKS MADNESS"
        },
        details: {
            flavor: "'direct chaos unto foes';'mark self for death'",
            onUse: `'[STATUS::denatured] [STATUS::vulnerable_mega]';'HIT all foes'`,
            onHit: `'inflict one of following';'[STATUS::denatured]';'[STATUS::fear] [STATUS::madness]';'[STATUS::stun]'`,
            conditional:`<em>SPECIAL::</em>'5% chance to reduce foe HP by 90%'`
        },
        stats: {
            status: {
                denatured: {
                    name: 'denatured',
                    length: 2
                },
                vulnerable_mega: {
                    name: 'vulnerable_mega',
                    length: 2
                },
                fear: {
                    name: 'fear',
                    length: 2
                },
                stun: {
                    name: 'stun',
                    length: 1
                },
				madness: {
                    name: 'madness',
                    length: 1
                },
            },
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkfairy", 0.5)
            addStatus({target: user, status: "denatured", length: 2});
            addStatus({target: user, status: "vulnerable_mega", length: 2});
			
            let power = 0 
            if(hasStatus(user, "fated_lightning")) {
                if(user?.member?.components) for (const [slotName, slotContents] of Object.entries(user.member.components)) { if(slotContents == "lightning") power++ }
                if(user?.member?.augments) for (const augmentSlug of user.member.augments) { let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]; if(augment?.component) if(augment.component[1] == "lightning") power += 2 }
            }

            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
                    let rand = Math.random()
                    if(rand < 0.2) {
                        play("talkfairy", 2)
                        addStatus({target: actor, origin: user, status: "denatured", length: 2}); 
                        
                    } else if(rand < 0.4) {
                        play("fear", 1)
                        addStatus({target: actor, origin: user, status: "fear", length: 2}); 
						addStatus({target: actor, origin: user, status: "madness", length: 1}); 

                    } else {
                        play("fear", 2)
                        addStatus({target: actor, origin: user, status: "stun", length: 1}); 
                    }

                    if(Math.random() < 0.05 + (0.05 * power)) {
                        
                        sendFloater({
                            target: actor,
                            type: "arbitrary",
                            specialClass: "fate",
                            arbitraryString: "CHAOS REIGNS",
                            size: 2
                        })
                        
                        actor.hp = Math.floor(actor.hp * 0.1)

                        //special handling for weird hp usage
                        let conjoin = actor.statusEffects.find(status=>status.slug == "conjoined")
                        if(conjoin) conjoin.events.onCombatHit();
                        updateStats({actor})
                    }
                },
                
                advanceAfterExec: true, beingUsedAsync, user,
                endCallback: ()=>{console.log('just called advance')}
            })
        }
    },
		//lightning primary aug
	env.ACTIONS.revise_all = {
        slug: "revise_all",
        name: "Instant Rewrite",
        type: 'target',
		verb: "rewrite",
        anim: "basic-attack",
        usage: {
            act: "%USER GRASPS BEYOND %TARGET",
            crit: "%TARGET'S TEAM IS SUBVERTED",
            hit: "%TARGET FEELS SOMETHING TORN AWAY",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: `'strike at foes and grasp beyond flesh'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'<em>invert beneficial statuses of target's team</em>'`,
			conditional: "<em>MISS::</em>'attack user'"
        },
        stats: {
			autohit: false, // this is a surprise tool that will help us later
            accuracy: .5,
            crit: 0.5,
            amt: 2,
		},
        exec: function(user, target) {
			let action = this
            return env.GENERIC_ACTIONS.singleTarget({
                action, 
                user, 
                target,
				hitSfx: {
                    name: 'dull',
                    rate: 1.25
                },
				missSfx: { name: 'miss', rate: 0.75 },
				specialAutohit: target == user,
				missExec: ({target})=> {
                    if(user.hp > 0 && user.state != "lastStand") {
                        env.setTimeout(()=>{
                            useAction(user, this, user, {beingUsedAsync: true, reason: "instant rewrite miss"})
                        }, 400)
                    }
                },
                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: target.team,
                    exec: (actor, i)=>{
                        invertStatuses(actor, (statusObj)=>statusObj.beneficial)
                        play('talkfairy', 0.75);
                    }
                })
            })
        }
    },
		//lightning secondary aug
    env.ACTIONS.special_mass_denature = {
        slug: "special_mass_denature",
        name: "Denature Thoughtspace",
        type: 'special',
        anim: "wobble",
        autohit: true,
        usage: {
            act: "THE THOUGHTSPACE GROWS VIOLENT"
        },
        details: {
            flavor: "'afflict all nearby entities with incoherence'",
            onUse: `'[STATUS::denatured] to all actors'`,
        },
        stats: {
            status: {
                denatured: {
                    name: 'denatured',
                    length: 2
                }
            },
        },
        exec: function(user, target, beingUsedAsync) {
            if(env.rpg.classList.contains("bastard")) {                
                if(user.team.name == "ally") {
                    env.rpg.classList.add('incoherentbg')
                    content.classList.add('painprep', 'painfade', 'painhalf')
                    setTimeout(()=>{content.classList.add('painmode')}, 100)
                    setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                    setTimeout(()=>{content.classList.remove('painprep', 'painfade', 'painhalf')}, 5000)

                    setTimeout(()=>{env.rpg.classList.remove('incoherentbg')}, 4000)
                }
            } else {
                ratween(env.bgm, 1, 2000)
                env.rpg.classList.add('incoherentbg')
                content.classList.add('painprep', 'painhalf')
                setTimeout(()=>{content.classList.add('painmode')}, 100)
                setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                setTimeout(()=>{content.classList.remove('painprep', 'painhalf')}, 5000)
            }
            
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        autohit: true,
                        hitSfx: {
                            name: 'destabilize',
                            rate: 0.75
                        },
                        genExec: ({target}) => {
                            addStatus({target: actor, origin: user, status: "denatured", length: 2});
                        }
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
		//lightning utility aug
    env.ACTIONS.special_invoke_blindness = {
        slug: "special_invoke_blindness",
        name: "Invoke Blindness",
        type: 'special',
        anim: "",
        usage: {
            act: "%USER SPEAKS MADNESS"
        },
        details: {
            flavor: "'impart chaos';'afflict foes with blind terror'",
            onUse: `'[STATUS::denatured]';'HIT all foes';`,
            onHit: `'[STATUS::fear] [STATUS::blindness]'`,
            conditional:`<em>SPECIAL::</em>'10% chance to reduce foe HP by 90%'`
        },
        stats: {
            status: {
                denatured: {
                    name: 'denatured',
                    length: 2
                },
                fear: {
                    name: 'fear',
                    length: 2
                },
                blindness: {
                    name: 'blindness',
                    length: 1
                }
            },
        },
        autohit: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkfairy", 0.25)
            addStatus({target: user, status: "denatured", length: 2});

            let power = 0
            if(hasStatus(user, "fated_lightning")) {
                if(user?.member?.components) for (const [slotName, slotContents] of Object.entries(user.member.components)) { if(slotContents == "lightning") power++ }
                if(user?.member?.augments) for (const augmentSlug of user.member.augments) { let augment = env.ACTOR_AUGMENTS.generic[augmentSlug]; if(augment?.component) if(augment.component[1] == "lightning") power += 2 }
            }

            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "fear", length: 2}); 
                    addStatus({target: actor, origin: user, status: "blindness", length: 2});

                    if(Math.random() < 0.1 + (0.05 * power)) {
                        
                        sendFloater({
                            target: actor,
                            type: "arbitrary",
                            specialClass: "fate",
                            arbitraryString: "CHAOS REIGNS",
                            size: 3
                        })
                        
                        actor.hp = Math.floor(actor.hp * 0.1)

                        //special handling for weird hp usage
                        let conjoin = actor.statusEffects.find(status=>status.slug == "conjoined")
                        if(conjoin) conjoin.events.onCombatHit();
                        updateStats({actor})
                    }
                },
                
                advanceAfterExec: true, beingUsedAsync, user,
                endCallback: ()=>{console.log('just called advance')}
            })
        }
    },
		//heart primary (unused)
    env.ACTIONS.arch_punch_flat = {
        slug: "arch_punch_flat",
        name: "Assault",
        type: 'target',
        anim: "basic-attack",

        usage: {
            act: "%USER CHARGES %TARGET",
            crit: "%TARGET IS KNOCKED BACK",
            hit: "%TARGET STAGGERS",
            miss: "%TARGET EVADES"
        },

        details: {
            onHit: `'boldly assault for [STAT::amt]'`,
            onCrit: `'inflict immense physical trauma';'[STATUS::stun]'`,
        },

        stats: {
            accuracy: 0.8,
            crit: 0.2,
            amt: 2,
            status: {
                stun: {
                    name: 'stun',
                    length: 1
                }
            }
        },

        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                critStatus: this.stats.status.stun
            })
        }
    },
		//unused
	env.ACTIONS.special_invitation = {
		slug: "special_invitation",
		name: "Invitation",
		type: 'special',
		anim: "skitter",
		details: {
			onUse: "'HIT all foes'",
			onHit: "'[STAT::amt]'",
			onCrit: "'[STATUS::weakened]'",
		},
		stats: {
			accuracy: .7,
			crit: 0.2,
			amt: 1,
			status: {
				weakened: {
					name: 'weakened',
					length: 1
				},
			},
		},
		usage: {
			act: "%USER DRAWS IN RESOURCES"
		},
		exec: function(user, target, beingUsedAsync) {
			let action = this

			env.GENERIC_ACTIONS.teamWave({
				team: user.enemyTeam,
				exec: (actor, i) => {
					env.GENERIC_ACTIONS.singleTarget({
						action: action, 
						user, 
						target: actor,
						hitSfx: { name: 'talksignal' },
						critSfx: { name: 'fear', rate: 1 },
						critStatus: {
							name: 'weakened',
							length: 1
						}
					})
				},
				advanceAfterExec: true, beingUsedAsync, user,
			})
		}
	},
		//heart utility
    env.ACTIONS.evade_hyper = {
        slug: "evade_hyper",
        name: "Rush",
        type: 'autohit',
        anim: "",
        beneficial: true,
        usage: {
            act: "%USER CHARGES FORWARD"
        },
        details: {
            flavor: "'move quickly';'overexert cognitive facilities';'consider all immediate possibilities'",
            onUse: `'gain [STATUS::hyperfocus_flat]'`
        },
        stats: {
            status: {
                hyperfocus_flat: {
                    name: 'hyperfocus_flat',
                    length: 1
                }
            }
        },
        exec: function(user, target) {
            play('mend', 0.5);
            addStatus({target: user, status: "hyperfocus_flat", length: 1, noReact: true}); 
            return 'nothing';
        },
        disableIf: (actor)=>{ if(hasStatus(actor,"fear")) return "PROHIBITED BY FEAR" },
        avoidChaining: true
    },
		//heart primary augment (might be fun and silly to make it the base primary though
    env.ACTIONS.grasp_weak = {
        slug: "grasp_weak",
        name: "Grasp",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER GRASPS AT %TARGET",
            crit: "%TARGET IS CRUSHED",
            hit: "%TARGET IS CAUGHT",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'utilize gauntlet';'immobilize and crush target';'leave critically open to attack'",
            onUse: `'[STAT::amt] [STATUS::vulnerable]'`,
            onCrit: `'[STATUS::stun]'`,
        },
        stats: {
            accuracy: 0.7,
            crit: 0.1,
            amt: 1,
            status: {
                stun: { name: 'stun', length: 2 },
                vulnerable: { name: 'vulnerable', length: 1 },
            },
        },
        exec: function(user, target) {
            removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'hit',
                    rate: 2
                },

                hitExec: ({target})=> {
                    addStatus({target, status: "vulnerable", length: 1, noReact: true});
                },

                critExec: ({target})=>{
                    addStatus({target, status: "stun", length: 2}); 
                }
            })
        }
    },
		//da REAL heart primary augment (holy shit cripple is busted)
	env.ACTIONS.cripple_heart = {
        slug: "cripple_heart",
        name: "Cripple",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER JABS AT %TARGET'S WEAPONRY",
            crit: "%TARGET IS CRIPPLED",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'strike neural center of target';'guaranteed disorientation'",
            onUse: `'[STAT::amt] [STATUS::stun]'`,
            onCrit: `'[STATUS::vulnerable]'`,
        },
        stats: {
            accuracy: 0.7,
            crit: 0.1,
            amt: 1,
            status: {
                vulnerable: { name: 'vulnerable', length: 2 },
                stun: { name: 'stun', length: 1 },
            },
        },
        exec: function(user, target) {
            removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'hit',
                    rate: 2
                },
                hitExec: ({target})=> {
                    addStatus({target, status: "stun", length: 1, noReact: true});
                },
                critExec: ({target})=>{
                    addStatus({target, status: "vulnerable", length: 2}); 
                }
            })
        }
    },
		//heart secondary augment
	env.ACTIONS.special_falseprayer_foes = {
        slug: "special_falseprayer_foes",
        name: "Okidoia",
        type: 'special+nomimic+summon',
        anim: "heal",
		itemAction: true, //lying here so imps can't use this because could you fucking imagine
		beneficial: false,
        usage: {
            act: "%USER SINGS A DISCORDANT MELODY"
        },
		details: {
            onUse: "'ATTACK all foes'",
            onHit: "'inflict one of following';'-2HP, -REGEN';'[STATUS::weakened]';'[STATUS::fear]';'[STATUS::cursed]'",
			onCrit: "'summon spectral ally'",
        },
        stats: {
            accuracy: 0.7,
            crit: 0.1,
            amt: 0,
            status: {
				weakened: { name: 'weakened', length: 1 },
				fear: { name: 'fear', length: 1 },
				cursed: { name: 'cursed', length: 2},
            },
        },
        exec: function(user, target, beingUsedAsync) {
			let fated = user.statusEffects.find(status => status.slug == "fated_heart")
            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
					env.GENERIC_ACTIONS.singleTarget({
						user: user,
						target: actor,
						action: this,
						beneficial: true,
						hitSfx: {
							name: 'okidoia',
							rate: 1
						},
						critSfx: {
							name: 'scarydoia',
							rate: 1
						},
						hitExec: ({target})=> {
							let rand = Math.random()
							if(rand < 0.25) {
								removeStatus(target, "regen")
								combatHit(target, {amt: 2, origin: user, autohit: true});
							} else if(rand < 0.5) {
								addStatus({target, origin: user, status: "weakened", origin: user, length: 1}); 
							} else if(rand < 0.75) {
								addStatus({target, origin: user, status: "fear", origin: user, length: 1});
							} else {
								addStatus({target, origin: user, status: "cursed", origin: user, length: 2}); 
							}
						},
						critExec: ({target})=> {
							let rand1 = Math.random()
							let heart_peasant = ['heart_formless', 'heart_formless', 'heart_formless_enraged', 'heart_formless_enraged', 'heart_puncher', 'heart_harasser', 'heart_bomber', 'heart_puller', 'heart_support']
							let heart_royal = ['heart_channeler', 'heart_channeler', 'heart_charger', 'heart_keeper', 'heart_keeper', 'heart_golem']
							let newAllySlug = heart_peasant.sample()
							let newAllySlug1 = heart_royal.sample()
							if (rand1 < 0.75) {
								user.lastSide = !user.lastSide
								if(user.team.members.filter(m=>m.slug.includes('heart')).length < (fated ? fated.power + 4 : 4)) {
									midCombatAllyAdd(newAllySlug, user.lastSide ? "left" : "right")
								}
							}
							else {
								user.lastSide = !user.lastSide
								if(user.team.members.filter(m=>m.slug.includes('heart')).length < (fated ? fated.power + 4 : 4)) {
									midCombatAllyAdd(newAllySlug1, user.lastSide ? "left" : "right")
								}
							}
						}
					})
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
		//heart utility augment
	env.ACTIONS.coordination_hyper = {
        slug: "coordination_hyper",
        name: "Coordinated Assault",
        type: 'self+autohit+support',
        anim: "",
        usage: {
            act: "%USER SHOUTS ORDERS"
        },
        details: {
            flavor: "'guide entire team to charge forward'",
            onUse:`'[STATUS::hyperfocus_flat] to all allies'`,
        },
        stats: {
            autohit: true,
            crit: 0,
            status: {
                hyperfocus_flat: {
                    name: 'hyperfocus_flat',
                    length: 1
                },
            },
        },
        autohit: true,
        disableIf: (actor)=>{ if(hasStatus(actor,"fear")) return "PROHIBITED BY FEAR" },
        exec: function(user, target) {
            play("talkchoir7", 1.5)


            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "hyperfocus_flat", origin: user, length: 1, noReact: true}); 
                    play('mend', 0.5);
                }
            })

            return 'nothing'
        }
    }
		//chaos utility
	env.ACTIONS.focused_shot_weak = {
        slug: "focused_shot_weak",
        name: "Focused Shot",
        verb: "shoot",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER FIRES AT %TARGET",
            crit: "%TARGET IS TORN APART",
            hit: "%TARGET TAKES A BIG HIT",
            miss: "%USER MISSES"
        },
        details: {
            flavor: "'well-placed high-caliber shot';'immense physical trauma'",
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable] [STATUS::stun] [STATUS::critical_flaw]'`,
        },
        stats: {
            accuracy: 1,
            crit: 0.4,
            amt: 4,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 3
                },
                stun: {
                    name: 'stun',
                    length: 1
                },
                critical_flaw: {
                    name: 'critical_flaw',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
            removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'shot',
                    rate: 1.25
                },
                critSfx: {
                    name: 'shot',
                    rate: 1.5
                },
                missSfx: { name: "shot2", rate: 0.9 },

                critExec: ({target})=>{
                    addStatus({target, status: "vulnerable", length: 3}) 
                    addStatus({target, status: "stun", length: 1}) 
					setTimeout(()=>{
						addStatus({target, status: "critical_flaw", length: 1, noReact: true})
					}, 200)
                }
            })
        }
    },
		//chaos primary aug
	env.ACTIONS.fullauto_shotgun = {
        slug: "fullauto_shotgun",
        name: "Boomstick",
        type: 'target',
        anim: "wobble",
		verb: "blast",
        usage: {
            act: "%USER BLASTS %TARGET",
        },
        details: {
            flavor: "'utilize symbiotic shotgun';'rapid attacks on single target';'consumes HP for munitions'",
            onUse: `'HIT target 8 times';'[STAT::amt] to self'`,
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable]'`
        },
        stats: {
            accuracy: .2,
            crit: 0.2,
            amt: 1,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
            let animElement = user.sprite || user.box
            let initialRate = env.bgm.rate()

            animElement.classList.add('aiming')
            if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, initialRate + 0.5)
            play('click1')

            //damage self on use if you aren't bstrd
            if(!["BSTRD Golem", "BSTRD", "Gun Golem", "EFGY"].includes(user.name)) combatHit(user, {amt: 1, crit: 0, autohit: true, origin: user})

            let anim = env.COMBAT_ANIMS.shoot

            if(target) for (let i = 0; i < 8; i++) {
                let baseDelay = ((env.ADVANCE_RATE * 0.05) * i)
                let animDelay = baseDelay + anim.duration;

				setTimeout(()=>anim.exec(this, user, target), baseDelay)
				setTimeout(()=>{
					env.GENERIC_ACTIONS.singleTarget({
						action: this, 
						user, 
						target,
						hitSfx: { name: "shot2", volume: 0.5 },
						critSfx: { name: "shot6" },
						missSfx: { name: "shot2", rate: 1.5, volume: 0.5 },
						critStatus: {
							name: 'vulnerable',
							length: 1
						}
					})

					animElement.classList.add('scramble')
					setTimeout(()=>animElement.classList.remove('scramble'), 100)
				}, animDelay)
            }

            setTimeout(()=>{
                animElement.classList.remove('aiming')                
                if(!beingUsedAsync) advanceTurn(user)
                if(!env.rpg.classList.contains("standoff")) ratween(env.bgm, env.bgm.intendedRate)
            }, (env.ADVANCE_RATE * 0.05) * 9)
        }
    },
		//chaos secondary aug
	env.ACTIONS.frenzy_sidearm = {
        slug: "frenzy_sidearm",
        name: "Forced Reset",
        type: 'target',
        anim: "basic-attack",
        verb: "shoot",
        usage: {
            act: "%USER FIRES AT %TARGET",
            crit: "%USER JUST KEEPS GOING",
            hit: "%TARGET IS STRUCK",
            miss: "%USER MISSES"
        },
        details: {
            flavor: "'utilize illegal sidearm';'may inspire additional shots'",
            onHit: `'[STAT::amt]'`,
            onCrit:`'[STATUS::vulnerable]';'use this action again'`,
        },
        stats: {
            accuracy: .6,
            crit: 0.15,
            amt: 1,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'shot',
                    rate: 1
                },
                critSfx: {
                    name: 'shot',
                    rate: 1.35
                },
				critExec: ({target})=> {
                    if(target.hp > 0 && target.state != "lastStand" && !user.frenzyChainKilled) {
                        env.setTimeout(()=>{
                            useAction(user, this, target, {beingUsedAsync: true, reason: "forced reset"})
                        }, 250)
                    }
                },
                missSfx: { name: "shot2", rate: 0.9 },
            })
        }
    },
		//chaos utility aug (hip shot replacement)
	env.ACTIONS.spy_laser = {
        slug: "spy_laser",
        name: "Target",
        type: 'target',
        anim: "spying",
        animDuration: 2000,
        frameClass: "temp-perspective", // special class added to RPG div while active
        usage: {
            act: "%USER AIMS AT %TARGET",
            hit: "%TARGET FEELS TARGETED",
            miss: "%TARGET HIDES BEHIND SOMETHING"
        },
        details: {
			flavor: `'utilize and misuse guiding laser'`,
            onUse: `'[STATUS::vulnerable]'`,
        },
        stats: {
            range: 5,
            autohit: true,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 3
                }
            }
        },
        exec: function(user, target) {
            reactDialogue(user, `give_vulnerable`)
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'megastatus',
                    rate: 1
                },
                hitStatus: this.stats.status.vulnerable,
            })
        },
    },
		//chaos utility aug (take aim replacement)
	env.ACTIONS.reload_missile = {
        slug: "reload_missile",
        name: "Reload",
        type: 'autohit',
        anim: "",
        usage: {
            act: "%USER PREPARES AN ATTACK..."
        },
        details: {
            flavor: "'prepare devastating attack';'load weapon';'lose windup if attention diverted'",
            onUse: `'[STATUS::windup] [STATUS::evasion] [STATUS::rocket_bearer]'`,
        },
        stats: {
            status: {
                evasion: {
                    name: 'evasion',
                    length: 1
                },
                windup: {
                    name: 'windup',
                    length: 1
                },
				rocket_bearer: {
                    name: 'rocket_bearer',
                    length: 1
                },
            },
        },
        exec: function(user, target) {
			user.windupActions = user.windupActions.filter(action => action !== "focused_shot_weak") // we still don't have a good way to replace windup actions, so we quietly remove the original windup actions in reload instead
			user.windupActions = user.windupActions.filter(action => action !== "hold_aim") // this'll be confusing in the critta menu but shhhhh
			if(user.windupActions.includes("special_judgement_player")) {
				user.windupActions = user.windupActions.filter(action => action !== "special_rule_player")
			}
			if(user.windupActions.includes("haymaker")) {
				user.windupActions = user.windupActions.filter(action => action !== "archival_smash")
			}
			if(user.windupActions.includes("special_combinesummon_select")) {
				user.windupActions = user.windupActions.filter(action => action !== "special_combinesummon")
			}
            play("talkgel", 0.6)
            addStatus({target: user, status: "evasion", length: 1, noReact: true}); 
            addStatus({target: user, status: "windup", length: 1}); 
			addStatus({target: user, status: "rocket_bearer", length: 1, noReact: true}); 
            return 'nothing';
        }
    },
		//chaos utility aug (focused shot replacement sorta)
	env.ACTIONS.focused_shot_missile = {
        slug: "focused_shot_missile",
        name: "RPG",
        verb: "launch",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER FIRES AT %TARGET",
            crit: "%TARGET'S TEAM EXPLODES",
            hit: "%TARGET EXPLODES",
            miss: "%USER MISSES"
        },
        details: {
            flavor: "'utilize laser guided missile launcher';'immense physical trauma'",
            onHit: `'[STAT::amt] [STATUS::vulnerable]'`,
            onCrit:`'HIT all foes for [STAT::amt] [STATUS::vulnerable]';'additional hits trigger on-hit effects'`,
        },
        stats: {
            accuracy: 1,
            crit: 0.4,
            amt: 3,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                },
                stun: {
                    name: 'stun',
                    length: 1
                },
                critical_flaw: {
                    name: 'critical_flaw',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'shot1',
                    rate: 0.75
                },
                critSfx: {
                    name: 'shot',
                    rate: 0.5
                },
                missSfx: { name: "shot5", rate: 0.75 },

                hitExec: ({target})=>{
                    addStatus({target, status: "vulnerable", length: 1}) 
                },
				critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i)=>{
                        combatHit(actor, {amt: 3, crit: 0, accuracy: 1, origin: user});
                        addStatus({target: actor, status: "vulnerable", length: 1}); 
                        play("shot", 0.5)
                    }
                })
            })
        }
    },
		//chaos utility aug (da REAL focused shot replacement)
	env.ACTIONS.special_enact_missile = {
        slug: "special_enact_missile",
        name: "Launch Missiles",
        type: 'special',
        anim: "basic-attack",
        verb: "enact upon",
        details: {
            flavor: "'unleash flurry of missiles upon foes'",
            onUse: `'launch missile at random foes per T:[STATUS::rocket_bearer]';'lose all [STATUS::rocket_bearer]'`,
			onHit: `'PER MISSILE::[STAT::selfHP] [STATUS::vulnerable]'`,
            onCrit:`'PER MISSILE CRIT::HIT all foes for [STAT::selfHP] [STATUS::vulnerable]';'additional hits trigger on-hit effects'`,
        },
		stats: {
            accuracy: 1,
            crit: 0.4,
            selfHP: 3,
            status: {
                vulnerable: {
                    name: 'vulnerable',
                    length: 1
                },
				rocket_bearer: { name: "rocket_bearer", showReference: true }
            },
        },
        autohit: true,
        noRepeat: true,
        exec: function(user, target) {
            let amt = Math.floor(hasStatus(target, 'rocket_bearer'))
            removeStatus(user, "rocket_bearer")
			removeStatus(user, "windup")
            let primary = env.ACTIONS.focused_shot_missile
            actionMessage(user, "%USER BESIEGES THEIR FOES", target, 'none', 1000 + (amt * 600))

            for (let i = 0; i < amt; i++) {
                env.setTimeout(()=>{
                    let target = env.rpg.enemyTeam.members.filter(t=>t.state != "dead").sample()
                    if(target) useAction(user, primary, target, {triggerActionUseEvent: i == 0, beingUsedAsync: true, reason: "missile launch", noUseMessage: true})
                }, i * 600)
            }

            env.setTimeout(()=>{
                advanceTurn(user)
            }, (amt * 600) + 500)
        },
        disableIf: (actor)=>{ if(!hasStatus(actor,"rocket_bearer")) return "REQUIRES MUNITIONS" },
    },
	
	env.ACTIONS.plot_reload = {
        slug: "plot_reload",
        name: "Overload",
        type: 'autohit',
        anim: "",
        usage: {
            act: "%USER LOADS ANOTHER MISSILE"
        },
        details: {
            flavor: "'overload missile launcher';'prepare great attack'",
            onUse:`'[STATUS::evasion] [STATUS::rocket_bearer]'`,
        },
        stats: {
            selfHP: 1,
            status: {
                evasion: {
                    name: 'evasion',
                    length: 2
                },
                rocket_bearer: {
                    name: 'rocket_bearer',
                    length: 1
                },
            },
        },
        exec: function(user, target) {
            play('talkgel', 0.75);
            addStatus({target: user, status: "evasion", length: 2, noReact: true}); 
            addStatus({target: user, status: "rocket_bearer", length: 1, noReact: true}); 
            return 'nothing';
        },
    },
		//order primary
	env.ACTIONS.special_rule_player = {
        slug: "special_rule_player",
        name: "Continuous Adjustment",
        type: 'special',
        anim: "",
        usage: {
            act: "%USER SHIFTS THE BALANCE"
        },
        details: {
            flavor: "'utilize status control to empower and repair team';'afflict opponents with critical vulnerability'",
            conditional: "<em>SELF::</em>[STATUS::windup]\n<em>ALLIES::</em>[STAT::amtBP] [STATUS::repairs]\n<em>FOES::</em>[STAT::amt] [STATUS::vulnerable] [STATUS::critical_flaw]",
        },
        stats: {
            accuracy: 1,
            crit: 0,
            amt: 1,
            amtBP: 1,
            status: {
                windup: {
                    name: 'windup',
                    length: 1
                },
                repairs: {
                    name: 'repairs',
                    length: 1
                },
                vulnerable : {
                    name: 'vulnerable',
                    length: 1
                },
                critical_flaw: {
                    name: 'critical_flaw',
                    length: 1
                },
            },
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
            let allyTeam = user.team.name
            let enemyTeam = user.enemyTeam.name
            if(user.sprite) user.sprite.classList.add("basic-attack") 

            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                extraDelay: 150,
                endCallback: () => {
                    if(user.sprite) user.sprite.classList.remove("basic-attack")
                    readoutAdd({
                        message: `${user.name} stays wound up!`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: true,
                        forceMini: true,
                        sfx: false
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
                exec: (actor, i) => {
                    if(actor.slug == user.slug) return;

                    switch(actor.team.name) {
                        case allyTeam:
                            env.GENERIC_ACTIONS.singleTarget({
                                beneficial: true,
								autohit: true,
                                type: 'barrier',
                                action, 
                                user, 
                                target: actor,
                                canCrit: false,
                                hitSfx: {
                                    name: 'mend',
                                    rate: 2
                                },
                                hitStatus: {
                                    name: 'repairs',
                                    length: 1
                                },
                            })
                        break

                        case enemyTeam:
                            env.GENERIC_ACTIONS.singleTarget({
                                action: this, 
                                user, 
								autohit: false,
                                target: actor,
                                hitSfx: {
                                    name: 'talkcroak',
                                    rate: 2
                                },
                                canCrit: false,
                                hitExec: (target) => {
                                    addStatus({origin: user, target: actor, status: "vulnerable", length: 1}); 
                                    addStatus({origin: user, target: actor, status: "critical_flaw", length: 1}); 
                                }
                            })                            
                        break
                    }
                }
            })
        }
    },
		//order secondary
	env.ACTIONS.wound_stab = {
        slug: "wound_stab",
        name: "Eviscerate",
        type: 'target',
        anim: "basic-attack", 
        usage: {
            act: "%USER STABS %TARGET",
            crit: "%TARGET IS TORN APART",
            hit: "%TARGET BLEEDS SLUDGY CORRU",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'utilize positioning appendages to wound target';'create lasting injuries'",
            onHit: `'[STAT::amt] [STATUS::puncture]'`,
            onCrit: ()=> `'wound vital cystic component for [STATUS::open_wound]'${env?.rpg?.is2D ? ";'KB::2'" : ''}`,
        },
        stats: {
            accuracy: 1,
            crit: 0.15,
            amt: 1,
            status: {
                puncture: {
                    name: 'puncture',
                    length: 3
                },
				open_wound: {
                    name: 'open_wound',
                    length: 3
                }
            }
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'stab',
                    rate: 1
                },
				critSfx: {
                    name: 'stab',
                    rate: 0.5
                },
                critStatus: this.stats.status.open_wound,
                hitStatus: this.stats.status.puncture,
            })
        }
    },
		//order utility
	env.ACTIONS.special_player_newprocess = {
		slug: "special_player_newprocess",
		name: "New Process",
		type: 'special+summon',
		anim: "orbshake",
		details: {
			flavor: "'remove resources from foes to create new daemon processes'",
			onHit: `'inflict one of following';'[STATUS::vulnerable], [STATUS::puncture], [STATUS::open_wound]'`,
			onCrit:`'[STAT::selfHP], [STATUS::weakened]';'summon idea (max:4)'`,
		},
		stats: {
			accuracy: .7,
			crit: 0.15,
			amt: 0,
			selfHP: 1,
			status: {
				vulnerable: {
					name: 'vulnerable',
					length: 2
				},
				puncture: {
					name: 'puncture',
					length: 1
				},
				open_wound: {
					name: 'open_wound',
					length: 1
				},
				weakened: {
					name: 'weakened',
					length: 1
				},
			},
		},
		usage: {
			act: "%USER DRAWS IN RESOURCES"
		},
		exec: function(user, target, beingUsedAsync) {
			let action = this
			let myTeam = env.rpg.enemyTeam
			if(user.team.name == "enemy") { myTeam = env.rpg.enemyTeam }
			let fated = user.statusEffects.find(status => status.slug == "fated_order")

			env.GENERIC_ACTIONS.teamWave({
				team: user.enemyTeam,
				exec: (actor, i) => {
					env.GENERIC_ACTIONS.singleTarget({
						action: action, 
						user, 
						target: actor,
						hitSfx: { name: 'talksignal' },
						critSfx: { name: 'fear', rate: 0.75 },
						hitExec: ({target})=> {
							let rand = Math.random()
							if(rand < 0.4) {
								addStatus({target, origin: user, status: "vulnerable", origin: user, length: 2}); 
							} else if(rand < 0.7) {
								addStatus({target, origin: user, status: "puncture", origin: user, length: 1}); 
							} else {
								addStatus({target, origin: user, status: "open_wound", origin: user, length: 1}); 
							}
						},
						critStatus: {
							name: 'weakened',
							length: 1
						},
						critExec: ({target}) => {
						user.lastSide = !user.lastSide
							if(user.team.members.filter(m=>m.slug.includes('order_spawner_bee')).length < (fated ? fated.power + 4 : 4)) {
								if(user.team.name == "enemy") { midCombatActorAdd(myTeam, 'order_spawner_bee', user.lastSide ? "left" : "right") }
								else { midCombatAllyAdd('order_spawner_bee', user.lastSide ? "left" : "right") }
							}
							combatHit(actor, {amt: 1, crit: 0, autohit: true, origin: user});
						}
					})
				},
				advanceAfterExec: true, beingUsedAsync, user,
			})
		}
	},
		//order primary aug
	env.ACTIONS.special_judgement_player = {
        slug: "special_judgement_player",
        name: "Continuous Rewrite",
        type: 'special',
        anim: "",
        details: {
            flavor: "'utilize thoughtspace influence to empower massive strike'",
            onUse: `'[STATUS::windup]';'HIT all foes'`,
            onHit: `'[STAT::amt]'`,
            onCrit: `'[STATUS::destabilized] [STATUS::fear]`
        },
        usage: {
            act: "%USER TURNS THE MEMORY AGAINST THEIR FOES"
        },
        stats: {
            accuracy: 1,
            crit: 0.3,
            amt: 3,
             status: {
                windup: {
                    name: 'windup',
                    length: 2
                },
                destabilized: {
                    name: 'destabilized',
                    length: 2
                },
                fear: {
                    name: 'fear',
                    length: 2
                }, 
            }
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
            if(user.sprite) user.sprite.classList.add("basic-attack")

            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                extraDelay: 200,
                endCallback: () => {
                    if(user.sprite) user.sprite.classList.remove("basic-attack")
                    readoutAdd({
                            message: `${user.name} stays wound up!`, 
                            name: "sourceless", 
                            type: "sourceless combat minordetail", 
                            show: true,
                            forceMini: true,
                            sfx: false
                        })
                    },
                exec: (actor, i) => {
                    if(actor.slug == user.slug) return
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'dull',
                            rate: 1
                        },
                        critExec: ({target})=>{
                            addStatus({target, origin: user, status: "destabilized", length: 2})
                            addStatus({target, origin: user, status: "fear", length: 2})
                        }                
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
		//order secondary aug
	env.ACTIONS.enforce_player = {
        slug: "enforce_player",
        name: "Enforcement",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER STABS %TARGET",
            crit: "%USER JUST KEEPS GOING",
            hit: "%TARGET BLEEDS SLUDGY CORRU",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'relentless assault with positioning appendages';'may inspire additionals smashing'",
            onHit: `'[STAT::amt] [STATUS::puncture]'`,
            onCrit:`'[STATUS::open_wound]';'use this action again'`,
        },
        stats: {
            accuracy: .7,
            crit: 0.075,
            amt: 1,
            status: {
                puncture: {
                    name: 'puncture',
                    length: 2
                },
                open_wound: {
                    name: 'open_wound',
                    length: 2
                }
            },
        },
        exec: function(user, target) {
            let action = this
            return env.GENERIC_ACTIONS.singleTarget({
                action, 
                user, 
                target,
                hitSfx: {
                    name: 'hit',
                    rate: 0.7
                },
                critSfx: {
                    name: 'hit',
                    rate: 1.5
                },
                hitExec: ({target}) => {
                    addStatus({target, status: "puncture", length: 2});
                },
                critExec: ({target})=> {
                    addStatus({target, status: "open_wound", length: 2});
                    if(target.hp > 0 && target.state != "lastStand" && !user.frenzyChainKilled) {
                        env.setTimeout(()=>{
                            useAction(user, this, target, {beingUsedAsync: true, reason: "enforcement"})
                        }, 400)
                    }
                }
            })
        }
    },
		//order utility aug
	env.ACTIONS.special_newprocess_mega = {
		slug: "special_newprocess_mega",
		name: "Reallocate",
		type: 'special+summon',
		anim: "orbshake",
		possibleSpawns: ['order_pawn', 'order_pawn', 'order_knight', 'order_knight', 'order_bishop', 'order_bishop', 'order_rook', 'order_rook', 'order_queen','order_king'],
		possibleMegaSpawns: ['order_pawn_mega', 'order_pawn_mega', 'order_knight_mega', 'order_knight_mega', 'order_bishop_mega', 'order_bishop_mega', 'order_rook_mega', 'order_rook_mega', 'order_queen_mega','order_king_mega'],
		details: {
			flavor: "'remove resources from foes to create new daemon processes'",
			onHit: `'[STAT::amt]'`,
			onCrit:`'[STATUS::weakened]';'summon daemon (max:4)'`,
		},
		stats: {
			accuracy: .7,
			crit: 0.05,
			amt: 1,
			status: {
				weakened: {
					name: 'weakened',
					length: 1
				},
			},
		},
		usage: {
			act: "%USER REARRANGES THE BATTLEFIELD"
		},
		exec: function(user, target, beingUsedAsync) {
			let action = this
			let myTeam = env.rpg.enemyTeam
			if(user.team.name == "enemy") { myTeam = env.rpg.enemyTeam }
			let fated = user.statusEffects.find(status => status.slug == "fated_order")

			env.GENERIC_ACTIONS.teamWave({
				team: user.enemyTeam,
				exec: (actor, i) => {
					env.GENERIC_ACTIONS.singleTarget({
						action: action, 
						user, 
						target: actor,
						hitSfx: { name: 'talksignal', rate: 0.8 },
						critSfx: { name: 'fear', rate: 0.5 },
						critStatus: {
							name: 'weakened',
							length: 1
						},
						critExec: ({target}) => {
						let rand = Math.random()
						user.lastSide = !user.lastSide
						if(rand < 0.75) {
								if(user.team.members.filter(m=>m.slug.includes('order')).length < (fated ? fated.power + 4 : 4)) {
									if(user.team.name == "enemy") { midCombatActorAdd(myTeam, this.possibleSpawns.sample(), user.lastSide ? "left" : "right") }
									else { midCombatAllyAdd(this.possibleSpawns.sample(), user.lastSide ? "left" : "right") }
								}
							}
						else if(rand > 0.75) { 
								if(user.team.members.filter(m=>m.slug.includes('order')).length < (fated ? fated.power + 4 : 4)) {
									if(user.team.name == "enemy") { midCombatActorAdd(myTeam, this.possibleMegaSpawns.sample(), user.lastSide ? "left" : "right") }
									else { midCombatAllyAdd(this.possibleMegaSpawns.sample(), user.lastSide ? "left" : "right") }
								}
							}
						}
					})
				},
				advanceAfterExec: true, beingUsedAsync, user,
			})
		}
	},
		// palestone primary
	env.ACTIONS.bazruka_incendiary = {
        slug: "bazruka_incendiary",
        name: "IID",
        verb: "throw at",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER TOSSES AN EXPLOSIVE AT %TARGET",
            crit: "THE ROOM IS ENGULFED IN FLAMES",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET DODGES"
        },
        details: {
            flavor: `'throw hastily made minor explosive';'chance to ignite fires'`,
            onHit: `'[STAT::amt]'`,
            onCrit: () => `'HIT all foes for [STAT::amt] [STATUS::burning]'${page.name == "frame" ? `;'additional hits trigger on-hit effects'` : ``}`,
        },
        stats: {
            accuracy: .9,
            crit: 0.5,
            amt: 1,
            status: {
                burning: {
                    name: 'burning',
                    length: 2
                }
            },
        },
        exec: function(user, target) {
            let action = this;
            return env.GENERIC_ACTIONS.singleTarget({
                action, 
                user, 
                target,
                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i) => {
                        env.GENERIC_ACTIONS.singleTarget({
                            action, 
                            user, 
                            target: actor,
                            hitSfx: { name: 'shot4' },
                            hitStatus: this.stats.status.burning,
                            canCrit: false
                        })
                    }
                })
            })
        }
    },
		// palestone primary aug
	env.ACTIONS.tozik_attack_cmb = {
        slug: "tozik_attack_cmb",
        name: "Dullskivi",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER CLAWS THROUGH %TARGET",
            crit: "%TARGET'S LIFE IS DRAINED THROUGH THE DULL",
            hit: "%TARGET FEELS SOMETHING TORN AWAY",
            miss: "%TARGET DODGES"
        },
        details: {
            flavor: `'attack with improvised dull-connected repair tool';'bypass flesh to siphon vital corru'`,
            onHit: `'[STAT::amt]'`,
            onCrit: `'heal nearby allies for [STAT::healHP] [STATUS::antidote]'`,
        },
        stats: {
            accuracy: 0.8, 
            crit: 0.1,
            amt: 1,
            healHP: -2,
            status: {
                antidote: {
                    name: 'antidote',
                    length: 2
                }
            },
        },
        exec: function(user, target) {
            if(env.rpg.classList.contains("tutorialgolem")) change("PAGE!!earlytoz", true)
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'dull',
                    rate: 1.5
                },
                critExec: ()=> {
					env.GENERIC_ACTIONS.teamWave({
						team: user.team,
						exec: (actor, i)=>{
							combatHit(actor, {amt: -2, origin: user, autohit: true, beneficial: true});
							addStatus({target: actor, origin: user, status: "antidote", length: this.stats.status.antidote.length});
							play('mend', 0.75)
						}
					})
				}
           })
        }
    },
		// palestone secondary
	env.ACTIONS.spy_hypervulnerable = {
        slug: "spy_hypervulnerable",
        name: "Direct",
        verb: "direct to",
        type: 'target',
        anim: "spying",
        animDuration: 2000,
        frameClass: "temp-perspective",
        usage: {
            act: "%USER DIRECTS THEIR ALLIES TOWARDS %TARGET",
            crit: "%TARGET IS MARKED FOR DEATH",
            hit: "%TARGET FEELS TARGETED",
            miss: "%TARGET HIDES BEHIND SOMETHING"
        },
        details: {
            onUse: `'[STATUS::vulnerable_mega]'`,
        },
        stats: {
            autohit: true,
            status: {
                vulnerable_mega: {
                    name: 'vulnerable_mega',
                    length: 2
                }
            }
        },
        exec: function(user, target) {
            reactDialogue(user, `give_vulnerable`)
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'megastatus',
                    rate: 0.75
                },
                hitStatus: this.stats.status.vulnerable_mega,
            })
        },
    },
		// palestone secondary aug
	env.ACTIONS.ultra_spy_cmb = {
        slug: "ultra_spy_cmb",
        name: "Expose Flaw",
        verb: "expose flaw in",
        type: 'target',
        anim: "spying",
        frameClass: "temp-perspective",
        animDuration: 2000,
        autohit: true,
        usage: {
            act: "%USER DIRECTS THEIR ALLIES TOWARDS %TARGET",
            crit: "%TARGET IS MARKED FOR DEATH",
            hit: "%TARGET IS MARKED FOR DEATH",
            miss: "%TARGET HIDES BEHIND SOMETHING"
        },
        details: {
            flavor: `'locate critical design flaw in target'`,
            onHit: "'[STATUS::vulnerable_mega] [STATUS::fatal_flaw]'",
        },
        stats: {
            status: {
                vulnerable_mega: {
                    name: 'vulnerable_mega',
                    length: 2
                },
                fatal_flaw: {
                    name: 'fatal_flaw',
                    length: 1
                }
            }
        },
        exec: function(user, target) {
            reactDialogue(user, `give_vulnerable`);
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'megastatus',
                    rate: 0.75
                },
                genExec: () => {
                    addStatus({
                        origin: user, 
                        target, 
                        status: this.stats.status.vulnerable_mega.name, 
                        length: this.stats.status.vulnerable_mega.length
                    });
                    addStatus({
                        origin: user, 
                        target, 
                        status: this.stats.status.fatal_flaw.name, 
                        length: this.stats.status.fatal_flaw.length
                    });
                }
            });
        }
    },   
		// palestone utility
	env.ACTIONS.special_combinesummon = {
		slug: "special_combinesummon",
		name: "Reinforce",
		type: 'special+summon+nomimic',
		anim: "heal",
		accuracy: 1,
		crit: 0,
		availableSummonsCop: ["cmb_cop_pawn", "cmb_cop_pawn", "cmb_cop_pawn", "cmb_cop_pawn", "cmb_cop_knight", "cmb_cop_bishop", "cmb_cop_bishop_support", "cmb_cop_rook", "cmb_cop_queen", "cmb_cop_king", "cmb_cop_king_target"],
		availableSummonsSoldier: ["cmb_soldier_pawn", "cmb_soldier_pawn", "cmb_soldier_pawn", "cmb_soldier_knight", "cmb_soldier_bishop", "cmb_soldier_bishop_support", "cmb_soldier_rook", "cmb_soldier_rook_prospekt", "cmb_soldier_queen", "cmb_soldier_queen_shotgun", "cmb_soldier_king", "cmb_soldier_king_support"],
		details: {
            flavor: `'collect additional allies from elsewhere'`,
            conditional: `<em>SUMMON::</em>'summon 2 soldiers (max:6 soldiers)'`
        },
		usage: {
			act: "%USER CONJURES ALLIES FROM ANOTHER WORLD"
		},
		exec: function(user, target) {
			removeStatus(user, "windup")
			play('dull', 0.8, 1);
			let rand2 = Math.random()
			
			var newAllySlug = this.availableSummonsCop.sample()
			var newAllySlug1 = this.availableSummonsCop.sample()
			if(rand2 < 0.25) {
				newAllySlug = this.availableSummonsSoldier.sample()
				newAllySlug1 = this.availableSummonsSoldier.sample()
			}
			
			if(user.team.name == "ally") {
				//try to center the dude
				if(user.team.members.filter(m=>m.slug.includes('cmb_')).length == 4) {
					let uI = user.team.members.findIndex(a => a.slug == user.slug)
					if(uI < 3) midCombatAllyAdd('cmb_cop_knight', 'left')
					else if(uI >= 3) midCombatAllyAdd('cmb_cop_knight', 'right')
				} else {
					midCombatAllyAdd(newAllySlug, 'left')
					midCombatAllyAdd(newAllySlug1, 'right')
				}
			} else { // antishell/imp usage safeguard
				midCombatActorAdd(env.rpg.enemyTeam, newAllySlug, 'left')
				midCombatActorAdd(env.rpg.enemyTeam, newAllySlug1, 'right')
			}
			setTimeout(()=>advanceTurn(user), 1000)
		},
		disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('cmb_')).length > 5) return "TOO MANY ALLIES" }
	},
	
	env.ACTIONS.special_combinesummon_cop = {
		slug: "special_combinesummon_cop",
		name: "Superportal::CIVIL PROTECTION",
		type: 'special+summon+nomimic',
		anim: "heal",
		accuracy: 1,
		crit: 0,
		availableSummonsCop: ["cmb_cop_pawn", "cmb_cop_pawn", "cmb_cop_pawn", "cmb_cop_pawn", "cmb_cop_knight", "cmb_cop_bishop", "cmb_cop_bishop_support", "cmb_cop_rook", "cmb_cop_queen", "cmb_cop_king", "cmb_cop_king_target"],
		details: {
            flavor: `'collect additional allies from elsewhere'`,
            conditional: `<em>SUMMON::</em>'summon 6 soldiers (max:6 soldiers)'`
        },
		usage: {
			act: "%USER INVADES THE BATTLEFIELD"
		},
		exec: function(user, target) {
			if(user.team.members.filter(m=>m.slug.includes('cmb_')).length == 0) {
				play('dull', 0.7, 1);
				addStatus({target: user, status: "stun", length: 1});
				addStatus({target: user, status: "vulnerable", length: 2});
				addStatus({target: user, status: "critical_flaw", length: 1});
				removeStatus(user, "windup") // :obeskscream:

				var newAllySlug1 = this.availableSummonsCop.sample()
				var newAllySlug2 = this.availableSummonsCop.sample()
				var newAllySlug3 = this.availableSummonsCop.sample()
				var newAllySlug4 = this.availableSummonsCop.sample()
				var newAllySlug5 = this.availableSummonsCop.sample()
				var newAllySlug6 = this.availableSummonsCop.sample()

				if(user.team.name == "ally") {
					midCombatAllyAdd(newAllySlug1, 'left')
					midCombatAllyAdd(newAllySlug2, 'left')
					midCombatAllyAdd(newAllySlug3, 'left')
					midCombatAllyAdd(newAllySlug4, 'right')
					midCombatAllyAdd(newAllySlug5, 'right')
					midCombatAllyAdd(newAllySlug6, 'right')
				} else { // antishell/imp usage safeguard
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug1, 'left')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug2, 'left')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug3, 'left')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug4, 'right')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug5, 'right')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug6, 'right')
				}
			}
			setTimeout(()=>advanceTurn(user), 1000)
		},
		disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('cmb_')).length > 6) return "TOO MANY ALLIES" }
	},
	
	env.ACTIONS.special_combinesummon_soldier = {
		slug: "special_combinesummon_soldier",
		name: "Superportal::STANDARD UNITS",
		type: 'special+summon+nomimic',
		anim: "heal",
		accuracy: 1,
		crit: 0,
		availableSummonsSoldier: ["cmb_soldier_pawn", "cmb_soldier_pawn", "cmb_soldier_pawn", "cmb_soldier_knight", "cmb_soldier_bishop", "cmb_soldier_bishop_support", "cmb_soldier_rook", "cmb_soldier_rook_prospekt", "cmb_soldier_queen", "cmb_soldier_queen_shotgun", "cmb_soldier_king", "cmb_soldier_king_support"],
		details: {
            flavor: `'collect additional allies from elsewhere'`,
            conditional: `<em>SUMMON::</em>'summon 6 soldiers (max:6 soldiers)'`
        },
		usage: {
			act: "%USER INVADES THE BATTLEFIELD"
		},
		exec: function(user, target) {
			if(user.team.members.filter(m=>m.slug.includes('cmb_')).length == 0) {
				play('dull', 0.6, 1);
				addStatus({target: user, status: "stun", length: 2});
				addStatus({target: user, status: "vulnerable", length: 4});
				addStatus({target: user, status: "critical_flaw", length: 1});
				removeStatus(user, "windup") // :obeskscream:

				var newAllySlug1 = this.availableSummonsSoldier.sample()
				var newAllySlug2 = this.availableSummonsSoldier.sample()
				var newAllySlug3 = this.availableSummonsSoldier.sample()
				var newAllySlug4 = this.availableSummonsSoldier.sample()
				var newAllySlug5 = this.availableSummonsSoldier.sample()
				var newAllySlug6 = this.availableSummonsSoldier.sample()

				if(user.team.name == "ally") {
					midCombatAllyAdd(newAllySlug1, 'left')
					midCombatAllyAdd(newAllySlug2, 'left')
					midCombatAllyAdd(newAllySlug3, 'left')
					midCombatAllyAdd(newAllySlug4, 'right')
					midCombatAllyAdd(newAllySlug5, 'right')
					midCombatAllyAdd(newAllySlug6, 'right')
				} else { // antishell/imp usage safeguard
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug1, 'left')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug2, 'left')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug3, 'left')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug4, 'right')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug5, 'right')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug6, 'right')
				}
			}
			setTimeout(()=>advanceTurn(user), 1000)
		},
		disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('cmb_')).length > 6) return "TOO MANY ALLIES" }
	},
	
	env.ACTIONS.special_combinesummon_special = {
		slug: "special_combinesummon_special",
		name: "Superportal::SPECIALIZED UNITS",
		type: 'special+summon+nomimic',
		anim: "heal",
		accuracy: 1,
		crit: 0,
		availableSummonsSpecial: ["cmb_special_pawn", "cmb_special_pawn_shotgun", "cmb_special_knight", "cmb_soldier_king_support", "cmb_special_bishop", "cmb_special_bishop_shotgun", "cmb_special_bishop_support", "cmb_special_bishop_support_shotgun", "cmb_special_rook", "cmb_special_rook_elite", "cmb_special_queen", "cmb_special_queen_smg", "cmb_special_queen_assassin", "cmb_special_king", "cmb_special_king_veteran", "cmb_special_king_veteran_ar2", "cmb_special_king_veteran_shotgun", "cmb_special_king_juggernaut"],
		details: {
            flavor: `'collect additional allies from elsewhere'`,
            conditional: `<em>SUMMON::</em>'summon 6 soldiers (max:6 soldiers)'`
        },
		usage: {
			act: "%USER INVADES THE BATTLEFIELD"
		},
		exec: function(user, target) {
			if(user.team.members.filter(m=>m.slug.includes('cmb_')).length == 0) {
				play('dull', 0.5, 1);
				addStatus({target: user, status: "stun", length: 3});
				addStatus({target: user, status: "vulnerable", length: 6});
				addStatus({target: user, status: "critical_flaw", length: 1});
				removeStatus(user, "windup") // :obeskscream:

				var newAllySlug1 = this.availableSummonsSpecial.sample()
				var newAllySlug2 = this.availableSummonsSpecial.sample()
				var newAllySlug3 = this.availableSummonsSpecial.sample()
				var newAllySlug4 = this.availableSummonsSpecial.sample()
				var newAllySlug5 = this.availableSummonsSpecial.sample()
				var newAllySlug6 = this.availableSummonsSpecial.sample()

				if(user.team.name == "ally") {
					midCombatAllyAdd(newAllySlug1, 'left')
					midCombatAllyAdd(newAllySlug2, 'left')
					midCombatAllyAdd(newAllySlug3, 'left')
					midCombatAllyAdd(newAllySlug4, 'right')
					midCombatAllyAdd(newAllySlug5, 'right')
					midCombatAllyAdd(newAllySlug6, 'right')
				} else { // antishell/imp usage safeguard
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug1, 'left')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug2, 'left')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug3, 'left')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug4, 'right')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug5, 'right')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug6, 'right')
				}
			}
			setTimeout(()=>advanceTurn(user), 1000)
		},
		disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('cmb_')).length > 6) return "TOO MANY ALLIES" }
	},
	
	env.ACTIONS.special_combinesummon_boss = {
		slug: "special_combinesummon_boss",
		name: "Superportal::OVERLOAD",
		type: 'special+summon',
		anim: "heal",
		accuracy: 1,
		crit: 0,
		availableSummonsBoss: ["cmb_cop_queen", "cmb_cop_king", "cmb_cop_king_target", "cmb_soldier_queen", "cmb_soldier_queen_shotgun", "cmb_soldier_king", "cmb_soldier_king_support", "cmb_special_queen", "cmb_special_queen_smg", "cmb_special_queen_assassin", "cmb_special_king", "cmb_special_king_veteran", "cmb_special_king_veteran_ar2", "cmb_special_king_veteran_shotgun", "cmb_special_king_juggernaut", "cmb_hunterchopper", "cmb_gunship", "cmb_strider", "cmb_canister", "cmb_thumper", "cmb_canister", "cmb_thumper"],
		details: {
            flavor: `'collect additional allies from elsewhere'`,
            conditional: `<em>SUMMON::</em>'summon 6 soldiers (max:6 soldiers)'`
        },
		usage: {
			act: "%USER INVADES THE BATTLEFIELD"
		},
		exec: function(user, target) {
			if(user.team.members.filter(m=>m.slug.includes('cmb_')).length == 0) {
				play('dull', 0.4, 1);
				addStatus({target: user, status: "stun", length: 4});
				addStatus({target: user, status: "vulnerable", length: 8});
				addStatus({target: user, status: "critical_flaw", length: 1});
				removeStatus(user, "windup") // :obeskscream:

				var newAllySlug1 = this.availableSummonsBoss.sample()
				var newAllySlug2 = this.availableSummonsBoss.sample()
				var newAllySlug3 = this.availableSummonsBoss.sample()
				var newAllySlug4 = this.availableSummonsBoss.sample()
				var newAllySlug5 = this.availableSummonsBoss.sample()
				var newAllySlug6 = this.availableSummonsBoss.sample()

				if(user.team.name == "ally") {
					midCombatAllyAdd(newAllySlug1, 'left')
					midCombatAllyAdd(newAllySlug2, 'left')
					midCombatAllyAdd(newAllySlug3, 'left')
					midCombatAllyAdd(newAllySlug4, 'right')
					midCombatAllyAdd(newAllySlug5, 'right')
					midCombatAllyAdd(newAllySlug6, 'right')
				} else { // antishell/imp usage safeguard
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug1, 'left')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug2, 'left')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug3, 'left')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug4, 'right')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug5, 'right')
					midCombatActorAdd(env.rpg.enemyTeam, newAllySlug6, 'right')
				}
			}
			setTimeout(()=>advanceTurn(user), 1000)
		},
		disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('cmb_')).length > 6) return "TOO MANY ALLIES" }
	},
		// palestone utility aug
	env.ACTIONS.special_combinesummon_select = {
        slug: "special_combinesummon_select",
        name: "Superportal",
        type: 'special+summon+nomimic',
        anim: "wobble",
		itemAction: true,
        usage: {
            act: "%USER CONSIDERS THEIR OPTIONS..."
        },
		details: {
            onUse: "'collect additional allies from offworld';'present user choice of outcome'",
        },
        accuracy: 1,
        crit: 0,
        exec: function(user, target) {
            let action = this

            //summon a div that lets the player click guaranteed or chance <--- we are modifying this to let the player choose between dull portal actions
            actionChoice({
                user: user,
                action: action,
                choiceText: `${user.name} considers their options...`,
                options: [
                    {text: "Superportal::CIVIL PROTECTION", definition: "NOTE::'SUMMON::6 CIVIL PROTECTION UNITS (MAX: 6 SUMMONS)'\nSELF::'+1T:STUN +1T:VULNERABLE'"},
                    {text: "Superportal::STANDARD UNITS", definition: "NOTE::'SUMMON::6 STANDARD UNITS (MAX: 6 SUMMONS)'\nSELF::'+2T:STUN +2T:VULNERABLE'"},
					{text: "Superportal::SPECIALIZED UNITS", definition: "NOTE::'SUMMON::6 SPECIALIZED UNITS (MAX: 6 SUMMONS)'\nSELF::'+3T:STUN +3T:VULNERABLE'"},
					{text: "Superportal::OVERLOAD", definition: "NOTE::'SUMMON::6 UNKNOWN UNITS (MAX: 6 SUMMONS)'\nSELF::'+4T:STUN +4T:VULNERABLE'"},
                ],
                choiceCallback: (c) => {
                    //reap the consequences
                        
                    var hit
                    switch(c) {
                        case "c0":
                            hit = useAction(user, env.ACTIONS['special_combinesummon_cop'], user, {beingUsedAsync: true, reason: "superportal"})
                            break;
                        case "c1":
                            hit = useAction(user, env.ACTIONS['special_combinesummon_soldier'], user, {beingUsedAsync: true, reason: "superportal"})
                            break
						case "c2":
                            hit = useAction(user, env.ACTIONS['special_combinesummon_special'], user, {beingUsedAsync: true, reason: "superportal"})
                            break
						case "c3":
                            hit = useAction(user, env.ACTIONS['special_combinesummon_boss'], user, {beingUsedAsync: true, reason: "superportal"})
                            break
                    }

                    setTimeout(()=>advanceTurn(user), env.ADVANCE_RATE);
                }
            })
        },
		disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('cmb_')).length > 0) return "TOO MANY ALLIES" }
    },
		// softlock prevention safeguard
	env.ACTIONS.windup_cmb = {
        slug: "windup_cmb",
        name: "Charge",
        type: 'autohit',
        anim: "",
        usage: {
            act: "%USER PREPARES AN ATTACK..."
        },
        details: {
            flavor: `'prepare a devastating attack'`,
            onUse: `'[STATUS::windup]'`
        },
        stats: {
            status: {
                windup: {
                    name: 'windup',
                    length: 1
                },            
            }
        },
        exec: function(user, target) {
			if(user.windupActions !== "undefined" && user.windupActions.includes("special_enact_missile")) {
			user.windupActions = user.windupActions.filter(action => action !== "focused_shot_weak") // we still don't have a good way to replace windup actions, so we quietly remove the original windup actions in reload instead (ported to preparation as well due to shenanigans :P)
			user.windupActions = user.windupActions.filter(action => action !== "hold_aim")
			}
			if(user.windupActions !== "undefined" && user.windupActions.includes("special_judgement_player")) {
				user.windupActions = user.windupActions.filter(action => action !== "special_rule_player")
			}
			if(user.windupActions !== "undefined" && user.windupActions.includes("haymaker")) {
				user.windupActions = user.windupActions.filter(action => action !== "archival_smash")
			}
			if(user.windupActions !== "undefined" && user.windupActions.includes("special_combinesummon_select")) {
				user.windupActions = user.windupActions.filter(action => action !== "special_combinesummon")
			}
			if(user.windupActions !== "undefined" && user.windupActions.includes("kivtezruka")) {
				user.windupActions = user.windupActions.filter(action => action !== "cavik_attack_mega")
			}
			if(user.windupActions !== "undefined" && user.windupActions.includes("calculated_frenzy")) {
				user.windupActions = user.windupActions.filter(action => action !== "calculated_stab")
			}
			play('talklaugh', 0.5);
			if(user.team.members.filter(m=>m.slug.includes('cmb_')).length < 5) {
				addStatus({target: user, status: "windup", length: 1}); 
			}
			return 'nothing';
		},
		disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('cmb_')).length > 5) return "TOO MANY ALLIES" }
    },
		// god fucking damn it
	env.ACTIONS.windup_cmb_aug = { // why ? why is this necessary ?
        slug: "windup_cmb_aug", // why does the augment handler not actually replace what's in the slot, but replaces things by slug, thereby necessitating the creation of this action ?
        name: "Charge", // explodes and dies
        type: 'autohit',
        anim: "",
        usage: {
            act: "%USER PREPARES AN ATTACK..."
        },
        details: {
            flavor: `'prepare a devastating attack'`,
            onUse: `'[STATUS::windup]'`
        },
        stats: {
            status: {
                windup: {
                    name: 'windup',
                    length: 1
                },
            }
        },
        exec: function(user, target) {
			if(user.windupActions !== "undefined" && user.windupActions.includes("special_enact_missile")) {
			user.windupActions = user.windupActions.filter(action => action !== "focused_shot_weak") // we still don't have a good way to replace windup actions, so we quietly remove the original windup actions in reload instead (ported to preparation as well due to shenanigans :P)
			user.windupActions = user.windupActions.filter(action => action !== "hold_aim")
			}
			if(user.windupActions !== "undefined" && user.windupActions.includes("special_judgement_player")) {
				user.windupActions = user.windupActions.filter(action => action !== "special_rule_player")
			}
			if(user.windupActions !== "undefined" && user.windupActions.includes("haymaker")) {
				user.windupActions = user.windupActions.filter(action => action !== "archival_smash")
			}
			if(user.windupActions !== "undefined" && user.windupActions.includes("special_combinesummon_select")) {
				user.windupActions = user.windupActions.filter(action => action !== "special_combinesummon")
			}
			if(user.windupActions !== "undefined" && user.windupActions.includes("kivtezruka")) {
				user.windupActions = user.windupActions.filter(action => action !== "cavik_attack_mega")
			}
			if(user.windupActions !== "undefined" && user.windupActions.includes("calculated_frenzy")) {
				user.windupActions = user.windupActions.filter(action => action !== "calculated_stab")
			}
			play('talklaugh', 0.5);
			if(user.team.members.filter(m=>m.slug.includes('cmb_')).length == 0) {
				addStatus({target: user, status: "windup", length: 1}); 
			}
			return 'nothing';
		},
		disableIf: (actor) => {if(actor.team.members.filter(m=>m.slug.includes('cmb_')).length > 0) return "TOO MANY ALLIES" }
    },
		// zuka primary
	env.ACTIONS.cavik_attack_mega = {
        slug: "cavik_attack_mega",
        name: "IND",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER THROWS A HEAVY CYST AT %TARGET",
            crit: "%TARGET'S TEAM EXPLODES",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET DODGES"
        },
        details: {
            flavor: `'throw dangerous makeshift major explosive';'crushes collection of dull bones to create massive explosion'`,
            onHit: `'[STAT::amt]'`,
            onCrit: ()=> `'HIT all foes for [STAT::selfHP]'${page.name == "frame" ? `;'additional hits do not trigger on-hit effects'` : ``}`,
        },
        stats: {
            accuracy: 0.8,
            crit: 0.6,
            amt: 1,
			selfHP: 4,
        },
        exec: function(user, target) {
			let action = this;
			let critAmt = this.stats.selfHP
			removeStatus(user, "windup")
			return env.GENERIC_ACTIONS.singleTarget({
				action: this, 
				user, 
				target,
				critSfx: {
					name: 'crit',
					rate: 1.25
				},
				critExec: ()=> env.GENERIC_ACTIONS.teamWave({
					team: user.enemyTeam,
					extraDelay: 5,
					exec: (actor, i)=>{
						setTimeout(()=>{
							env.GENERIC_ACTIONS.singleTarget({
								action,
								user, 
								target: actor,
								specialAmt: critAmt, // this should be fine
								hitSfx: { name: 'shot6', rate: 0.75 },
								canCrit: false,
								runHitEvents: false
							})
						}, (500))
					}
				})
			})
        }
    },
		// zuka primary aug
	env.ACTIONS.kivtezruka = {
        slug: "kivtezruka",
        name: "Kivtezruka",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER THROWS AN EXPLOSIVE AT %TARGET",
            crit: "%TARGET'S TEAM IS ANNIHILATED",
            hit: "%TARGET IS STRUCK",
            miss: "%TARGET DODGES"
        },
        details: {
            flavor: `'utilize industrial excavation charge';'upscaled kavruka paired with groundsmindry micro-relays';'broadcast annihilation'`,
            onHit: `'[STAT::amt]'`,
            onCrit: ()=> `'HIT all foes for [STAT::selfHP] [STATUS::destabilized] [STATUS::vulnerable]';${page.name == "frame" ? `;'additional hits trigger on-hit effects'` : ``}`,
        },
        stats: {
            accuracy: 0.8,
            crit: 0.6,
            amt: 1,
			selfHP: 4,
			status: {
                destabilized: {
                    name: 'destabilized',
                    length: 2
                },
				vulnerable: {
                    name: 'vulnerable',
                    length: 2
                }
            },
        },
        exec: function(user, target) {
			let action = this;
			let critAmt = this.stats.selfHP
			removeStatus(user, "windup")
			return env.GENERIC_ACTIONS.singleTarget({
				action: this, 
				user, 
				target,
				critExec: ()=> env.GENERIC_ACTIONS.teamWave({
					team: user.enemyTeam,
					extraDelay: 5,
					exec: (actor, i)=>{
						setTimeout(()=>{
							env.GENERIC_ACTIONS.singleTarget({
								action,
								user, 
								target: actor,
								specialAmt: critAmt, // this should be fine
								hitSfx: { name: 'shot4', rate: 0.75 },
								hitExec: ({target})=>{
									addStatus({target, origin: user, status: "destabilized", length: 2})
									addStatus({target, origin: user, status: "vulnerable", length: 2})
								},
								canCrit: false
							})
						}, (500))
					}
				})
			})
        }
    },
		// zuka secondary
	env.ACTIONS.parastrike = {
        slug: "parastrike",
        name: "Parastrike",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER SPRINTS AT %TARGET",
            crit: "%TARGET EXPLODES",
            hit: "%TARGET'S FLESH MELTS AWAY",
            miss: "%TARGET RESISTS CONTROL"
        },
        details: {
            flavor: `'heavy strike paired with mobile groundsmindry pulse';'chance to force detonation of vital cystic component in target'`,
            onHit: `'[STAT::amt]'`,
            onCrit: () => `'HIT all foes for [STAT::amt] [STATUS::puncture]'${page.name == "frame" ? `;'additional hits do not trigger on-hit effects'` : ``}`,
        },
        stats: {
            accuracy: 0.75, 
            crit: 0.2,
            amt: 2,
            status: {
                puncture: {
                    name: 'puncture',
                    length: 1
                }
            }
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this;
            return env.GENERIC_ACTIONS.singleTarget({
                action, 
                user, 
                target,
				hitSfx: { name: 'destabilize', rate: 2 },
                critExec: ()=> env.GENERIC_ACTIONS.teamWave({
                    team: user.enemyTeam,
                    exec: (actor, i) => {
                        env.GENERIC_ACTIONS.singleTarget({
                            action, 
                            user, 
                            target: actor,
                            hitSfx: { name: 'shot6', rate: 1.25 },
							missSfx: { name: "shot6", rate: 1.5, volume: 0.5 },
                            hitStatus: this.stats.status.puncture,
                            canCrit: false,
							runHitEvents: false
                        })
                    }
                })
            })
        },
    },
		// zuka secondary aug
	env.ACTIONS.frenzy_extracall = {
        slug: "frenzy_extracall",
        name: "Extracall",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER LUNGES AT %TARGET",
            crit: "%USER JUST KEEPS GOING",
            hit: "%TARGET'S FLESH MELTS AWAY",
            miss: "%TARGET RESISTS CONTROL"
        },
        details: {
            flavor: `'frantic strike paired with interfering signal';'likely to cause successive detonations'`,
            onHit: `'[STAT::amt]'`,
            onCrit: () => `'use this action again on random foe';'HIT all foes for [STAT::amt]'${page.name == "frame" ? `;'additional hits do not trigger do not on-hit effects'` : ``}`,
        },
        stats: {
            accuracy: 0.6, 
            crit: 0.1,
            amt: 1,
        },
        exec: function(user, target, beingUsedAsync) {
            let targetTeam
            switch(user.team.name) {
                case "ally": targetTeam = env.rpg.enemyTeam; break;
                case "enemy": targetTeam = env.rpg.allyTeam; break;
            }
			let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")
			let nextTarget = validTargets.sample()
			let action = this;
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
				hitSfx: { name: 'destabilize', rate: 1.5 },
                critExec: ()=> { // i cannot BELIEVE this all works with like, minimal issues. absolutely wild
					if(validTargets && !user.frenzyChainKilled) {
                        env.setTimeout(()=>{
                            useAction(user, this, nextTarget, {beingUsedAsync: true, reason: "extracall"})
                        }, 400)
                    }
					return env.GENERIC_ACTIONS.teamWave({
						team: user.enemyTeam,
						extraDelay: 5,
						exec: (actor, i) => {
							env.GENERIC_ACTIONS.singleTarget({
								action, 
								user, 
								target: actor,
								hitSfx: { name: 'shot4', rate: 1.25 },
								missSfx: { name: "shot4", rate: 1.5, volume: 0.5 },
								canCrit: false,
								runHitEvents: false
							})
						}
					})
				}
            })
        },
    },
		// zuka utility
	env.ACTIONS.rage = {
        slug: "rage",
        name: "Rage",
        type: 'self+autohit+support',
        anim: "skitter",
        usage: {
            act: "%USER PREPARES FOR A DESPERATE CHARGE"
        },
        details: {
            flavor: "'mark self for death to empower next move immensely';'optionally empower allies instead'",
            onUse:`'[STATUS::rage] [STATUS::evasion_mega]'`,
        },
        stats: {
            status: {
                evasion_mega: {
                    name: 'evasion_mega',
                    length: 2
                },
                rage: {
                    name: 'rage',
                    length: 1
                }
            },
        },
        exec: function(user, target) {
            play("scarydoia", 0.5)
            addStatus({target: user, status: "evasion_mega", length: 2, noReact: true})
            setTimeout(()=>{
                addStatus({target: user, status: "rage", length: 1, noReact: true})
            }, 400)
            return 'nothing'
        },
        avoidChaining: true
    },
		// zuka utility again (alt? two? secondary utility? what do i call this one)
	env.ACTIONS.special_rally = {
        slug: "special_rally",
        name: "Rally",
        type: 'self+autohit+support',
        anim: "",
        usage: {
            act: "%USER COMMANDS THEIR ALLIES TO STRIKE"
        },
        details: {
            flavor: "'empower and energize team';'requires rage'",
            onUse:`'[STATUS::focused] [STATUS::surge] to all allies'`,
        },
        stats: {
            status: {
                surge: {
                    name: 'surge',
                    length: 1
                },
                focused: {
                    name: 'focused',
                    length: 1
                },
            },
        },
        autohit: true,
        disableIf: (actor)=>{
            if(actor.actions.includes("rage") || actor.actions.includes("special_wrath_enact")) {
                if(hasStatus(actor, "rage")) return false
                else return "MUST FIRST USE OFFERING"
            } else return false
		},
        exec: function(user, target) {
            play("talkchoir7", 1.5)
            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i)=>{
                    addStatus({target: actor, origin: user, status: "focused", origin: user, length: 1, noReact: true}); 
					addStatus({target: actor, origin: user, status: "surge", origin: user, length: 1, noReact: true}); 
                    play('scarydoia', 1);
                }
            })
            return 'nothing'
        }
    },
		// zuka utility aug
	env.ACTIONS.special_wrath_enact = {
        slug: "special_wrath_enact",
        name: "Wrath",
        type: 'special',
        anim: "skitter",
		allowedWindupPrimaries: ["archival_smash", "focused_shot_weak", "focused_shot", "special_rule_player", "ik_attack_player", "dullflare_player", "haymaker", "reforge", "special_playershelf_annihilate_mega", "trusive_smash", "plot_reload", "special_judgement_player", "cavik_attack_mega", "bazruka_mega"],
        usage: {
            act: "%USER GOES IN A BLAZE OF GLORY"
        },
        details: {
            flavor: "'spend own health to unleash reckless flurry of strikes';'likely to end in the user's death'",
            onUse:`'[STATUS::evasion] [STATUS::rage]';'[STATUS::empowered] [STATUS::surge] to all allies'`,
            conditional: `<em>SPECIAL::</em>'reduce user HP to 1, then use primary action X times corresponding to HP consumed\nIE::4HP consumed = 4 attacks'`
        },
        stats: { 
			accuracy: 1,
			crit: 0,
			amt: 0,
            status: {
                evasion: {
                    name: 'evasion',
                    length: 2
                },
                rage: {
                    name: 'rage',
                    length: 1
                },
				surge: {
                    name: 'surge',
                    length: 1
                },
                empowered: {
                    name: 'empowered',
                    length: 2
                }
            },
        },
        autohit: true,
        noRepeat: true,
        exec: function(user, target) {
            let amt = user.hp - 1
            let primary = env.ACTIONS[user.actions[0]]
			let availableWindupActions = false // i don't understand why availableWindupActions being undefined doesn't make the later check just return as false, so . have this
			if(user.windupActions) { availableWindupActions = user.windupActions.filter(f =>this.allowedWindupPrimaries.includes(f)) } // i have no fucking clue why this works, it just does
			if(availableWindupActions) { primary = env.ACTIONS[availableWindupActions[0]] }
			user.hp = 1

            for (let i = 0; i < amt; i++) {
                env.setTimeout(()=>{
                    let target = env.rpg.enemyTeam.members.filter(t=>t.state != "dead").sample()
                    if(target) useAction(user, primary, target, {triggerActionUseEvent: i == 0, beingUsedAsync: true, reason: "wrath", noUseMessage: true})
                }, i * 200)
            }

            env.setTimeout(()=>{
                advanceTurn(user)
				addStatus({target: user, status: "rage", length: 1, noReact: true})
				env.GENERIC_ACTIONS.teamWave({
					team: user.team,
					exec: (actor, i) => {
						addStatus({target: actor, status: "empowered", length: 2})
						addStatus({target: actor, status: "surge", length: 1})
					},
					advanceAfterExec: false
				})
            }, (amt * 200) + 500)
        },
        disableIf: (actor)=>{ if(actor.hp <= 5) return "REQUIRES HP OVER 5" },
    },
		// hook primary
	env.ACTIONS.vicious_claw = {
        slug: "vicious_claw",
        name: "Vicious Claw",
        verb: "claw at",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER ATTACKS %TARGET",
            crit: "%TARGET IS MAULED",
            hit: "%TARGET STAGGERS",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'utilize brutal weaponry';'likely to cause immense pain in target'",
            onHit: `'[STAT::amt]';'inflict one of following';'[STATUS::open_wound] [STATUS::puncture]';'[STATUS::stun]';'[STATUS::agony]'`,
        },
        stats: {
            accuracy: .7,
            crit: 0.3,
            amt: 2,
            status: {
                open_wound: {
                    name: 'open_wound',
                    length: 2
                },
				puncture: {
                    name: 'puncture',
                    length: 2
                },
                stun: {
                    name: 'stun',
                    length: 1
                },
                agony: {
                    name: 'agony',
                    length: 1
                },
            },
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'stab',
                    rate: 0.75
                },
                hitExec: ({target})=> {
                    let rand = Math.random()
                    if(rand < 0.3) {
                        addStatus({target, origin: user, status: "open_wound", length: 2}); 
                        addStatus({target, origin: user, status: "puncture", length: 2});
                    } else if(rand < 0.6) {
                        addStatus({target, origin: user, status: "stun", length: 1}); 
                    } else {
                        addStatus({target, origin: user, status: "agony", length: 1}); 
                    }
                }
            })
        }
    },
		// scrapped hook secondary
	env.ACTIONS.strip_carapace = {
        slug: "strip_carapace",
        name: "Strip Carapace",
        type: 'target',
        anim: "skitter",
        usage: {
            act: "%USER REACHES FOR %TARGET",
            crit: "%TARGET IS DEFENSELESS",
            hit: "%TARGET'S FORM CRACKS",
        },
        details: {
            flavor: `'utilize illegal groundsmindry';'alter structure of target to forcibly remove defenses'`,
            onHit: `'[STATUS::open_wound]'`,
            onCrit: `'[STATUS::agony]';'additional [STATUS::open_wound]'`,
        },
        stats: {
            autohit: true,
            crit: 0.1,
            status: {
                open_wound: {
                    name: 'open_wound',
                    length: 3
                },
				agony: {
                    name: 'agony',
                    length: 1
                }
            }
        },
        exec: function(user, target) {
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: { name: 'stab', rate: 0.75 },
                critSfx: { name: 'stab', rate: 0.5 },
                critStatus: this.stats.status.open_wound,
                hitStatus: this.stats.status.open_wound,
				critExec: ({target})=>{
                    addStatus({target, status: "agony", origin: user, length: 1}); 
                }
            })
        },
    },
		// hook secondary
	env.ACTIONS.calculated_stab = {
        slug: "calculated_stab",
        name: "Calculated Stab",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER CHARGES %TARGET",
            crit: "%TARGET IS IMPALED",
            hit: "%TARGET IS BRUTALLY STABBED",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'focused, deadly attack upon one target's vital cystic components';'immense physical trauma'",
            onHit: `'[STAT::amt] [STATUS::puncture]'`,
            onCrit: `'[STATUS::stun] [STATUS::agony]';'additional [STATUS::puncture]'`,
        },
        stats: {
			accuracy: 1,
            crit: 0.1,
            amt: 4,
            status: {
                stun: {
                    name: 'stun',
                    length: 1
                },
				agony: {
                    name: 'agony',
                    length: 1
                },
				puncture: {
                    name: 'puncture',
                    length: 6
                }
            },
        },
        exec: function(user, target) {
            removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'stab',
                    rate: 0.6
                },
				hitStatus: {
					name: 'puncture',
					length: 6
				},
                critStatus: {
                    name: 'stun',
                    length: 1
                },
				critExec: ({target})=>{
                    addStatus({target, status: "agony", origin: user, length: 1}); 
					addStatus({target, status: "puncture", origin: user, length: 6});
                }
            })
        }
    },
		// hook utility
	env.ACTIONS.special_inversion_player = {
        slug: "special_inversion_player",
        name: "Inversion",
        type: 'special',
        anim: "wobble",
        usage: {
            act: "%USER PUSHES AGAINST THEIR REALITY"
        },
        details: {
            flavor: "'grasp the nature of this place';'recognize and exploit framing device'",
            onUse:`'[STATUS::incoherent]';'invert all statuses currently in play'`
        },
        stats: {
            status: {
                incoherent: {
                    name: 'incoherent',
                    length: 1
                },
            },
        },
        autohit: true,
		noRepeat: true,
		avoidChaining: true,
        exec: function(user, target, beingUsedAsync) {
            play("talkfairy", 1.5)
            addStatus({target: user, status: "incoherent", length: 1, noReact: true})
            let action = this
            
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'talkfairy',
                            rate: 0.75
                        },
                        genExec: ({target}) => {
                            invertStatuses(actor)
                        }
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
		// hook primary aug
	env.ACTIONS.revoke = {
        slug: "revoke",
        name: "Revoke",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER GRASPS BEYOND %TARGET",
            crit: "%TARGET FEELS SOMETHING TORN AWAY",
            hit: "%TARGET FLICKERS",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'steal from beyond the flesh of foes'",
            onHit: `'[STAT::amt]'`,
            onCrit:`'remove target's beneficial statuses';'re-apply to user'`,
        },
        stats: {
            accuracy: .7,
            crit: 0.3,
            amt: 2,
        },
        exec: function(user, target, beingUsedAsync) {
			let statusExceptions = ['conjoined', 'conjoined_baseslug', 'windup', 'windup_telegraph_flat', 'winderup', 'windestup', 'final_windup', 'windup_aim', 'coiling_flat']
            if(user.windupActions) statusExceptions = ['conjoined', 'conjoined_baseslug', 'windup_telegraph_flat', 'winderup', 'windestup', 'final_windup', 'windup_aim', 'coiling_flat']
			if(user.windupActions && hasStatus(user, 'heart_calc')) statusExceptions = ['conjoined', 'conjoined_baseslug', 'winderup', 'windestup', 'final_windup', 'windup_aim', 'coiling_flat']
			return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'stab',
                    rate: 0.75
                },
                critExec: ({target})=> {
                    for(let status of Object.values(env.STATUS_EFFECTS)) {
						if(status['beneficial'] && !status['passive']) { // only get beneficial statuses, don't iterate through impulses
							let newStatus = status.slug
							if(hasStatus(target, newStatus) && !statusExceptions.includes(newStatus)) { // this SHOULD work. probably
								let newStatusLength = Math.floor(hasStatus(target, newStatus))
								if(newStatus.includes("redirection")) addStatus({target: user, origin: target, status: newStatus, length: newStatusLength})
								else addStatus({target: user, origin: user, status: newStatus, length: newStatusLength})
								removeStatus(target, newStatus)
							}
						}
					}
                }
            })
        }
    },
		// scrapped hook secondary aug
	env.ACTIONS.special_mass_dissolve = {
        slug: "special_mass_dissolve",
        name: "Dissolve Thoughtspace",
        type: 'special',
        anim: "wobble",
        autohit: true,
        usage: {
            act: "THE THOUGHTSPACE GROWS CAUSTIC"
        },
        details: {
            flavor: "'afflict all foes with incoherence';'remove outer membrane'",
            onUse: `'HIT all foes'`,
			onHit: `'[STATUS::open_wound]'`,
			onCrit: `'additional [STATUS::open_wound]';'[STATUS::agony]'`
        },
        stats: {
			crit: 0.1,
            status: {
                open_wound: {
                    name: 'open_wound',
                    length: 2
                },
				agony: {
                    name: 'agony',
                    length: 1
                }
            },
        },
        exec: function(user, target, beingUsedAsync) {
            if(env.rpg.classList.contains("bastard")) {                
                if(user.team.name == "ally") {
                    env.rpg.classList.add('incoherentbg')
                    content.classList.add('painprep', 'painfade', 'painhalf')
                    setTimeout(()=>{content.classList.add('painmode')}, 100)
                    setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                    setTimeout(()=>{content.classList.remove('painprep', 'painfade', 'painhalf')}, 5000)

                    setTimeout(()=>{env.rpg.classList.remove('incoherentbg')}, 4000)
                }
            } else {
                ratween(env.bgm, 1, 2000)
                env.rpg.classList.add('incoherentbg')
                content.classList.add('painprep', 'painhalf')
                setTimeout(()=>{content.classList.add('painmode')}, 100)
                setTimeout(()=>{content.classList.remove('painmode')}, 4000)
                setTimeout(()=>{content.classList.remove('painprep', 'painhalf')}, 5000)
            }
            
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.enemyTeam,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        autohit: true,
                        hitSfx: {
                            name: 'stab',
                            rate: 0.75
                        },
						critSfx: {
							name: 'stab',
							rate: 0.75
						},
                        hitExec: ({target}) => {
                            addStatus({target: actor, origin: user, status: "open_wound", length: 2});
                        },
						critExec: ({target}) => {
                            addStatus({target: actor, origin: user, status: "open_wound", length: 2});
							addStatus({target: actor, origin: user, status: "agony", length: 1});
                        }
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
		// hook secondary aug
	env.ACTIONS.calculated_frenzy = {
        slug: "calculated_frenzy",
        name: "Calculated Frenzy",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER LUNGES FOR %TARGET",
            crit: "%USER JUST KEEPS GOING",
            hit: "%TARGET IS BRUTALLY STABBED",
            miss: "%TARGET EVADES"
        },
        details: {
            flavor: "'brutal attack upon one target's vital components';'may inspire continuous rampage'",
            onHit: `'[STAT::amt] [STATUS::puncture]'`,
            onCrit: `'use this action again on two random foes'`,
        },
        stats: {
			accuracy: 0.9,
            crit: 0.05,
            amt: 4,
            status: {
				puncture: {
                    name: 'puncture',
                    length: 4
                }
            },
        },
        exec: function(user, target) {
			let targetTeam
            switch(user.team.name) {
                case "ally": targetTeam = env.rpg.enemyTeam; break;
                case "enemy": targetTeam = env.rpg.allyTeam; break;
            }
			let validTargets = targetTeam.members.filter(member => member.state != "dead" && member.state != "lastStand")
			let nextTarget1 = validTargets.sample()
			let nextTarget2 = validTargets.sample()
            removeStatus(user, "windup")
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                hitSfx: {
                    name: 'stab',
                    rate: 0.6
                },
				hitStatus: {
					name: 'puncture',
					length: 4
				},
				critExec: ({target})=>{
                    if(validTargets && !user.frenzyChainKilled) {
                        env.setTimeout(()=>{
                            useAction(user, this, nextTarget1, {beingUsedAsync: true, reason: "calc. frenzy (1)"})
                        }, 400)
						env.setTimeout(()=>{
                            useAction(user, this, nextTarget2, {beingUsedAsync: true, reason: "calc. frenzy (2)"})
                        }, 800)
                    }
                }
            })
        }
    },
		// hook utility aug
	env.ACTIONS.special_rewrite = {
        slug: "special_rewrite",
        name: "Rewrite",
        type: 'special',
        anim: "cloak-barrier",
        animDuration: 4000,
        autohit: true,
		noRepeat: true,
		avoidChaining: true,
        details: {
            flavor: "'recognize and alter structure of framing device'",
            onUse: "'[STATUS::incoherent]';'invert all negative statuses of allies except user';'invert all beneficial statuses of foes and user'",
        },
		stats: {
            status: {
                incoherent: {
                    name: 'incoherent',
                    length: 1
                },
            },
        },
        usage: {
            act: "%USER REWRITES THEIR REALITY"
        },
        exec: function(user, target, beingUsedAsync) {
            play("talkfairy", 1.5)
			addStatus({target: user, status: "incoherent", length: 1, noReact: true})
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                arbitraryActorList: env.rpg.turnOrder,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'talkfairy',
                            rate: 0.75
                        },
                        genExec: ({target}) => {
                            if(user.team.name == actor.team.name && actor !== user) invertStatuses(target, (statusObj)=>!statusObj.beneficial)
                            else invertStatuses(target, (statusObj)=>statusObj.beneficial)
                        }
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
		// spine primary
	env.ACTIONS.empowering_strike = {
        slug: "empowering_strike",
        name: "Empowering Strike",
        verb: "strike",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER STRIKES %TARGET",
            crit: "%USER'S ALLIES ARE INSPIRED",
            hit: "%TARGET IS HIT",
            miss: "%TARGET DODGES"
        },
        details: {
            onHit: `'[STAT::amt]'`,
            onCrit: `'[STATUS::empowered] to nearby allies';'grant [STATUS::windup] to allies with windup actions'`,
        },
        stats: {
            accuracy: 0.8, 
            crit: 0.2,
            amt: 1,
            status: {
                empowered: {
                    name: 'empowered',
                    length: 2
                },
				windup: {
                    name: 'windup',
                    length: 1
                }
            }
        },
        exec: function(user, target) { 
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                critExec: ()=> {           
                    let targets = user.team.members  
                    env.GENERIC_ACTIONS.teamWave({
                        arbitraryActorList: targets, // hey. wait. why does distraction do it like this
                        exec: (actor, i)=>{
                            addStatus({target: actor, origin: user, status: "empowered", origin: user, length: 2, noReact: true})
							if(actor.windupActions) { // turns out using target.windupActions here checks for the *original* target instead of the teamwave's target :obeskscream:
								addStatus({target: actor, origin: user, status: "windup", origin: user, length: 1, noReact: true})
							}
                            play('mend', 0.5);
                        }
                    })
                }
            })
        }
    },
		// spine primary aug
	env.ACTIONS.focusing_strike = {
        slug: "focusing_strike",
        name: "Focusing Strike",
        verb: "strike",
        type: 'target',
        anim: "basic-attack",
        usage: {
            act: "%USER STRIKES %TARGET",
            crit: "%USER'S ALLIES GET READY TO ATTACK",
            hit: "%TARGET IS HIT",
            miss: "%TARGET DODGES"
        },
        details: {
            onHit: `'[STAT::amt]'`,
            onCrit: `'[STATUS::focused] to nearby allies';'grant [STATUS::windup] to allies with windup actions'`,
        },
        stats: {
            accuracy: 0.9, 
            crit: 0.1,
            amt: 2,
            status: {
                focused: {
                    name: 'focused',
                    length: 1
                },
				windup: {
                    name: 'windup',
                    length: 1
                }
            }
        },
        exec: function(user, target) { 
            return env.GENERIC_ACTIONS.singleTarget({
                action: this, 
                user, 
                target,
                critExec: ()=> {           
                    let targets = user.team.members  
                    env.GENERIC_ACTIONS.teamWave({
                        arbitraryActorList: targets, // hey. wait. why does distraction do it like this
                        exec: (actor, i)=>{
                            addStatus({target: actor, origin: user, status: "focused", origin: user, length: 1, noReact: true})
							if(actor.windupActions) {
								addStatus({target: actor, origin: user, status: "windup", origin: user, length: 1, noReact: true})
							}
                            play('mend', 0.5);
                        }
                    })
                }
            })
        }
    },
		// spine utility
	env.ACTIONS.spine_blink = {
        slug: "spine_blink",
        name: "Blink",
        type: 'autohit',
        anim: "heal",
        usage: {
            act: "%USER BLINKS AWAY"
        },
        details: {
            flavor: "'teleport a short distance via dull manipulation';'hide vulnerabilities'",
			onUse: "'gain [STATUS::evasion_mega]'",
        },
        stats: {
            status: {
                evasion_mega: {
                    name: 'evasion_mega',
                    length: 2
                },              
            }
        },
        exec: function(user, target) {
            addStatus({target: user, status: "evasion_mega", length: 2, noReact: true});
			play("talkfairy", 1)
            return 'nothing';
        },
        avoidChaining: true,
    },
		// spine utility aug
	env.ACTIONS.special_cloaking_barrier = {
        slug: "special_cloaking_barrier",
        name: "Cloaking Cover",
        type: 'special',
        anim: "cloak-barrier", // hehehe
        animDuration: 4000,
        autohit: true,
        usage: {
            act: "%USER SHIELDS THEIR ALLIES"
        },
        details: {
            flavor: "'broadly apply ablative protection';'upgraded barrier conceals allies while active'",
            onUse: `'[STAT::amtBP] [STATUS::cloaked] to nearby allies'`,
        },
        stats: {
            crit: 0,
            amtBP: 2,
            amt: 2,
            status: { 
                cloaked: {
                    name: 'cloaked', 
                    length: 1
                },
            } 
        },
        exec: function(user, target, beingUsedAsync) {
            let action = this
            env.GENERIC_ACTIONS.teamWave({
                team: user.team,
                exec: (actor, i) => {
                    env.GENERIC_ACTIONS.singleTarget({
                        beneficial: true,
                        type: 'barrier',
                        action, 
                        user, 
                        target: actor,
                        hitSfx: {
                            name: 'mend',
                            rate: 2
                        },
                        hitStatus: {
                            name: 'cloaked',
                            length: 1
                        },
                    })
                },
                advanceAfterExec: true, beingUsedAsync, user,
            })
        }
    },
		// spine secondary part 1
	env.ACTIONS.deform = {
		slug: "deform",
		name: "Deform",
		type: 'summon+target',
		anim: "basic-attack",
		usage: {
			act: "%USER REACHES TOWARDS %TARGET",
			crit: "%USER SUMMONS AN ANGEL",
			hit: "%TARGET'S MEMBRANE REVOLTS",
			miss: "%TARGET RESISTS CONTROL"
		},
		details: {
            flavor: "'attempt to directly damage target's thoughtform membrane';'chance to use leftover resources to create allies'",
            onHit: "'[STAT::amt]';'inflict one of following';'[STATUS::destabilized]';'[STATUS::open_wound]';'[STATUS::weakened]'",
            onCrit: "'summon angelic ally (max:4)'",
        },
        stats: {
            accuracy: 0.7,
            crit: 0.15,
            amt: 2,
            status: {
                weakened: { name: 'weakened', length: 2 },
				open_wound: { name: 'open_wound', length: 2 },
				destabilized: { name: 'destabilized', length: 2 },
            },
        },
		exec: function(user, target) {
			let fated = user.statusEffects.find(status => status.slug == "fated_spine")
			return env.GENERIC_ACTIONS.singleTarget({
				action: this,
				user,
				target,
				hitSfx: { name: "destabilize", rate: 1.5 },
				critSfx: { name: "dull", rate: 0.5 },
				hitExec: ({target})=> {
                    let rand = Math.random()
                    if(rand < 0.3) {
                        addStatus({target, origin: user, status: "destabilized", origin: user, length: 2}); 
                    } else if(rand < 0.6) {
                        addStatus({target, origin: user, status: "open_wound", origin: user, length: 2}); 
                    } else {
                        addStatus({target, origin: user, status: "weakened", origin: user, length: 2}); 
                    }
                },
				critExec: ({target}) => {
					user.lastSide = !user.lastSide
					if(user.team.members.filter(m=>m.slug.includes('spine_fodder')).length < (fated ? fated.power + 4 : 4)) {
						midCombatActorAdd(env.rpg.allyTeam, 'spine_fodder', user.lastSide ? "left" : "right")
					}
				}
			})
		}
	},
		// spine secondary part 2
	env.ACTIONS.special_spine_merge = { // oh god this is gonna be a nightmare to write isn't it
    slug: "special_spine_merge", // everyone say thank you to max for making this actually work !!!!!! oh god it was so uncooperative
		name: "Merge",
		type: 'self+autohit+support',
		anim: "",
		usage: {
			act: "%USER GATHERS THEIR SUMMONS..."
		},
		details: {
			flavor: "'sacrifice angelic allies to create more powerful ally'",
			onUse: `'DOWN angelic allies';'summon 1 greater angel per 4 lesser angels (max:4)'`,
		},
		autohit: true,
		avoidChaining: true,
		noRepeat: true,
		possibleSpawns: ["angel_pawn", "angel_knight", "angel_bishop", "angel_rook", "angel_queen", "angel_king"],
		disableIf: (actor) => {
		  if(actor.team.members.filter(m => m.slug.includes('spine_fodder')).length < 4) { return "NOT ENOUGH ALLIES" }
		  if(actor.team.members.filter(m => m.slug.includes('angel_')).length >= 4) { return "TOO MANY ALLIES" }
		},
		exec: function(user, target) {
			let fated = user.statusEffects.find(status => status.slug == "fated_spine")
			let fodderConsumed = 0

			user.team.members.forEach((member) => {
				if (member.slug.includes('spine_fodder') && user.team.members.filter((m) => m.slug.includes('angel_')).length < (fated ? fated.power + 4 : 4)) {
					console.log("consuming summon now")

					midCombatActorRemove(member)
					play('chomp', 0.6)

					fodderConsumed++

					if (fodderConsumed == 4) {
						fodderConsumed = 0

						let newAllySlug = this.possibleSpawns.sample()

						midCombatAllyAdd(newAllySlug, "right")
						playCombatCrit('dull', 0.5)
					}
				}
			})
		}
	}
		// spine secondary aug part 1
	env.ACTIONS.reconstruct = {
		slug: "reconstruct",
		name: "Reconstruct",
		type: 'summon+target',
		anim: "basic-attack",
		possibleSpawns: ["angel_pawn", "angel_knight", "angel_bishop", "angel_rook", "angel_queen", "angel_king"],
		usage: {
			act: "%USER REACHES TOWARDS %TARGET",
			crit: "%TARGET IS MADE ANEW",
			hit: "%TARGET REVOLTS",
			miss: "%TARGET RESISTS CONTROL"
		},
		details: {
            flavor: "'attempt to directly rewrite target to assist user in combat'",
            onHit: "'[STAT::amt]';'inflict one of following';'[STATUS::destabilized]';'[STATUS::open_wound]';'[STATUS::weakened]'",
            onCrit: "'summon greater angelic ally (max:4)';'additionally inflict one of following';'[STATUS::destabilized]';'[STATUS::open_wound]';'[STATUS::weakened]'",
        },
        stats: {
            accuracy: 0.7,
            crit: 0.15,
            amt: 3,
            status: {
                weakened: { name: 'weakened', length: 3 },
				open_wound: { name: 'open_wound', length: 3 },
				destabilized: { name: 'destabilized', length: 3 },
            },
        },
		exec: function(user, target) {
			removeStatus(user, "windup")
			let fated = user.statusEffects.find(status => status.slug == "fated_spine")
			return env.GENERIC_ACTIONS.singleTarget({
				action: this,
				user,
				target,
				hitSfx: { name: "dull", rate: 0.6 },
				critSfx: { name: "stab", rate: 0.4 },
				hitExec: ({target})=> {
                    let rand = Math.random()
                    if(rand < 0.3) {
                        addStatus({target, origin: user, status: "destabilized", origin: user, length: 3}); 
                    } else if(rand < 0.6) {
                        addStatus({target, origin: user, status: "open_wound", origin: user, length: 3}); 
                    } else {
                        addStatus({target, origin: user, status: "weakened", origin: user, length: 3}); 
                    }
                },
				critExec: ({target}) => {
					let rand1 = Math.random()
                    if(rand1 < 0.3) {
                        addStatus({target, origin: user, status: "destabilized", origin: user, length: 3}); 
                    } else if(rand1 < 0.6) {
                        addStatus({target, origin: user, status: "open_wound", origin: user, length: 3}); 
                    } else {
                        addStatus({target, origin: user, status: "weakened", origin: user, length: 3}); 
                    }
					let newAllySlug = this.possibleSpawns.sample()
					user.lastSide = !user.lastSide
					if(user.team.members.filter(m=>m.slug.includes('angel_')).length < (fated ? fated.power + 4 : 4)) {
						midCombatActorAdd(env.rpg.allyTeam, newAllySlug, user.lastSide ? "left" : "right")
					}
				}
			})
		}
	},
	
	env.ACTIONS.special_spine_merge_mega = {
        slug: "special_spine_merge_mega",
        name: "Reconsolidate",
        type: 'self+autohit+support',
        anim: "",
        usage: {
            act: "%USER CONSOLIDATES THEIR SUMMONS..."
        },
        details: {
            flavor: "'sacrifice greater angelic allies to create more powerful ally'",
            onUse: `'DOWN angelic allies';'summon 1 major angel per 4 greater angels (max:4)'`,
        },
        autohit: true,
		avoidChaining: true,
		noRepeat: true,
		possibleSpawns: ["angelGreater_pawn", "angelGreater_knight", "angelGreater_bishop", "angelGreater_rook", "angelGreater_queen", "angelGreater_king"],
        disableIf: (actor) => {
		  if(actor.team.members.filter(m => m.slug.includes('angel_')).length < 4) { return "NOT ENOUGH ALLIES" }
		  if(actor.team.members.filter(m => m.slug.includes('angelGreater_')).length >= 4) { return "TOO MANY ALLIES" }
		},
        exec: function(user, target) {
			let fated = user.statusEffects.find(status => status.slug == "fated_spine")
			let fodderConsumed = 0
			if(fated && fated.power) {
				this.disableIf = (actor) => { // this SHOULD work. i think. i'm pretty sure
				  if(actor.team.members.filter(m => m.slug.includes('angel_')).length < 4) { return "NOT ENOUGH ALLIES" }
				  if(actor.team.members.filter(m => m.slug.includes('angelGreater_')).length >= (fated ? fated.power + 4 : 4)) { return "TOO MANY ALLIES" }
				}
			}

			user.team.members.forEach((member) => {
				if (member.slug.includes('angel_') && user.team.members.filter((m) => m.slug.includes('angelGreater_')).length < (fated ? fated.power + 4 : 4)) {
					console.log("consuming summon now")

					midCombatActorRemove(member)
					play('chomp', 0.6)

					fodderConsumed++

					if (fodderConsumed == 4) {
						fodderConsumed = 0

						let newAllySlug = this.possibleSpawns.sample()

						midCombatAllyAdd(newAllySlug, "right")
						playCombatCrit('dull', 0.5)
					}
				}
			})
		}
    }

// NOTE TO SELF::you gotta remove the comma on the last action here or else midCombatAllyAdd gets undefined for reasons unclear to me
// CUSTOM FUNCTIONS
function midCombatAllyAdd(actorSpecifier, side = "right") {
    if(!env.rpg.active) return false;
    
    let actor = initializeActor(actorSpecifier, {team: env.rpg.allyTeam, enemyTeam: env.rpg.enemyTeam, uniqify: true, side})
    
    if(env.rpg.settings.actorPreprocess) env.rpg.settings.actorPreprocess(actor)
    if(actor.base?.events?.onInitialize) actor.base.events.onInitialize(actor)
    if(actor.alterations || env.rpg.settings.teamAlterations?.enemy || env.rpg.settings.teamAlterations?.all ) actor.actions = getAlteredActorActions({member: actor, actor: actor})

    initializeActorUI({actor, team: env.rpg.allyTeam, side, animateIn: false})

    //update the turnorder
    env.rpg.turnOrder = []
    env.rpg.teams.forEach((team, i) => {
        env.rpg.turnOrder = env.rpg.turnOrder.concat(team.members);
    })
	
	//update current actor accordingly
    if(side == "left") {
        env.rpg.currentActorIndex = env.rpg.turnOrder.findIndex((a) => a == env.rpg.currentActor)
    }

    updateStats()
    return actor
}

function midCombatAllyRemove(actor) {
    env.rpg.allyTeam.members = env.rpg.allyTeam.members.filter(a => a.slug != actor.slug)
    delete env.rpg.actors[actor.slug]

    content.querySelectorAll(`#ally-team #${actor.slug}`).forEach(el=>{
        setTimeout(()=>{
            el.remove()
        }, 1000)
    })

    //update the turnorder
    env.rpg.turnOrder = []
    env.rpg.teams.forEach((team, i) => {
        env.rpg.turnOrder = env.rpg.turnOrder.concat(team.members);
    })

    updateStats()
}

if(!env.adenator_toomanyhumors) {addResources(["https://adenator.neocities.org/corrumods/literallyTooManyHumors.js"])} //LITERALLY TOO MANY HUMORS by adenator; adds scroll to humor list

// oh boy here we go
// TODO:: create function that checks for a component's showIf property, and changes that component's dontSpawnNormally property to true or false depending on the output
// NOTE TO SELF::oh my god don't do this again it's so bad

function fakeComponentLock() { // absolutely no idea what to pass in here
	if (env.crittaMap) { 
		console.log("performing showIf check now")
		let humors = env.COMBAT_COMPONENTS 
//		if(humors.chaos.showIf()) {
//			humors.chaos.dontSpawnNormally = false
//			console.log("enabling chaos humor")
//		} else { humors.chaos.dontSpawnNormally = true
//			console.log("disabling chaos humor") }
		if(humors.intrusive.showIf()) {
			console.log("enabling intrusive humor")
			humors.intrusive.dontSpawnNormally = false
		} else { humors.intrusive.dontSpawnNormally = true
			console.log("disabling intrusive humor") }
	}
}

//setInterval(fakeComponentLock, 30000) // TODO::don't do this

// wahoo !!!!!!!! swarm won't be terrible anymore !!!!!!!!!!!!!!!!!!!!! a kind light in this hateful gaze !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// everyone say thank you dutokrisa and voidkat !!!!!!!!!!!!!!!!!!
function midCombatActorTeamSwap(team, actorSpecifier, side = "right") { // i am renaming y'all's function though :P
    if(!env.rpg?.active) return false;

    console.warn("oh boy here we go:: " + actorSpecifier.slug  + " is now getting swapped to " + team.name)
  	midCombatActorRemove(env.rpg.actors[actorSpecifier.slug])

    let enemyTeam
    switch(team.name) {
        case "enemy": enemyTeam = env.rpg.allyTeam; break;
        case "ally": enemyTeam = env.rpg.enemyTeam; break;
    }

    let actor = actorSpecifier;
    actor['sprite'] = "/img/sprites/obesk/larval/larval7.gif"
  	actor['slug'] = actor['slug'] + env.rpg.entCount++
    actor['team'] = team;
    actor['enemyTeam'] = enemyTeam;
  
    env.rpg.actors[actor.slug] = actor
    side == "right" ? team.members.push(actor) : team.members.unshift(actor)

    //preprocessing
    if(env.rpg.settings.actorPreprocess) env.rpg.settings.actorPreprocess(actor)
    if(actor.base?.events?.onInitialize) actor.base.events.onInitialize(actor)

    //update turn order, etc
    initializeActorUIFUCKYOU({actor, team, side, animateIn: true})
    env.rpg.turnOrder = []
    env.rpg.teams.forEach(t => { env.rpg.turnOrder = env.rpg.turnOrder.concat(t.members) })
    //update current actor accordingly
    if(side == "left") {
        env.rpg.currentActorIndex = env.rpg.turnOrder.findIndex((a) => a == env.rpg.currentActor)
    }
    updateStats()
    return actor
}

function initializeActorUIFUCKYOU({actor, team, side, animateIn = false}) { // i'm gonna keep this function name the same because haha funny :)
    let i = team.members.findIndex(act => act == actor)
    var actorTemplate = `
        <div id="%SLUG" style="--index: ${i}" index="${i}" class="actor ${actor.specialClass || ""} ${animateIn ? "phasing" : ""}">
            <div class="clickbox" actor-id="%SLUG"></div>
            %PORTRAIT
            <div class="statusbg"></div>
            <span class="statdisplay">
                <span class="name"></span>
                <span class="statuses"></span>
                <span class="points">
                    <span class="hp"></span>
                    <span class="bp" definition="STAT::BARRIER:LIMITED TO 1/2 MAX HP"></span>
                </span>
                <span class="state"></span>
            </span>
            <div class="passives"></div>
            <div class="actions"></div>
            <div class="floatbox"></div>
            <div class="combat-dialogue"></div>
        </div>
    `
    
    var portrait = ""
    var insertSpot = side == "left" ? 'afterbegin' : 'beforeend'
    if(actor.portrait) {portrait = actor.portrait.replaceAll("[[PORTRAITURL]]", actor.portraitUrl)}
    if(team.name == "enemy" && env.rpg.settings?.combatClass?.includes("crittamode")) actorTemplate = actorTemplate.replace(`<div class="actions"></div>`, `<details class="enemy-actions"><summary definition="NOTE::'analysis granted via vessel terminals'\nWARNING::'repeated actions are more likely to be used'">ACTIONS</summary></details>`)

    content.querySelector(`#${team.name}-team`).insertAdjacentHTML(insertSpot, actorTemplate.replaceAll('%SLUG', actor.slug).replaceAll('%PORTRAIT', portrait))
    actor.box = content.querySelector(`.team #${actor.slug}.actor`)
    actor.hitBox = actor.box.querySelector(".floatbox")

    /* in combat-scene, hovering a box will focus on the character */
    if(env.rpg.is2D) {
        //on mouseenter, highlight and focus on actor
        actor.box.addEventListener('mouseenter', function(ev){
            if(env.rpg.currentActor == actor || env.rpg.state == "animating" || !actor.piece) return;
            env.rpg.grid.focusOnTile(actor.piece.tile)
            actor.highlight("box")
        })

        //on mouseleave, focus back on env.rpg.currentActor and remove highlight
        actor.box.addEventListener('mouseleave', function(){
            if(env.rpg.currentActor == actor || env.rpg.state == "animating" || !env.rpg.currentActor.piece) return;
            env.rpg.grid.focusOnTile(env.rpg.currentActor.piece.tile)
            actor.highlight(false)
        })
    }

    if(team.name == "enemy") { 
        //only enemies get full on graphics
        let graphic = actor.graphic.replaceAll('%SLUG', actor.slug)
        if(animateIn) graphic = graphic.replace('sprite-wrapper', 'sprite-wrapper phasing')
        switch(env.rpg.tagName) {
            case "COMBAT-SCENE":
                actor.readyGraphic = graphic
            break

            default:
                content.querySelector('#enemy-graphic').insertAdjacentHTML(insertSpot, graphic)
        }

        //in crittamode, you can see enemy actions, and the zones that affect them
        if(env.rpg.settings?.combatClass?.includes("crittamode")) {
            content.querySelector(`#${actor.slug}.actor .enemy-actions`).insertAdjacentHTML('beforeend', generatePartyActions(actor))
        }
    } else {
        //allies have components via their party members
        //enemies CAN have components directly on the object
        let componentSource = false
        if(actor.member?.components) componentSource = actor.member;
        else if (actor.components) componentSource = actor;
        
        if(componentSource !== false) actor.box.insertAdjacentHTML('beforeend', generateComponentDisplay(componentSource))
    }

    actor.sprite = content.querySelector(`#${actor.slug}-sprite-wrapper`)
    if(actor.sprite) actor.sprite.setAttribute("for", `${actor.base.slug}`)

    //handle any special spritework
    if(actor.base.events) {
        if(actor.base.events.onSpawn) actor.base.events.onSpawn(actor)
    }
    if(!env.rpg.is2D && env.rpg.settings.actorSpriteProcess) env.rpg.settings.actorSpriteProcess(actor)

    //if any actors should start with status effects, initialize them now that the element exists
    if(actor.initialStatusEffects) {
        actor.initialStatusEffects.forEach(status=>addStatus({target: actor, status: status[0], length: status[1], noReact: true, noUpdate: true, forceAdd: true}))
    }

    //ditto but at the party member level
    if(page.party) {
        let partyGuy = page.party.find(member => member.slug == actor.slug)
        if(partyGuy) {
            if(partyGuy.initialStatusEffects) {
                partyGuy.initialStatusEffects.forEach(status=>addStatus({target: actor, status: status[0], length: status[1], noReact: true, noUpdate: true, forceAdd: true}))
            }

            if(partyGuy.name != actor.name) actor.name = partyGuy.name
        }
    }

    if(animateIn) setTimeout(()=>{
        actor.box.classList.remove('phasing')
        actor.sprite.classList.remove('phasing')
    }, 100)
}

// FUNCTION MODIFICATIONS

env.STATUS_EFFECTS.retaliation.events.GLOBAL_onEvade = function({subject, target, attack, originalEventTarget}) {
                let user = this.status.affecting
                if(
                    !user.enemyTeam.members.includes(subject) || 
                    subject.state == "dead" ||
                    user.state == "dead" ||
                    target == user ||
                    hasStatus(user, "fear")
                ) return;

                let primary = env.ACTIONS[user.actions[0]]
				if(hasStatus(user, "windup")) (primary = env.ACTIONS[user.windupActions[0]])
				if(hasStatus(user, "winderup")) (primary = env.ACTIONS[user.winderupActions[0]])
				if(hasStatus(user, "windestup")) (primary = env.ACTIONS[user.windestupActions[0]])
				if(hasStatus(user, "final_windup")) (primary = env.ACTIONS[user.finalWindupActions[0]])
				if(hasStatus(user, "windup_aim")) (primary = env.ACTIONS[user.aimingActions[0]])

                setTimeout(()=>{
                    useAction(this.status.affecting, primary, subject, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "retaliation"})
            
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "action",
                        arbitraryString: `RETALIATE::${primary.name.toUpperCase()}`,
                        size: 1.5,
                    })

                    readoutAdd({
                        message: `${user.name} retaliates against ${subject.name} as they miss! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }

env.STATUS_EFFECTS.fated_bone.events.onStruck = function({subject, target, attack, beneficial, originalEventTarget}) {
                let user = this.status.affecting

                if(
                    env.rpg.lastRedirector != user ||
                    beneficial ||
                    !user.enemyTeam.members.includes(subject) || 
                    user.state == "dead"
                ) return;

                let primary = env.ACTIONS[user.actions[0]]
				if(hasStatus(user, "windup")) (primary = env.ACTIONS[user.windupActions[0]])
				if(hasStatus(user, "winderup")) (primary = env.ACTIONS[user.winderupActions[0]])
				if(hasStatus(user, "windestup")) (primary = env.ACTIONS[user.windestupActions[0]])
				if(hasStatus(user, "final_windup")) (primary = env.ACTIONS[user.finalWindupActions[0]])
				if(hasStatus(user, "windup_aim")) (primary = env.ACTIONS[user.aimingActions[0]])

                setTimeout(()=>{
                    useAction(this.status.affecting, primary, subject, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "FATE::BONE"})
                
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "fate",
                        arbitraryString: "FATE::BONE",
                    })
                
                    readoutAdd({
                        message: `${user.name} counterattacks ${subject.name} as they guard! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }

env.STATUS_EFFECTS.impatient.events.GLOBAL_onAction = function({target, user, hit, action, beingUsedAsync, reason, originalEventTarget}) {
                if(
                    hit != "crit" ||
                    this.status.affecting.state == "dead" || 
                    user == this.status.affecting || 
                    originalEventTarget == this.status.affecting ||
                    this.status.affecting.enemyTeam.members.includes(user) || 
                    this.status.affecting.team.members.includes(target) || 
                    target.state == "dead" ||
                    reason != false ||
                    this.status.turnUsage ||
                    hasStatus(user, "fear")
                ) return;

                this.status.turnUsage = true
                let primary = env.ACTIONS[this.status.affecting.actions[0]]
				if(hasStatus(this.status.affecting, "windup")) (primary = env.ACTIONS[this.status.affecting.windupActions[0]])
				if(hasStatus(user, "winderup")) (primary = env.ACTIONS[user.winderupActions[0]])
				if(hasStatus(user, "windestup")) (primary = env.ACTIONS[user.windestupActions[0]])
				if(hasStatus(user, "final_windup")) (primary = env.ACTIONS[user.finalWindupActions[0]])
				if(hasStatus(user, "windup_aim")) (primary = env.ACTIONS[user.aimingActions[0]])

                setTimeout(()=>{
                    useAction(this.status.affecting, primary, target, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "impatient"})
            
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "action",
                        arbitraryString: `IMPATIENT::${primary.name.toUpperCase()}`,
                        size: 1.5,
                    })
                
                    readoutAdd({
                        message: `${this.status.affecting.name} joins in ${user.name}'s attack on ${target.name}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.5)
            }

env.STATUS_EFFECTS.active_support.events.GLOBAL_onAction = function({target, user, hit, reason, action, beingUsedAsync, originalEventTarget}) {
                if(
                    hit != "crit" ||
                    this.status.affecting.state == "dead" || 
                    user == this.status.affecting || 
                    originalEventTarget == this.status.affecting ||
                    this.status.affecting.enemyTeam.members.includes(user) || 
                    this.status.affecting.team.members.includes(target) || 
                    target.state == "dead" ||
                    this.status.turnUsage ||
                    !this.status.affecting.actions[1] ||
                    hasStatus(user, "fear")
                ) return;

                this.status.turnUsage = true
                let secondary = env.ACTIONS[this.status.affecting.actions[1]]
				if(hasStatus(this.status.affecting, "windup") && this.status.affecting.windupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.windupActions[1]])
				if(hasStatus(this.status.affecting, "winderup") && this.status.affecting.winderupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.winderupActions[1]])
				if(hasStatus(this.status.affecting, "windestup") && this.status.affecting.windestupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.winderupActions[1]])
				if(hasStatus(this.status.affecting, "final_windup") && this.status.affecting.finalWindupActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.finalWindupActions[1]])
				if(hasStatus(this.status.affecting, "windup_aim") && this.status.affecting.aimingActions.length > 1) (secondary = env.ACTIONS[this.status.affecting.aimingActions[1]])

                setTimeout(()=>{
                    useAction(this.status.affecting, secondary, secondary.beneficial ? user : target, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "active support"})

                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        specialClass: "action",
                        arbitraryString: `SUPPORT::${secondary.name.toUpperCase()}`,
                        size: 1.5,
                    })
                
                    readoutAdd({
                        message: `${this.status.affecting.name} provides support alongside ${user.name}'s attack on ${target.name}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.5)
            }

env.STATUS_EFFECTS.visionary.events.onCrit = function({subject, origin, attack, beneficial}) {
                let user = this.status.affecting
                if(beneficial || user.team.members.includes(subject) || user.state == "dead" || !user.actions[2] || hasStatus(user, "fear")) return;

                let dullUtility = [2, 4, 4, 5, 5, 5, 6, 6, 6, 6] //vestigial variable
				
                let utility = env.ACTIONS[user.actions[2]]
				if (user.actions.includes('special_player_dullsummon_low')) {
					utility = env.ACTIONS[user.actions[dullUtility.sample()]]
				}

                
                setTimeout(()=>{
                    sendFloater({
                        target: user,
                        type: "arbitrary",
                        specialClass: "action",
                        arbitraryString: `VISIONARY::${utility.name.toUpperCase()}`,
                        size: 1.5,
                    })

                    readoutAdd({
                        message: `${user.name} grasps the opportunity! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                    
                    useAction(user, utility, subject, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "visionary"})
                }, 500)
            }
			
env.ACTIONS.special_enact.exec = function(user, target) {
            let amt = Math.floor(hasStatus(target, 'evasion'))
			let amt2 = 2 * Math.floor(hasStatus(target, 'evasion_mega'))
			let finalAmt = amt + amt2
            removeStatus(user, "evasion")
			removeStatus(user, "evasion_mega")
			let primary = env.ACTIONS[user.actions[0]]
			if(hasStatus(user, "windup")) (primary = env.ACTIONS[user.windupActions[0]])
			if(hasStatus(user, "winderup")) (primary = env.ACTIONS[user.winderupActions[0]])
			if(hasStatus(user, "windestup")) (primary = env.ACTIONS[user.windestupActions[0]])
			if(hasStatus(user, "final_windup")) (primary = env.ACTIONS[user.finalWindupActions[0]])
			if(hasStatus(user, "windup_aim")) (primary = env.ACTIONS[user.aimingActions[0]])
            actionMessage(user, "%USER LAUNCHES THEIR ATTACK", target, 'none', 1000 + (finalAmt * 200))

            for (let i = 0; i < finalAmt; i++) {
                env.setTimeout(()=>{
                    let target = user.enemyTeam.members.filter(t=>t.state != "dead").sample()
                    if(target) useAction(user, primary, target, {triggerActionUseEvent: i == 0, beingUsedAsync: true, reason: "enact", noUseMessage: true})
                }, i * 200)
            }

            env.setTimeout(()=>{
                advanceTurn(user)
            }, (finalAmt * 200) + 500)
        }
		
env.ACTIONS.special_enact.disableIf = (actor)=>{
			if(!hasStatus(actor,"evasion") && !hasStatus(actor,"evasion_mega")) return "REQUIRES EVASION/UNNATURAL SPEED" //check for if they have one of the two statuses, and let them through if they do
		}
		
env.ACTIONS.windup.exec = function(user, target) {
	if(user.windupActions !== "undefined" && user.windupActions.includes("special_enact_missile")) {
		user.windupActions = user.windupActions.filter(action => action !== "focused_shot_weak") // we still don't have a good way to replace windup actions, so we quietly remove the original windup actions in reload instead (ported to preparation as well due to shenanigans :P)
		user.windupActions = user.windupActions.filter(action => action !== "hold_aim")
	}
	if(user.windupActions !== "undefined" && user.windupActions.includes("special_judgement_player")) {
		user.windupActions = user.windupActions.filter(action => action !== "special_rule_player")
	}
	if(user.windupActions !== "undefined" && user.windupActions.includes("haymaker")) {
		user.windupActions = user.windupActions.filter(action => action !== "archival_smash")
	}
	if(user.windupActions !== "undefined" && user.windupActions.includes("special_combinesummon_select")) {
		user.windupActions = user.windupActions.filter(action => action !== "special_combinesummon")
	}
	if(user.windupActions !== "undefined" && user.windupActions.includes("kivtezruka")) {
		user.windupActions = user.windupActions.filter(action => action !== "cavik_attack_mega")
	}
	if(user.windupActions !== "undefined" && user.windupActions.includes("calculated_frenzy")) {
		user.windupActions = user.windupActions.filter(action => action !== "calculated_stab")
	}
	play('talklaugh', 0.5);
	addStatus({target: user, status: "windup", length: 1}); 
	return 'nothing';
}

env.ACTIONS.windup_cover.exec = function(user, target) { // oops forgot to do it with the other one :P
	if(user.windupActions !== "undefined" && user.windupActions.includes("special_enact_missile")) {
		user.windupActions = user.windupActions.filter(action => action !== "focused_shot_weak") // we still don't have a good way to replace windup actions, so we quietly remove the original windup actions in reload instead (ported to preparation as well due to shenanigans :P)
		user.windupActions = user.windupActions.filter(action => action !== "hold_aim")
	}
	if(user.windupActions !== "undefined" && user.windupActions.includes("special_judgement_player")) {
		user.windupActions = user.windupActions.filter(action => action !== "special_rule_player")
	}
	if(user.windupActions !== "undefined" && user.windupActions.includes("haymaker")) {
		user.windupActions = user.windupActions.filter(action => action !== "archival_smash")
	}
	if(user.windupActions !== "undefined" && user.windupActions.includes("special_combinesummon_select")) {
		user.windupActions = user.windupActions.filter(action => action !== "special_combinesummon")
	}
	if(user.windupActions !== "undefined" && user.windupActions.includes("kivtezruka")) {
		user.windupActions = user.windupActions.filter(action => action !== "cavik_attack_mega")
	}
	if(user.windupActions !== "undefined" && user.windupActions.includes("calculated_frenzy")) {
		user.windupActions = user.windupActions.filter(action => action !== "calculated_stab")
	}
	play("talkgel")
	addStatus({target: user, status: "evasion", length: 1, noReact: true}); 
	addStatus({target: user, status: "windup", length: 1}); 
	return 'nothing';
}

env.STATUS_EFFECTS.spikes.events.onStruck = function({subject, attack, beneficial}) {
                if(beneficial) return;
				if(this.status.affecting == subject) return;
                let fated = this.status.affecting.statusEffects.find(status => status.slug == "fated_bone")
                let returnDmg = Math.max(Math.floor(attack * 0.5), fated ? fated.power + 1 : 1)

                setTimeout(()=>{
                    sendFloater({
                        target: subject,
                        type: "arbitrary",
                        arbitraryString: "SPIKED!",
                        beneficial: false,
                        size: 1,
                    })

                    readoutAdd({
                        message: `${subject.name} receives ${Math.abs(returnDmg)} damage via <span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })

                    forcePlay("stab", 0.7, 0.8)
                    combatHit(subject, {amt: returnDmg, autohit: true, crit: 0, origin: false, redirectable: false})
                }, env.ADVANCE_RATE * 0.2)
            }
			
env.STATUS_EFFECTS.bone_adaptive.events.onStruck = function({subject, attack, beneficial}) {
                if(beneficial || this.status.affecting.state == "dead" || this.status.affecting == subject) return;
                addStatus({target: this.status.affecting, origin: subject, status: "spikes", length: 2}); 

                setTimeout(()=>{
                    play("guard", 1.25, 0.5)
                    
                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "ADAPT!",
                    })
                                    
                    readoutAdd({
                        message: `${this.status.affecting.name}'s form shifts defensively in response to the attack! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }, env.ADVANCE_RATE * 0.2)
            }
		
env.STATUS_EFFECTS.light_laughterhouse.events.onAction = function({user, action, target}) {
                if(action.slug.includes("incoherent_") || action.slug.includes("intrusive") || action.slug == "special_archiveshelf_annihilate" || action.slug == "frenzy_heal" || target.state == "dead" || user.state == "dead" || hasStatus(user, "fear") || user.frenzyChainKilled == true) return;
                
                if(Math.random() < (0.2 + hasStatus(user, "light_humorist") ? 0.2 : 0)) {
                    reactDialogue(this.status.affecting, 'laugh')

                    sendFloater({
                        target: this.status.affecting,
                        type: "arbitrary",
                        arbitraryString: "LAUGHTERHOUSE!",
                        size: 1.5
                    })

                    readoutAdd({
                        message: `${user.name} acts again! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail", 
                        show: false,
                        sfx: false
                    })
                    setTimeout(()=>useAction(user, action, target, {triggerActionUseEvent: false, beingUsedAsync: true, reason: "laughterhouse"}), 500)
                }
            }

env.STATUS_EFFECTS.sacrifice.events.onAction = function({user, action, target}) {
				if(!action.slug.includes("windup")) { //added safeguard for if the affected actor just used preparation or a similar action
					removeStatus(this.status.affecting, "sacrifice") 
				}
            }
			
env.STATUS_EFFECTS.sacrifice.help = "+2 base outgoing damage/heal, +200% HIT% & CRIT%, consumed by next action (not consumed by PREPARATION or similar actions)"

env.STATUS_EFFECTS.claws_rabid.events.onBeforeAction = function(context) {
                if(!context.settings.action.type.includes("target")) return;
				if(context.settings.action.slug.includes(["special_grenade", "special_grenade_fear", "special_grenade_incendiary", "special_grenade_poison", "special_grenade_teleport"])) return; // whyyyyyy does it softlock if they throw a grenade :(
                let pow = hasStatus(this.status.affecting, "rot");
                
                // alter action maybe
                if(Math.random() < (0.25 + (pow * 0.01))) {

                    context.settings.action = env.ACTIONS["bite"]
                    let subject = context.settings.user

                    sendFloater({
                        target: subject,
                        type: "arbitrary",
                        arbitraryString: "RABID!",
                        beneficial: false,
                        size: 2,
                    })

                    readoutAdd({
                        message: `${subject.name}'s uncontrollably bites ${context.settings.target.name}! (<span definition="${processHelp(this.status, {caps: true})}">${this.status.name}</span>)`, 
                        name: "sourceless", 
                        type: "sourceless combat minordetail",
                        show: false,
                        sfx: false
                    })
                }
            }

			//TODO::re-add denatured, cursed, and siphon_mega into Da Thing
env.STATUS_EFFECTS.global_escalation.events.onAddStatus = function({target, statusObj}) {
                let statusChange = false
                let power = env.crittaMap.getModQty("global_escalation")
				let baseStatus = env.STATUS_EFFECTS[statusObj.slug]
                switch(statusObj.slug) {
                    case "puncture": // escalation stack increases minimum damage by 1
                    case "rot":
                        statusObj.oldName = baseStatus.name
                        statusObj.name = statusObj.oldName + '+'.repeat(power)
                        statusObj.help = processHelp(baseStatus).replace("min:1", `min:${power + 1}`)
                        statusChange = true 
                    break

                    case "vulnerable": // escalation stack gives this a +50% incoming damage mult
                        statusObj.incomingMult = 0.5 * power
                        statusObj.oldName = baseStatus.name
                        statusObj.name = statusObj.oldName + '+'.repeat(power)
                        statusObj.help = processHelp(baseStatus) + `, +${Math.floor(50 * power)}% incoming damage/heal`
                        statusChange = true
                    break
					
					case "vulnerable_mega": // escalation stack gives this +5% base incoming crit boost
                        statusObj.incomingFlatCrit = 0.05 * power
                        statusObj.oldName = baseStatus.name
                        statusObj.name = statusObj.oldName + '+'.repeat(power)
                        statusObj.help = processHelp(baseStatus) + `, +${Math.floor(5 * power)}% base incoming crit% (before bonuses)`
                        statusChange = true
                    break
					
					case "cursed": // escalation stack gives this a +50% incoming hit and crit mult
						statusObj.oldName = baseStatus.name
                        statusObj.name = statusObj.oldName + '+'.repeat(power)
						statusObj.incomingToHit = 0.75 + (power * 0.5)
						statusObj.incomingCrit = 2 + (power * 0.5)
						statusObj.help = `+${baseStatus.incomingToHit * 100}% incoming hit%, +${baseStatus.incomingCrit * 100}% incoming crit%, -50% outgoing hit%, crit%`
                        statusChange = true
                    break

                    case "siphon": // escalation stack increases direct heal by 1
                        statusObj.oldName = baseStatus.name
                        statusObj.name = statusObj.oldName + '+'.repeat(power)
                        statusObj.help = processHelp(baseStatus).replace("1HP", `${power + 1}HP`)
                        statusChange = true
                    break
					
					case "siphon_mega": // escalation stack increases direct heal by 2
                        statusObj.oldName = baseStatus.name
                        statusObj.name = statusObj.oldName + '+'.repeat(power)
                        statusObj.help = processHelp(baseStatus).replace("2HP", `${(power * 2) + 2}HP`)
                        statusChange = true
                    break

                    case "destabilized": // escalation stack increases incoming damage by another 50%
                        statusObj.incomingMult = 1 + (power * 0.5)
                        statusObj.oldName = baseStatus.name
                        statusObj.name = statusObj.oldName + '+'.repeat(power)
                        statusObj.help = `+${Math.floor(baseStatus.incomingMult * 100)}% incoming damage/heal, +100% outgoing`
                        statusChange = true
                    break
					
					case "denatured": // escalation stack increases incoming damage by another 100%
                        statusObj.incomingMult = 2 + (power)
                        statusObj.oldName = baseStatus.name
                        statusObj.name = statusObj.oldName + '+'.repeat(power)
                        statusObj.help = `+${Math.floor(baseStatus.incomingMult * 100)}% incoming damage/heal, +200% outgoing`
                        statusChange = true
                    break

                    case "open_wound": // escalation stack increases by +1 flat
                        statusObj.incomingFlat = 1 + power
                        statusObj.oldName = baseStatus.name
                        statusObj.name = statusObj.oldName + '+'.repeat(power)
                        statusObj.help = processHelp(baseStatus).replace("+1", `+${statusObj.incomingFlat}`)
                        statusChange = true
                    break

                    case "weakened": // escalation stack also reduces hit chance by 20%
                        statusObj.oldName = baseStatus.name
                        statusObj.outgoingToHit = power * -.2
                        statusObj.name = statusObj.oldName + '+'.repeat(power)
                        statusObj.help = processHelp(baseStatus) + `, ${Math.floor(statusObj.outgoingToHit * 100)}% hit%`
                        statusChange = true
                    break

                    case "fear": // when afraid, take damage from defeating nearby foes
                        statusObj.oldName = baseStatus.name
                        statusObj.name = statusObj.oldName + '+'.repeat(power)
                        statusObj.help = processHelp(baseStatus).replace("actions prohibited", `actions prohibited\nwhen an ally dies, take ${Math.floor(power * 10)}% of their max HP in damage`)
                        statusChange = true
                    break
                }
            }

					/* only commenting out in case we need it later
					onAddStatus: function({target, statusObj}) {
						let statusChange = false
						let power = env.crittaMap.getModQty("global_escalation")
						switch(statusObj.slug) {
							case "siphon_mega": // escalation stack increases direct heal by 2
								statusObj.oldName = statusObj.name
								statusObj.name = statusObj.name + '+'.repeat(power)
								statusObj.help = statusObj.help.replace("2HP", `${(power * 2) + 2}HP`)
								statusChange = true
							break
							case "denatured": // escalation stack increases incoming damage by another 100%
								statusObj.incomingMult = 1 + (power)
								statusObj.oldName = statusObj.name
								statusObj.name = statusObj.name + '+'.repeat(power)
								statusObj.help = `+${statusObj.incomingMult * 100}% incoming damage/heal, +200% outgoing`
								statusChange = true
							break
							case "cursed": // escalation stack increases incoming hit% and crit% by 50%
								statusObj.oldName = statusObj.name
								statusObj.name = statusObj.name + '+'.repeat(power)
								statusObj.incomingToHit = 0.75 + (power * 0.5)
								statusObj.incomingCrit = 2 + (power * 0.5)
								statusObj.help = `+${statusObj.incomingToHit * 100}% incoming hit%, +${statusObj.incomingCrit * 100}% incoming crit%, -50% outgoing hit%, crit%`
								break
						}
					}


env.ACTIONS.special_enact.exec = function(user, target) {
            let amt = Math.floor(hasStatus(target, 'evasion'))
			let amt2 = 2 * Math.floor(hasStatus(target, 'unnatural_speed'))
			let finalAmt = amt + amt2
            removeStatus(user, "evasion")
			let primary = env.ACTIONS[user.actions[0]]
			if (hasStatus(user, "windup")) (primary = env.ACTIONS[user.windupActions[0]])
            actionMessage(user, "%USER LAUNCHES THEIR ATTACK", target, 'none', 1000 + (finalAmt * 200))

            for (let i = 0; i < finalAmt; i++) {
                env.setTimeout(()=>{
                    let target = user.enemyTeam.members.filter(t=>t.state != "dead").sample()
                    if(target) useAction(user, primary, target, {triggerActionUseEvent: i == 0, beingUsedAsync: true, reason: "enact", noUseMessage: true})
                }, i * 200)
            }

            env.setTimeout(()=>{
                advanceTurn(user)
            }, (finalAmt * 200) + 500)
        }
		
env.ACTIONS.special_enact.disableIf = (actor)=>{ if(!hasStatus(actor,"evasion") || !hasStatus(actor,"unnatural_speed")) return "REQUIRES EVASION" }
					*/

let newHumors = ["flesh", "dull", "spirestone", "hands", "metal", "pain", "lightning", "heart", "chaos", "order", "zuka", "spine"]
if(check("flan")) (newHumors.push("intrusive"))
if(check("cmb_unlocked")) (newHumors.push("cmb"))

for (const componentName of newHumors) { // this probably isn't a function but i don't know where else to put it
    const component = env.COMBAT_COMPONENTS[componentName]
	let commerceObject = ({
        type: "humor",
        name: `${component.name.replace("Humor of ", "")}`,
        subject: component,
        value: 1,

        showSellIf: ()=> env.e3a2.mTotals[componentName].available > 0,
        sellExec: ()=>{
            addItem("sfer_cube")
            page.flags.components[componentName]--
            env.e3a2.mTotals = CrittaMenu.getTotals()
            env.commerceNotice = `exchanged ${component.name} for 1 ${env.ITEM_LIST['sfer_cube'].name}`
        },
    })
		env.e3a2.merchant.sellResponses.replies.push({
		name: `${commerceObject.name}::${commerceObject.value}S`,
		destination: "sell",
		hideRead: true,
		showIf: commerceObject.showSellIf,
		class: `commerce-${commerceObject.type}`,
		definition: `NOTE::'exchange for ${commerceObject.value} ${env.ITEM_LIST['sfer_cube'].name}'`,
		exec: ()=> {commerceObject.sellExec(); env.e3a2.mTotals = CrittaMenu.getTotals(); env.e3a2.updateExchangeScreen()}
	})
    env.e3a2.merchant.commerce.push(commerceObject)
}

    //hopefully this fixes the ADD_WINDUP shenanigans
CrittaMenu.generateStatHTMLObject = function(stats, {member, slotName, componentName, editingMember = {}} = {}) {
    let returnStats = {
        core: "",
        in: "",
        out: ""
    }

    let component = false
    if(componentName) component = env.COMBAT_COMPONENTS[componentName][slotName]

    //if a specific component is specified, we can also get a list of perma/auto statuses from it
    if(component?.alterations || member?.components) {
        function addStatusLine(statusObj) {
            returnStats.core += `
                <div class="stat status" 
                    type="status" 
                    pretty="${statusObj.name}"
                    definition="${statusObj.impulse ? `IMPULSE::` : 'PASSIVE::'}'${statusObj.name}'\nEFFECT::${processHelp(statusObj, {caps: true})}"
                    good="${statusObj.beneficial ? String(statusObj.beneficial).replace("true", "good") : "bad"}"
                >+ ${statusObj.name}</div>
            `
        }

        function addActionLine(actionObj, override = "ADD") {
            let effectiveOverride = override
            switch(effectiveOverride) {
                case "ADD": break
                case "ADD_WINDUP": break
                default:
                    effectiveOverride = env.ACTIONS[override].name
            }

            returnStats.core += `
                <div class="stat action" 
                    type="action"
                    override="${effectiveOverride}"
                    definition="ACTION++${actionObj.slug}"
                >${actionObj.name}</div>
            `
        }

        //for components, we also compile any used augments to display the proper end effect
        if(component?.alterations) {
            let effectiveAlterations = [... component.alterations]

            //get all augments that...
                // that AREN'T in pending remove AND are currently in use
                // are in the pending add
            let effectiveAugments = []
            if(editingMember.augments) effectiveAugments = effectiveAugments.concat(editingMember.augments)
            if(editingMember.augmentChanges) {
                effectiveAugments = effectiveAugments.concat(editingMember.augmentChanges.add)
                effectiveAugments = effectiveAugments.filter(aug => !editingMember.augmentChanges.remove.includes(aug))
            }

            //combine the gathered augments with the effective alterations
            //filter down to just those for this specific component and slot
            for (const augmentSlug of effectiveAugments) {
                const augment = env.ACTOR_AUGMENTS.generic[augmentSlug]
                if(augment.component[0] == slotName && augment.component[1] == componentName) effectiveAlterations = effectiveAlterations.concat(augment.alterations)
            }

            console.log('effective augments are', effectiveAugments, 'alts are', effectiveAlterations)
            for (const alteration of effectiveAlterations) {
                if(alteration[0] == "STATUS") addStatusLine(env.STATUS_EFFECTS[alteration[1]]);
                else switch(alteration[0]) {
                    case "ADD":
                        addActionLine(env.ACTIONS[alteration[1]])
                    break
                    
                    default:
						addActionLine(env.ACTIONS[alteration[1]], alteration[0])
                }
            }

        //otherwise, if a member is specified, we can get their collective statuses that way
        } else if(member?.components || member?.alterations || member?.augments) {
            for (const statusObj of getPassiveStatusesForPartyMember(member)) {
                addStatusLine(statusObj)
            }
        }
    }

    for (const statName in stats) {
        const statInfo = env.STATDATA[statName]

        if(statInfo) {
            var statValue = stats[statName]
            let goodClass = false

            //we show all HP if a member is specified
            if(statName == "maxhp" && member) {
                statValue += env.COMBAT_ACTORS[member.combatActor].maxhp
            }

            if(statValue > 0) {
                switch(statInfo.good) {
                    case "+":
                        goodClass = "good"
                    break
                    case "-":
                        goodClass = "bad"
                    break
                }
            } else if (statValue < 0) {
                switch(statInfo.good) {
                    case "+":
                        goodClass = "bad"
                    break
                    case "-":
                        goodClass = "good"
                    break
                }
            }
            
            let list = "core"
            if(statName.includes("incoming")) list = "in"
            else if(statName.includes("outgoing")) list = "out"

            returnStats[list] += `
                <div class="stat ${statName.includes("outgoing") ? "outgoing" : ""} ${statName.includes("incoming") ? "incoming" : ""}" 
                    type="${statName}" 
                    pretty="${statInfo ? statInfo.display : statName}"
                    definition="INFO::${statInfo ? statInfo.description : "'not found'"}"
                    ${goodClass ? `good=${goodClass}` : ""}
                >${statValue > 0 && statName != "maxhp" ? "+" : ""}${statInfo.percentage ?
                    `${statValue * 100}%`
                    :
                    statValue
                }</div>
            `
        }
    }

    returnStats.all = returnStats.core + returnStats.in + returnStats.out
    if(returnStats.all == "") return false
    return returnStats
},

window.showTargets = function showTargets(actor, action, actionItem = false) {
    if(env.rpg.is2D && !action.type.includes("boxtarg")) return env.rpg.showTargets(actor, action, actionItem)

    var itemNote = "";
    if(actionItem) {itemNote = `<span class='item-note'>(via ${actionItem.name})</span>`}
    env.rpg.querySelector(`.actor#${actor.slug}`).insertAdjacentHTML('beforeend',
        `
        <div class="target-notice">
            <span><span class="neutral">${action.verb ? action.verb : action.name}</span> whom?</span>
            ${itemNote}
            <span class="target-nevermind">NEVERMIND</span>
        </div>
        `
    );

	if(env.rpg.turnOrder.length < 18) { // softlock prevention for summon heavy teams
		env.rpg.classList.add('targeting')
	}
    //animates the target notice in after a short delay
    var targetNotice = env.rpg.querySelector('.target-notice')
    setTimeout(()=>{
        targetNotice.classList.add('active');
    }, 200);

    //hides the notice & shows their skills again if they go back
    env.rpg.nevermind = ()=>{
        MUI("off")
        targetNotice.classList.remove('active')
        clearActionsDisplay()
        showActions(actor)

        delete env.rpg.nevermind
    }
    env.rpg.querySelector('.target-nevermind').addEventListener('mousedown', env.rpg.nevermind);

    //makes the targetable actor panels glow and execute chooseTarget when clicked
    //has default regular targets - anything not self, dead, or last-standing
    let targetQuery = `.actor:not(#${actor.slug}):not(.dead):not(.last-stand):not(.status-untargetable)`

    //optional additional targets based on what the type is
    if(action.type.includes("self")) targetQuery += `, .actor#${actor.slug}`
    if(action.type.includes("rez")) targetQuery += `, .actor.dead`
    if(action.type.includes("support")) targetQuery =  `#${actor.team.name}-team ` + targetQuery

    //add targetable states
    env.rpg.querySelectorAll(targetQuery).forEach(el=>el.classList.add('targetable'))
    
    //store the event as a prop on the element for later dispelling
    env.rpg.querySelectorAll('.actor.targetable .clickbox').forEach(el=>{
        el.clickCallback = function(){
            chooseTarget(actor, action, env.rpg.actors[el.getAttribute('actor-id')], actionItem)
        };
        el.addEventListener('mousedown', el.clickCallback)
    })
}

window.showActions = function showActions(actor) {
    if(env.rpg.turnData.showingActions) { clearActionsDisplay() }
    env.rpg.turnData.showingActions = true
    let baseActor = env.COMBAT_ACTORS[actor.slug] //gets the original object with included functions
    let rpgActor = env.rpg.allyTeam.members.find(member => member.slug == actor.slug) //gets live object with statuses, hp, etc
    let actorEl = env.rpg.querySelector(`#${actor.slug}`);
    if(!actorEl) return;
    let actionsEl = env.rpg.querySelector(`#${actor.slug} .actions`);
    actorEl.classList.add('acting');

    //activate their windup options if they have windup
	// hiiii corruu why in gods green fuck is this how windup actions work
    let actionPool = actor.actions
    if(hasStatus(rpgActor, "windup") && actor.windupActions) { 
        actionPool = actor.windupActions
    }
	if(hasStatus(rpgActor, "winderup") && actor.winderupActions) { 
        actionPool = actor.winderupActions
    }
	if(hasStatus(rpgActor, "windestup") && actor.windestupActions) { 
        actionPool = actor.windestupActions
    }
	if(hasStatus(rpgActor, "final_windup") && actor.finalWindupActions) { 
        actionPool = actor.finalWindupActions
    }
	if(hasStatus(rpgActor, "windup_telegraph_flat") && actor.windupActions) { 
        actionPool = actor.windupActions
    }
	if(hasStatus(rpgActor, "windup_aim") && actor.aimingActions) { 
        actionPool = actor.aimingActions
    }

    //some statuses grant actions! yay!
    if(actor?.grantedActions?.length) actionPool = actionPool.concat(actor.grantedActions);

    //to avoid weird softlocks
    if(env.rpg.is2D && hasStatus(actor, "fear") && actor.actions.includes("scene_evade")) {
        actionPool = [...actor.actions]
        actionPool.push("cower")
    }

    actionPool.forEach(actName => {
        let action = env.ACTIONS[actName]
        let definition = `ACTION++${action.slug}`
        let disabled = false

        if(action.disableIf) disabled = action.disableIf(actor)
        if(disabled) definition = disabled
        
        const actionEl = document.createElement('span')
        actionEl.classList.add('action')
        if (disabled) { actionEl.classList.add('disabled') }
        actionEl.setAttribute('action', action.slug)
        actionEl.setAttribute('definition', definition)
        actionEl.textContent = action.name
        actionEl.action = action
        actionsEl.appendChild(actionEl)
    });

    if(page?.party?.inventory?.length) {
        if(page.party.inventory.length == 1 && page.party.inventory[0][0].slug == "sfer_cube") {
            //don't do this
        } else {
            actionsEl.insertAdjacentHTML('afterbegin', `<details class="item-container"><summary>Use Item</summary></details>`)
            page.party.inventory.forEach(itemPair => {
                let item = itemPair[0];
                if(item.combatAction){
                    if(item.usableBy) if(!item.usableBy.includes(actor.slug)) return

                    let itemAction = env.rpg.is2D ? (item.sceneAction || item.combatAction) : item.combatAction

                    const container = env.rpg.querySelector(`#${actor.slug} .item-container`)
                    const itemEl = document.createElement('span')
                    itemEl.classList.add('action')
                    itemEl.setAttribute('action', itemAction.slug)
                    itemEl.setAttribute('item', item.slug)
                    itemEl.setAttribute('definition', `ACTION++${itemAction.slug}`)
                    itemEl.action = itemAction
                    itemEl.item = item
                    itemEl.textContent = `${item.name} ${item.infinite ? "" : `x${itemPair[1]}`}`
                    container.appendChild(itemEl)
                }
            })
        }
    }

    env.rpg.querySelectorAll(`#${actor.slug} .actions .action:not(.disabled)`).forEach(el=>{
        el.addEventListener('mousedown', function(){
            MUI("off")
            let actionItem = el.item
            let action = el.action
            let parentEl = actor.box.querySelector(".actions")
    
            if(action.type.includes("target") || action.type.includes("ground")) {
                showTargets(actor, action, actionItem);
            } else { //DOES NOT NEED A TARGET - handle any special execs (i.e. auto AOEs or something) in the action itself
                chooseTarget(actor, action, actor, actionItem);
            }
            
            //hides action list
            parentEl.classList.add('turnover')
        })

        //in combat scene, we also show some range info if it's relevant
        if(env.rpg.is2D){
            let action = el.action
            //on mouse enter, we'll set up the env.rpg.markedPreviewTiles and env.rpg.markedPreviewTileClasses arrays
            el.addEventListener('mouseenter', function(){
                if(env.rpg.markedPreviewTiles && env.rpg.markedPreviewAction != action) { 
                    env.rpg.markedPreviewTiles.forEach(tile => tile.classList.remove(... env.rpg.markedPreviewTileClasses)) 
                } else if((env.rpg.markedPreviewTiles && env.rpg.markedPreviewAction == action)) return; //only show/render range stuff when relevant

                if( //we return here because we only care about removing AOE markers for self/special
                    (action.type.includes("autohit") || action.type.includes("special")) && 
                    !action?.stats?.extraAOE
                ) { env.rpg.markedPreviewTiles = false; return; }

                env.rpg.markedPreviewAction = action
                env.rpg.markedPreviewTileClasses = ["targetable-preview"]
                
                if(!action.type.includes("autohit") && !action.type.includes("special")) {
                    env.rpg.markedPreviewTiles = env.rpg.grid.markTiles({
                        originTile: actor.piece.tile,
                        shape: action.targeting || 'square',
                        size: action?.stats?.range || action.range || 1,
                        addClass: "targetable-preview",
                        ignoresObstacles: action.ignoresBlocks || false,
                        ignoresLOS: action.ignoresLOS,
                        ignoresActors: action.ignoresActors,
                        requiresPath: action.requiresPath,
                        includesOrigin: action.type.includes("self") || action.type.includesOrigin,
                        onTileCheck: ({tile, validity, validTiles, data}) => {
                            if(tile.untargetable) return false
                            return true
                        }
                    })
                } else {
                    env.rpg.markedPreviewTiles = []
                }

                if(action?.stats?.extraAOE) for (const aoeName in action.stats.extraAOE) {
                    const aoeInfo = action.stats.extraAOE[aoeName]
                    if(aoeInfo.origin == "self")  {
                        env.rpg.markedPreviewTiles = env.rpg.markedPreviewTiles.concat(env.rpg.grid.markTiles({
                            originTile: actor.piece.tile,
                            shape: aoeInfo.shape || 'square',
                            size: aoeInfo.size || 1,
                            addClass: aoeInfo.addClass,
                            ignoresObstacles: aoeInfo.ignoresBlocks,
                            ignoresLOS: aoeInfo.ignoresLOS,
                            ignoresActors: aoeInfo.ignoresActors,
                            requiresPath: aoeInfo.requiresPath,
                            includesOrigin: typeof aoeInfo.includesOrigin == "undefined" ? true : aoeInfo.includesOrigin,
                        }))

                        env.rpg.markedPreviewTileClasses.push(aoeInfo.addClass)
                    }
                }
            })

            el.addEventListener('mouseleave', function(){
                if(env.rpg.markedPreviewTiles) { 
                    env.rpg.markedPreviewTiles.forEach(tile => tile.classList.remove(... env.rpg.markedPreviewTileClasses)) 
                    env.rpg.markedPreviewAction = false
                }
            })
        }
    })
}

window.enemyTurn = function enemyTurn(enemy) {
    //determine target pools
    //enemy/ally is relative to the player's POV, i.e. "enemy" are enemy's allies
    var targetPools = {
        enemy_dead: env.rpg.enemyTeam.members.filter(actor => actor.state == "dead"),
        enemy_alive: env.rpg.enemyTeam.members.filter(actor => (actor.state != "dead") && (actor.slug != enemy.slug)),
        enemy_all: env.rpg.enemyTeam.members.filter(actor => (actor.slug != enemy.slug)),

        ally_alive: env.rpg.allyTeam.members.filter(actor => actor.state != "dead"),
        everyone_alive: env.rpg.allyTeam.members.concat(env.rpg.enemyTeam.members)
    }

    let priority = env.rpg.allyTeam.members.filter(actor=>actor.priorityTarget && actor.state != "dead")
    if(priority.length) {
        targetPools.ally_alive = priority
    }

    //if the enemy has a special per-turn check, execute it here
    var shouldBreak = false;
    if(enemy.turnCheck) { shouldBreak = env.COMBAT_TURNCHECKS[enemy.turnCheck](enemy, {targets: targetPools}) }
    if(shouldBreak) return;

    //redirect to alternate system if needed
    if(env.rpg.is2D) return env.rpg.enemyTurn(enemy)

    //proceed with action selection
    //if the enemy has the 'windup' status, draw from windupActions instead
	//corruuuuuuu whyyyyyyyy :(
    let actionNamePool = enemy.actions
    if(hasStatus(enemy, "windup") && enemy.windupActions) { actionNamePool = enemy.windupActions }
	if(hasStatus(enemy, "windup_telegraph_flat") && enemy.windupActions) { actionNamePool = enemy.windupActions }
	if(hasStatus(enemy, "windup_aim") && enemy.aimingActions) { actionNamePool = enemy.aimingActions }
    else if(!enemy.windupActions) { removeStatus(enemy, "windup"), removeStatus(enemy, "windup_telegraph_flat") }
	if(hasStatus(enemy, "winderup") && enemy.winderupActions) { actionNamePool = enemy.winderupActions }
	else if(!enemy.winderupActions) { removeStatus(enemy, "winderup") }
	if(hasStatus(enemy, "windestup") && enemy.windestupActions) { actionNamePool = enemy.windestupActions }
	else if(!enemy.windestupActions) { removeStatus(enemy, "windestup") }
	if(hasStatus(enemy, "final_windup") && enemy.finalWindupActions) { actionNamePool = enemy.finalWindupActions }
	else if(!enemy.finalWindupActions) { removeStatus(enemy, "final_windup") }

	//sola edit, give enemies their items as actions (thanks sola :D)
        addEnemyItemActions(enemy, actionNamePool) 

    let actionPool = []
    actionNamePool.forEach(actionName => {
        let action = env.ACTIONS[actionName]
        let usable = true

        //action-based disable checks
        if(action.enemyUsageIf) usable = action.enemyUsageIf(enemy) 
        if(usable && action.disableIf) usable = !action.disableIf(enemy)

        //avoidChaining filtering - some abilities shouldn't be used repeatedly
        if(enemy.lastUsed) 
            if(enemy.lastUsed.avoidChaining && (action.slug == enemy.lastUsed.slug))
                usable = false

        //last man standing support skill avoidance
        //basically, if they're the last guy trying to use an ally non-self buff, try to pick an attack or self-buff instead
        if(
            targetPools.enemy_alive.length == 0 &&
            (
                action.type.includes('support') && 
                !action.type.includes('self') &&
                !action.type.includes("rez")
            )
        ) usable = false
        
        if(usable) actionPool.push(action)
    })

    let action = actionPool.length ? actionPool.sample() : env.ACTIONS["nothing"]

    var target;
    if(action.type.includes('self')) {
        targetPools.enemy_alive.push(enemy)
        targetPools.everyone_alive.push(enemy)
    }

    if(action.type.includes('random')) {
        target = targetPools.everyone_alive.sample()
    } else if (action.type.includes('rez') && action.type.includes('support')) {
        target = targetPools.enemy_all.sample()
    } else if (action.type.includes('rez')) {
        target = targetPools.enemy_dead.sample()
    } else if (action.type.includes('support')) {
        target = targetPools.enemy_alive.sample()
    } else {
        target = targetPools.ally_alive.sample()
    }

    var executionTime = env.ADVANCE_RATE * 0.5;
    setTimeout(()=>{
        try {
            switch(action.type.includes('special')) {					
                case true:
                    useAction(enemy, action, target);
					
					// sola edit
                    actorItemUseCheck(enemy, action.slug)
                    break;

                default: 
                    var hit = useAction(enemy, action, target);
                    setTimeout(()=>advanceTurn(enemy), env.ADVANCE_RATE);
					// sola edit
                    actorItemUseCheck(enemy, action.slug)
					
                    switch(hit) {
                        case null: case "nothing":
                            break;
                        case "crit":
                            reactDialogue(enemy, 'crit');
                            break;
                        case true:
                            reactDialogue(enemy, 'hit');
                            break;
                        case false:
                            reactDialogue(enemy, 'miss');
                            break;
                    }					
            }
        } catch(e) {printError(e); printError('proceeding to next turn', false); setTimeout(()=>advanceTurn(enemy), env.ADVANCE_RATE); }
        //actor.history.push(action)
    }, executionTime);
}

window.generatePartyActions = function generatePartyActions(member) {
    let returnString = ``
    let combatActor = env.COMBAT_ACTORS[member.combatActor || member.originalSlug]
    if(member.mimic) combatActor = member.mimic

    let pool = combatActor.actions
    if(check("PAGE!!embassy_day", 3.99)) pool = combatActor.sceneActions || pool

    returnString += generatePoolActions(member, pool)
    if(combatActor.windupActions && !check("PAGE!!embassy_day", 3.99)) returnString += generatePoolActions(member, combatActor.windupActions, {poolClass: 'windup-action', poolNotice: "'requires WINDUP';"})
	if(combatActor.winderupActions && !check("PAGE!!embassy_day", 3.99)) returnString += generatePoolActions(member, combatActor.winderupActions, {poolClass: 'winderup-action', poolNotice: "'requires WINDUP+';"})
	if(combatActor.windestupActions && !check("PAGE!!embassy_day", 3.99)) returnString += generatePoolActions(member, combatActor.windestupActions, {poolClass: 'windestup-action', poolNotice: "'requires WINDUP++';"})
	if(combatActor.finalWindupActions && !check("PAGE!!embassy_day", 3.99)) returnString += generatePoolActions(member, combatActor.finalWindupActions, {poolClass: 'final_windup-action', poolNotice: "'requires WINDUP+++';"})
	if(combatActor.aimingActions && !check("PAGE!!embassy_day", 3.99)) returnString += generatePoolActions(member, combatActor.aimingActions, {poolClass: 'aiming-action', poolNotice: "'requires AIMING';"})
    
	return returnString
}

function randomInt(min, max) { // min and max included <---- thank you, random stackoverflow user
  return Math.floor(Math.random() * (max - min + 1) + min);
}
/* this didn't work :(
env.COMBAT_ACTORS.falsecritta.events.onInitialize = (actor) => { 
	let impulseStrength = Math.max(env.crittaMap.getModQty("global_anti") - 5, 0)
	let selections = shuffle(env.crittaMap.possibleZoneComponents.map(component => component.slug).splice(0, env.crittaMap.tension))

	actor.alterations = [] // just to trigger alterations
	actor.components = {}
	let slotShuffle = shuffle(["primary", "secondary", "utility"])

	for (const slotName of slotShuffle) {
		let selection = false
		selection = selections.shift()

		if(selection) {
			selection.replace("intrusive", "light");
			selection.replace("cmb", "metal");
		} else {
			break
		}
	}
	
	if(impulseStrength) {
		let possibleImpulses = shuffle(Object.entries(env.STATUS_EFFECTS).filter(entry => entry[1].impulse))
		possibleImpulses = possibleImpulses.filter(entry => !["ichor_last_stand", "chaos_locknload", "intrusive_maladaptive", "hands_daemon", "chaos_backup"].includes(entry[0]))
		for (let i = 0; i < impulseStrength; i++) {
			actor.alterations.push(["STATUS", possibleImpulses.sample()[0], "IMPULSE"])
		}
	}

	console.log('generated anti', actor)
},
*/

	env.STATUS_EFFECTS.global_madness_impulse = {
        slug: "global_impulse_bonus",
        name: "Into Madness",
        icon: "/img/sprites/bstrd/icon.gif",        
        events: {
            onCreated: function({statusObj}) {
                if(statusObj.slug != this.status.slug) return;

                let possible = Object.entries(env.STATUS_EFFECTS).filter(entry => entry[1].impulse).map(entry => entry[1].slug)
                possible = possible.filter(slug => !["ichor_last_stand", "chaos_locknload", "intrusive_maladaptive", "hands_daemon", "chaos_backup"].includes(slug))
                let power = env.crittaMap.getModQty("global_impulse_bonus")

                if(power) {
                    for (let i = 0; i < power; i++) {
                        addStatus({target: this.status.affecting, status: possible.sample(), noReact: true, length: 1})
                    }
                }

                setTimeout(() => {removeStatus(this.status.affecting, "global_impulse_bonus", {runEvents: false}); updateStats(this.status.affecting)}, 100)
            }
        },

        help: `this actor receives a random impulse per stack of Into Madness`
    }

// MISCELLANEOUS
	//ITEM_EXECS
    env.ITEM_EXEC.superstitionFish = (target) => {
        if(!target.alterations) target.alterations = []
        if(target.alterations.find(alteration => alteration[2] == "TAROTFISH")) {
            chatter({actor: 'sourceless', text: `the shell refuses, having lost their taste for this fish.`, readout: true, sfx: false})
            return play('muiClick', 2);
        }
        
        target.alterations.push(["STATUS", "hands_superstition", "TAROTFISH"])
        play('talkfairy', 2)
        removeItem(env.ITEM_LIST.fish_tarot)
        if(env.crittaMenu) if(env.crittaMenu.style.opacity == 1) toggleCrittaMenu()
    }

	env.ITEM_EXEC.fish_bfg9k = (target) => {
        if(!target.alterations) target.alterations = []
        if(target.alterations.find(alteration => alteration[2] == "BFG9K")) {
            chatter({actor: 'sourceless', text: `the shell refuses, having lost their taste for this fish.`, readout: true, sfx: false})
            return play('muiClick', 2);
        }
        
        target.alterations.push(["ADD", "windup_bfg", "BFG9K"], ["ADD_WINDUP", "bfg_shot", "BFG9K"])
        play('talkgal', 0.4)
        removeItem(env.ITEM_LIST.fish_bfg9k)
        if(env.crittaMenu) if(env.crittaMenu.style.opacity == 1) toggleCrittaMenu()
    }

	env.ITEM_EXEC.fish_fal = (target) => {
        if(!target.alterations) target.alterations = []
        if(target.alterations.find(alteration => alteration[2] == "FAL")) {
            chatter({actor: 'sourceless', text: `the shell refuses, having lost their taste for this fish.`, readout: true, sfx: false})
            return play('muiClick', 2);
        }
        
        target.alterations.push(["ADD", "special_fullauto_heavy", "FAL"])
        play('talkgal', 0.4)
        removeItem(env.ITEM_LIST.fish_fal)
        if(env.crittaMenu) if(env.crittaMenu.style.opacity == 1) toggleCrittaMenu()
    }

	env.ITEM_EXEC.fish_m32 = (target) => {
        if(!target.alterations) target.alterations = []
        if(target.alterations.find(alteration => alteration[2] == "M32")) {
            chatter({actor: 'sourceless', text: `the shell refuses, having lost their taste for this fish.`, readout: true, sfx: false})
            return play('muiClick', 2);
        }
        
        target.alterations.push(["ADD", "special_fullauto_grenade", "M32"])
        play('talkgal', 0.4)
        removeItem(env.ITEM_LIST.fish_m32)
        if(env.crittaMenu) if(env.crittaMenu.style.opacity == 1) toggleCrittaMenu()
    }

	env.ITEM_EXEC.fish_m82 = (target) => {
        if(!target.alterations) target.alterations = []
        if(target.alterations.find(alteration => alteration[2] == "M82")) {
            chatter({actor: 'sourceless', text: `the shell refuses, having lost their taste for this fish.`, readout: true, sfx: false})
            return play('muiClick', 2);
        }
        
        target.alterations.push(["ADD", "windup_amr", "M82"], ["ADD", "daze_lastresort_mega", "M82"], ["ADD_WINDUP", "hold_aim_amr", "M82"], ["ADD_WINDUP", "focused_shot_amr", "M82"])
        play('talkgal', 0.4)
        removeItem(env.ITEM_LIST.fish_m82)
        if(env.crittaMenu) if(env.crittaMenu.style.opacity == 1) toggleCrittaMenu()
    }

	env.ITEM_EXEC.fish_ssg = (target) => {
        if(!target.alterations) target.alterations = []
        if(target.alterations.find(alteration => alteration[2] == "SSG")) {
            chatter({actor: 'sourceless', text: `the shell refuses, having lost their taste for this fish.`, readout: true, sfx: false})
            return play('muiClick', 2);
        }
        
        target.alterations.push(["ADD", "fullauto_shotgun_mega", "SSG"])
        play('talkgal', 0.4)
        removeItem(env.ITEM_LIST.fish_ssg)
        if(env.crittaMenu) if(env.crittaMenu.style.opacity == 1) toggleCrittaMenu()
    }

	//ITEMS
	env.ITEM_LIST.fish_tarot = {
        slug: "fish_tarot",
        name: "Card Fish",
        imgClass: "fish",
        image: "/img/sprites/flantrusive/flanfisch.gif",
        description: `'invasive species mimicking intrusive species';'clutching strange deck of cards'`,
        oocnote: "'<strong>PERMANENT</strong>';'select shell';'imbue with superstition'",
        type: 'target',
        exec: "superstitionFish",
        group: "fish",
        max: 10,
        batches: 1
    }
	
	env.ITEM_LIST.fish_bfg9k = {
        slug: "fish_bfg9k",
        name: "Bright Weapon",
        imgClass: "fish",
        image: "https://narrativohazard-expunged.neocities.org/img/fishies/fish_bfg9k.gif",
        description: `'discarded bright weaponry paired with knowledge cyst';'cyst is titled "ON THE USE OF THE BFG9000"'`,
        oocnote: "'<strong>PERMANENT</strong>';'select shell';'equip powerful symbiotic weaponry'",
        type: 'target',
        exec: "fish_bfg9k",
        group: "fish",
        max: 10,
        batches: 1
    }
	
	env.ITEM_LIST.fish_fal = {
        slug: "fish_fal",
        name: "Bright Weapon",
        imgClass: "fish",
        image: "https://narrativohazard-expunged.neocities.org/img/fishies/fish_fal.gif",
        description: `'discarded bright weaponry paired with knowledge cyst';'cyst is titled "ON THE USE OF THE FN HERSTAL FAL"'`,
        oocnote: "'<strong>PERMANENT</strong>';'select shell';'equip powerful symbiotic weaponry'",
        type: 'target',
        exec: "fish_fal",
        group: "fish",
        max: 10,
        batches: 1
    }
	
	env.ITEM_LIST.fish_m32 = {
        slug: "fish_m32",
        name: "Bright Weapon",
        imgClass: "fish",
        image: "https://narrativohazard-expunged.neocities.org/img/fishies/fish_m32.gif",
        description: `'discarded bright weaponry paired with knowledge cyst';'cyst is titled "ON THE USE OF THE MILKOR USA M32A1"'`,
        oocnote: "'<strong>PERMANENT</strong>';'select shell';'equip powerful symbiotic weaponry'",
        type: 'target',
        exec: "fish_m32",
        group: "fish",
        max: 10,
        batches: 1
    }
	
	env.ITEM_LIST.fish_m82 = {
        slug: "fish_m82",
        name: "Bright Weapon",
        imgClass: "fish",
        image: "https://narrativohazard-expunged.neocities.org/img/fishies/fish_m82.gif",
        description: `'discarded bright weaponry paired with knowledge cyst';'cyst is titled "ON THE USE OF THE BARRETT M82"'`,
        oocnote: "'<strong>PERMANENT</strong>';'select shell';'equip powerful symbiotic weaponry'",
        type: 'target',
        exec: "fish_m82",
        group: "fish",
        max: 10,
        batches: 1
    }
	
	env.ITEM_LIST.fish_ssg = {
        slug: "fish_ssg",
        name: "Bright Weapon",
        imgClass: "fish",
        image: "https://narrativohazard-expunged.neocities.org/img/fishies/fish_ssg.gif",
        description: `'discarded bright weaponry paired with knowledge cyst';'cyst is titled "ON THE USE OF BREAK-ACTION SHOTGUNS"'`,
        oocnote: "'<strong>PERMANENT</strong>';'select shell';'equip powerful symbiotic weaponry'",
        type: 'target',
        exec: "fish_ssg",
        group: "fish",
        max: 10,
        batches: 1
    }
	
	//FISHIES
	FishingMinigame.fishies.fish_tarot = {
		item: "fish_tarot",
		stats: {
			"--fishspeed-x": [6, 9],
			"--fishspeed-y": [3, 7],
			"--fishspeed-rot": [1, 2],

			jumpRate: 1.5,
			jumpMod: 3,
			pullMod: 1,
			adjustMod: 1.1,
		}
	}
	
	FishingMinigame.fishies.fish_bfg9k = {
		item: "fish_bfg9k",
		stats: { 
			"--fishspeed-x": [1, 4], 
			"--fishspeed-y": 2,
			"--fishspeed-rot": [1, 2],

			jumpRate: 2, 
			jumpMod: 1, 
			pullMod: 0.25,
			adjustMod: 0.5, 
		},
		showIf: () => check("reward_bfg")
	}
	
	FishingMinigame.fishies.fish_fal = {
		item: "fish_fal",
		stats: {
			"--fishspeed-x": [10, 15], 
			"--fishspeed-y": 2,
			"--fishspeed-rot": [10, 15],

			jumpRate: 1, 
			jumpMod: 2, 
			pullMod: 2,
			adjustMod: 0.75, 
		},
		showIf: () => check("reward_rifle")
	}
	
	FishingMinigame.fishies.fish_m32 = {
		item: "fish_m32",
		stats: {
			"--fishspeed-x": [10, 15], 
			"--fishspeed-y": 2,
			"--fishspeed-rot": [10, 15],

			jumpRate: 1, 
			jumpMod: 2, 
			pullMod: 2,
			adjustMod: 0.75, 
		},
		showIf: () => check("reward_grenade")
	}
	
	FishingMinigame.fishies.fish_m82 = {
		item: "fish_m82",
		stats: {
			"--fishspeed-x": [10, 15], 
			"--fishspeed-y": 2,
			"--fishspeed-rot": [10, 15],

			jumpRate: 1, 
			jumpMod: 2, 
			pullMod: 2,
			adjustMod: 0.75, 
		},
		showIf: () => check("reward_sniper")
	}
	
	FishingMinigame.fishies.fish_ssg = {
		item: "fish_ssg",
		stats: {
			"--fishspeed-x": [10, 15], 
			"--fishspeed-y": 2,
			"--fishspeed-rot": [10, 15],

			jumpRate: 1, 
			jumpMod: 2, 
			pullMod: 2,
			adjustMod: 0.75, 
		},
		showIf: () => check("reward_shotgun")
	}
	
	//MUSIC
	env.e3a2.hazardous = new Howl({
		onload: function () {page.howls.push(this)},
		src: ['/audio/daemon_escape.ogg'],
		preload: true,
		loop: true,
		volume: 1,
		rate: 0.3,
		sprite: {
			__default: [0, 188948, true]
		},
		onend: function() {
			env.e3a2.hazardous.seek(14.2)
		}
	})
	env.e3a2.hazardous.intendedVol = 1
	env.e3a2.hazardous.intendedRate = 0.3
		
	env.e3a2.interviewer = new Howl({
		onload: function () {page.howls.push(this)},
		src: ['/audio/embassy_golems_unsafe.ogg'],
		preload: true,
		loop: true,
		volume: 1,
		rate: 0.3,
		sprite: {
			__default: [0, 188948, true]
		},
	})
	env.e3a2.interviewer.intendedVol = 1
	env.e3a2.interviewer.intendedRate = 0.3
		
	env.e3a2.citadel = new Howl({
		onload: function () {page.howls.push(this)},
		src: ['/audio/solarisen.ogg'],
		preload: true,
		loop: true,
		volume: 1,
		rate: 0.3,
		sprite: {
			__default: [0, 188948, true]
		},
	})
	env.e3a2.citadel.intendedVol = 1
	env.e3a2.citadel.intendedRate = 0.3
	
	env.e3a2.firing_squad = new Howl({
		onload: function () {page.howls.push(this)},
		src: ['/audio/embassy_bstrdcomb.ogg'],
		preload: true,
		loop: true,
		volume: 1,
		rate: 0.3,
		sprite: {
			__default: [0, 188948, true]
		},
	})
	env.e3a2.firing_squad.intendedVol = 1
	env.e3a2.firing_squad.intendedRate = 0.3
	
	env.e3a2.intrusive_rematch = new Howl({
		onload: function () {page.howls.push(this)},
		src: ['/audio/testing_combat.ogg'],
		preload: true,
		loop: true,
		volume: 1,
		rate: 0.25,
		sprite: {
			__default: [0, 188948, true]
		},
	})
	env.e3a2.intrusive_rematch.intendedVol = 1
	env.e3a2.intrusive_rematch.intendedRate = 0.25
	
	//COMBAT FORMATIONS
	env.COMBAT_FORMATIONS.hazardous = {
        name: "!!!!!!",
        help: "'context missing or removed';'potentially hazardous to render';'caution advised'",
        enemies: ["hazardous"],
        class: "intrusivefight summonerboss",
        advanceRate: 1000,
        bgmRate: 0.3,
        getBgm: ()=> {return env.e3a2.hazardous}
    }
	
	env.COMBAT_FORMATIONS.interviewer = {
        name: "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ",
        help: "'malformed context';'potential intra-thoughtspace memory bleed';'altered by extreme nearby incoherence'",
        enemies: ["interviewer"],
        class: "intrusivefight",
        advanceRate: 1000,
        bgmRate: 0.3,
        getBgm: ()=> {return env.e3a2.interviewer}
    }
	
	env.COMBAT_FORMATIONS.citadel = {
        name: "4349544144454C",
        help: "'unusual context';'implies extra-thoughtspace memory bleed'",
        enemies: ["cmb_mainfoe"],
        class: "intrusivefight summonerboss",
        advanceRate: 1000,
        bgmRate: 0.3,
        getBgm: ()=> {return env.e3a2.citadel}
    }
	
	env.COMBAT_FORMATIONS.firing_squad = {
        name: "FIRING SQUAD",
        help: "'evil mode';'hehe'",
        enemies: ["bstrdboss_sniper", "bstrdboss_shotgun", "bstrdboss_rifle", "bstrdboss_grenade", "bstrdboss_bfg"],
        class: "intrusivefight",
        advanceRate: 1000,
        bgmRate: 0.3,
        getBgm: ()=> {return env.e3a2.firing_squad}
    }
	
	env.COMBAT_FORMATIONS.intrusive_rematch = {
        name: "??????",
        help: "'unprocessable entity';'previously encountered thoughtform'",
        enemies: ["intrusive_rematch"],
        class: "intrusivefight summonerboss",
        advanceRate: 1000,
        bgmRate: 0.25,
        getBgm: ()=> {return env.e3a2.intrusive_rematch}
    }
	
/* INVENTORY CONTROLS */
// thank you sola !!!! :D
// edit of addItem() from combat.js
// takes the actor object itself, and the the item slug whatever string, and amount of item
// works exactly like you would expect it to
function addItemEnemy(actor, newItem, n = 1) {
	if (!actor.inventory) {
		actor.inventory = [];
		console.warn("attempted to add an item to a creature with no inventory, gave them an inventory first :p")
	}
    let itemObj = typeof newItem == "string" ? env.ITEM_LIST[newItem] : newItem

    if(!itemObj) {
        chatter({actor: 'actual_site_error', text: `you're trying to add an item that doesn't exist!`, readout: true})
        itemObj = env.ITEM_LIST.error
    }

    let i = actor.inventory.findIndex(item => item[0].slug === itemObj.slug);
    let newNum

    // postep4todo: make item adds not fail if they WOULD go over max, only if they ARE at max
    // only reason this isn't done for EP4 is because it would screw with loot dialogue in earlier episodes that rely on the failure
    if(i >= 0) {
        if((actor.inventory[i][1] + n) > actor.inventory[i][0].max) { return false }
        actor.inventory[i][1] += n;
        newNum = actor.inventory[i][1]
    } else { //it's new, ignore anything over the max
        let maxN = (n < itemObj.max) ? n : itemObj.max;
        actor.inventory.push([itemObj, maxN]);
        newNum = maxN
    }

    document.dispatchEvent(new CustomEvent('corru_changed', { detail: { key: `ITEM!!${itemObj.slug}`, value: newNum} }));
    return true
}

// edit of checkItem() from combat.js
// takes the actor object itself, and the the item slug whatever string
//returns the amount you have
// we don't use this but it's good diagnostic i think
function checkItemEnemy(actor, checkItem) {
    if(!actor.inventory) { console.warn("tried to check for an item on an empty inventory"); return false; }

    let effectiveCheckItem = typeof checkItem == "string" ? env.ITEM_LIST[checkItem] : checkItem
    if(!effectiveCheckItem) {
        chatter({actor: 'actual_site_error', text: `you're checking for an item that doesn't exist!`, readout: true})
    }
    let i = actor.inventory.findIndex(item => item[0].slug === effectiveCheckItem.slug);

    var amt = 0;
    if(i >= 0) {
        amt = actor.inventory[i][1];
    }
    return amt;
}

// edit of removeItem() from combat.js
//removes an item (object from main list) from inventory
// takes the actor object itself, the item slug whatever string, and amount to remove
//returns false if you didn't have any
function removeItemEnemy(actor, removeItem, n = 1) {
    let itemObj = typeof removeItem == "string" ? env.ITEM_LIST[removeItem] : removeItem

    let i = actor.inventory.findIndex(item => item[0].slug === itemObj.slug);
    if(i >= 0) {
        if((actor.inventory[i][1] - n) <= 0) {
            actor.inventory.splice(i, 1);
            document.dispatchEvent(new CustomEvent('corru_changed', { detail: { key: `ITEM!!${itemObj.slug}`, value: 0} }));
        } else {
            actor.inventory[i][1] -= n;
            document.dispatchEvent(new CustomEvent('corru_changed', { detail: { key: `ITEM!!${itemObj.slug}`, value: actor.inventory[i][1]} }));
        }

        return true;
    } else {
        return false;
    }
}


// edit of checkItem() from combat.js
// takes the actor object itself,and the string of the action of the item you are checking for
// made so we can find and remove the item from their inventory after usage
// returns the slug of the item if found
function checkItemActionEnemy(actor, itemAction) {
    if(!actor.inventory) { console.log("actor doesnt have an inventory in checkItemActionEnemy, it's probably fine though"); return false; }


	try {
    	return actor.inventory.find(item => item[0].combatAction.slug === itemAction)[0].slug;
	} catch (error) {
	    console.log("i have no clue how we got here with a non item attack, it *probably* doesnt matter lol", error);
	    return false;
	}



}

// find and remove the item tied to the action used... hope you dont have any duplicate actions on items 
function actorItemUseCheck(actor, itemActionName) {
	if(!actor.inventory || !actor.inventory[0]) { console.log("actor doesnt have an inventory or has an empty inventory in actorItemUseCheck, it's probably fine though"); return false; }
	if (!itemActionName) {
		 console.warn("this shoudnt happen in checkItemActionEnemy ")
	}
	let removing = checkItemActionEnemy(actor, itemActionName)
	
	// if we found it
	if (removing) {
		// remove it from the inventory
		removeItemEnemy(actor, removing, 1)
		
		//remove it from their action list
		let index = actor.actions.indexOf(itemActionName);
		if (index !== -1) {
	    	actor.actions.splice(index, 1);
		}
	}
	else 
		console.log("item doesnt exist in inventory in actorItemUseCheck, but this doesnt really matter")
}


function addEnemyItemActions(enemy, actionNamePool) {
	if(enemy.inventory?.length) {
        if(enemy.inventory.length == 1 && enemy.inventory[0][0].slug == "sfer_cube") {
            //don't do this
        } else {
            
            enemy.inventory.forEach(itemPair => {
                let item = itemPair[0];
                if(item.combatAction){
                    if(item.usableBy) if(!item.usableBy.includes(actor.slug)) return

                        // only add the item if we dont have it in the list already
                        if (!actionNamePool.includes(item.combatAction.slug)) {
                            actionNamePool.push(item.combatAction.slug);
                        }    

                }
            })
        }
    }
}
	
}})